<?xml version="1.0" encoding="UTF-8"?>
<!-- Map and JSON functions labelled at="MAP" and commented out -->
<!-- Current changes labelled at="M": post Jan-2013 candidate rec -->
<fos:functions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
   xsi:schemaLocation="http://www.w3.org/xpath-functions/spec/namespace fos.xsd"
   xmlns:fos="http://www.w3.org/xpath-functions/spec/namespace">
   <fos:global-variables>
      <fos:variable name="po" as="element()">&lt;PurchaseOrder&gt; &lt;line-item&gt;
         &lt;description&gt;Large widget&lt;/description&gt; &lt;price&gt;8.95&lt;/price&gt;
         &lt;quantity&gt;5.0&lt;/quantity&gt; &lt;/line-item&gt; &lt;line-item&gt;
         &lt;description&gt;Small widget&lt;/description&gt; &lt;price&gt;3.99&lt;/price&gt;
         &lt;quantity&gt;2.0&lt;/quantity&gt; &lt;/line-item&gt; &lt;line-item&gt;
         &lt;description&gt;Tiny widget&lt;/description&gt; &lt;price&gt;1.49&lt;/price&gt;a
         &lt;quantity&gt;805&lt;/quantity&gt; &lt;/line-item&gt;
         &lt;/PurchaseOrder&gt;</fos:variable>
      <fos:variable name="item1" select="$po/line-item[1]"/>
      <fos:variable name="item2" select="$po/line-item[2]"/>
      <fos:variable name="item3" select="$po/line-item[3]"/>
   </fos:global-variables>
   <fos:function name="node-name">
      <fos:signatures>
         <fos:proto diff="add" at="F" name="node-name" return-type="xs:QName?"/>
         <fos:proto name="node-name" return-type="xs:QName?">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the name of a node, as an <code>xs:QName</code>.</p>
      </fos:summary>
      <fos:rules>
         <p diff="add" at="F">If the argument is omitted, it defaults to the context item
               (<code>.</code>). The behavior of the function if the argument is omitted is exactly
            the same as if the context item had been passed as the argument.</p>
         <p>If <code>$arg</code> is the empty sequence, the empty sequence is returned.</p>
         <p>Otherwise, the function returns the result of the <code>dm:node-name</code> accessor as
            defined in <bibref ref="xpath-datamodel-30"/> (see <xspecref spec="DM30"
               ref="dm-node-name"/>).</p>
      </fos:rules>
      <fos:errors>
         <p diff="add" at="I">The following errors may be raised when <code>$arg</code> is omitted: if the context
            item is <xtermref ref="dt-absent" spec="DM30">absent</xtermref>
            <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a
            node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
         
      </fos:errors>
      <fos:notes>
         <p>For element and attribute nodes, the name of the node is returned as an
               <code>xs:QName</code>, retaining the prefix, namespace URI, and local part.</p>
         <p>For processing instructions, the name of the node is returned as an
               <code>xs:QName</code> in which the prefix and namespace URI are <xtermref
               ref="dt-absent" spec="DM30">absent</xtermref>.</p>
         <p>For a namespace node, the function returns an empty sequence if the node represents the
            default namespace; otherwise it returns an <code>xs:QName</code> in which prefix and
            namespace URI are <xtermref ref="dt-absent" spec="DM30">absent</xtermref> and the local
            part is the namespace prefix being bound).</p>
         <p>For all other kinds of node, the function returns the empty sequence.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="nilled" prefix="fn">
      <fos:signatures>
         <fos:proto name="nilled" return-type="xs:boolean"/>
         <fos:proto name="nilled" return-type="xs:boolean?">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      
      <fos:summary>
         <p>Returns true for an element that is <term>nilled</term>.</p>
      </fos:summary>
      <fos:rules>
         <p>If the argument is omitted, it defaults to the context item (<code>.</code>). The
            behavior of the function if the argument is omitted is exactly the same as if the
            context item had been passed as the argument.</p>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise the function returns the result of the <code>dm:nilled</code> accessor as
            defined in <bibref ref="xpath-datamodel-30"/> (see <xspecref spec="DM30" ref="dm-nilled"
            />).</p>
      </fos:rules>
      <fos:errors>
         <p>The following errors may be raised when <code>$arg</code> is omitted: if the context
            item is <xtermref ref="dt-absent" spec="DM30">absent</xtermref>
            <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a
            node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
         
      </fos:errors>
      <fos:notes>
         <p>If <code>$arg</code> is not an element node, the function returns the empty
            sequence.</p>
         <p>If <code>$arg</code> is an untyped element node, the function returns false.</p>
         <p>In practice, the function returns <code>true</code> only for an element node that has
            the attribute <code>xsi:nil="true"</code> and that is successfully validated against a
            schema that defines the element to be nillable; the detailed rules, however, are defined
            in <bibref ref="xpath-datamodel-30"/>.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="string" prefix="fn">
      <fos:signatures>
         <fos:proto name="string" return-type="xs:string"/>
         <fos:proto name="string" return-type="xs:string">
            <fos:arg name="arg" type="item()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the value of <code>$arg</code> represented as an
            <code>xs:string</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>In the zero-argument version of the function, <code>$arg</code> defaults to the context
            item. That is, calling <code>fn:string()</code> is equivalent to calling
               <code>fn:string(.)</code>.</p>
         <p>If <code>$arg</code> is the empty sequence, the function returns the zero-length
            string.</p>
         <p>If <code>$arg</code> is a node, the function returns the string-value of the node, as
            obtained using the <code>dm:string-value</code> accessor defined in <bibref
               ref="xpath-datamodel-30"/> (see <xspecref spec="DM30" ref="dm-string-value"/>).</p>
         <p>If <code>$arg</code> is an atomic value, the function returns the result of the
            expression <code>$arg cast as xs:string</code> (see <specref ref="casting"/>).</p>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">type</phrase> error is raised <xerrorref spec="XP" class="DY" code="0002" type="type"/> by the
            zero-argument version of the function if the context item is <xtermref ref="dt-absent"
               spec="DM30">absent</xtermref>. </p>
         <p>A <phrase diff="add" at="L">type</phrase> error is raised <errorref class="TY" code="0014" type="type"/> if
               <code>$arg</code> is a function item. </p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>string(23)</fos:expression>
               <fos:result>"23"</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>string(false())</fos:expression>
               <fos:result>"false"</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>string("Paris")</fos:expression>
               <fos:result>"Paris"</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>string(abs#1)</fos:expression>
               <fos:error-result error-code="FOTY0014"/>
            </fos:test>
         </fos:example>
         <fos:variable name="para"><![CDATA[
<para>In a hole in the ground there lived a <term author="Tolkein">hobbit</term>.</para>]]>
         </fos:variable>
         <fos:example>
            <fos:test>
               <fos:expression>string($para)</fos:expression>
               <fos:result>"In a hole in the ground there lived a hobbit."</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="data" prefix="fn">
      <fos:signatures>
         <fos:proto diff="add" at="F" name="data" return-type="xs:anyAtomicType*"/>
         <fos:proto name="data" return-type="xs:anyAtomicType*">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the result of atomizing a sequence, that is, replacing all nodes in the
            sequence by their typed values.</p>
      </fos:summary>
      <fos:rules>
         <p diff="add" at="F">If the argument is omitted, it defaults to the context item
               (<code>.</code>). The behavior of the function if the argument is omitted is exactly
            the same as if the context item had been passed as the argument.</p>
         <p> The result of <code>fn:data</code> is the sequence of atomic values produced by
            applying the following rules to each item in <code>$arg</code>:</p>
         <ulist>
            <item>
               <p>If the item is an atomic value, it is appended to the result sequence.</p>
            </item>
            <item>
               <p> If the item is a node, the typed value of the node is appended to the result
                  sequence. The typed value is a sequence of zero or more atomic values:
                  specifically, the result of the <code>dm:typed-value</code> accessor as defined in
                     <bibref ref="xpath-datamodel-30"/> (See <xspecref spec="DM30"
                     ref="dm-typed-value"/>).</p>
            </item>
         </ulist>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">type</phrase> error is raised <errorref class="TY" code="0012" type="type"/> if an item in the
            sequence <code>$arg</code> is a node that does not have a typed value. </p>
         <p diff="add" at="B">A <phrase diff="add" at="L">type</phrase> error is raised <errorref class="TY" code="0013" type="dynamic"/>
            if an item in the sequence <code>$arg</code> is a function item. </p>
         <p diff="add" at="I">The following <phrase diff="add" at="L">type</phrase> error may be raised when <code>$arg</code> is omitted: 
               if the context item is <xtermref ref="dt-absent" spec="DM30">absent</xtermref>
               <xerrorref spec="XP" class="DY" code="0002" type="type"/><phrase diff="del" at="L">; if the context item is not a
               node <xerrorref spec="XP" class="TY" code="0004" type="type"/></phrase>.</p>
            
         
      </fos:errors>
      <fos:notes>
         <p>The process of applying the <code>fn:data</code> function to a sequence is referred to
            as <code>atomization</code>. In many cases an explicit call on <code>fn:data</code> is
            not required, because atomization is invoked implicitly when a node or sequence of nodes
            is supplied in a context where an atomic value or sequence of atomic values is
            required.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>data(123)</fos:expression>
               <fos:result>123</fos:result>
            </fos:test>
         </fos:example>
             
            <fos:variable name="para"><![CDATA[
<para>In a hole in the ground there lived a <term author="Tolkein">hobbit</term>.</para>]]>
            </fos:variable>
            <fos:example>     
               <fos:test>
                  <fos:expression>data($para)</fos:expression>
                  <fos:result>xs:untypedAtomic("In a hole in the ground there lived a hobbit.")</fos:result>
               </fos:test>
               <fos:test>
                  <fos:expression>data($para/term/@author)</fos:expression>
                  <fos:result>xs:untypedAtomic("Tolkein")</fos:result>
               </fos:test>
            <fos:test>
               <fos:expression>data(abs#1)</fos:expression>
               <fos:error-result error-code="FOTY0013"/>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="base-uri" prefix="fn">
      <fos:signatures>
         <fos:proto name="base-uri" return-type="xs:anyURI?"/>
         <fos:proto name="base-uri" return-type="xs:anyURI?">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the base URI of a node.</p>
      </fos:summary>
      <fos:rules>
         <!-- see bug 6340 -->
         <p diff="add" at="B">The zero-argument version of the function returns the base URI of the
            context node: it is equivalent to calling <code>fn:base-uri(.)</code>. This may result
            in an error being raised: if the context item is <xtermref ref="dt-absent" spec="DM30"
               >absent</xtermref>
            <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a
            node <xerrorref spec="XP" class="TY" code="0004" type="type"/>. </p>
         <p diff="add" at="B">The single-argument version of the function behaves as follows:</p>
         <olist>
            <item>If <code>$arg</code> is the empty sequence, the function returns the empty
               sequence.</item>

            <item>Otherwise, the function returns the value of the <code>dm:base-uri</code> accessor
               applied to the node <code>$arg</code>. This accessor is defined, for each kind of
               node, in the XDM specification (See <xspecref spec="DM30" ref="dm-base-uri"
               />).</item>
         </olist>
         <note>As explained in XDM, document, element and processing-instruction nodes have a
            base-uri property which may be empty. The base-uri property for all other node kinds is
            the empty sequence. The dm:base-uri accessor returns the base-uri property of a node if
            it exists and is non-empty; otherwise it returns the result of applying the dm:base-uri
            accessor to its parent, recursively. If the node does not have a parent, or if the
            recursive ascent up the ancestor chain encounters a parentless node whose base-uri
            property is empty, the empty sequence is returned. In the case of namespace nodes,
            however, the result is always an empty sequence -- it does not depend on the base URI of
            the parent element.</note>


         <p>See also <code>fn:static-base-uri</code>.</p>
      </fos:rules>
      <fos:errors>
         <p>If <code>$arg</code> is not specified, the following errors may be raised: if the
            context item is <xtermref ref="dt-absent" spec="DM30">absent</xtermref>
            <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a
            node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
      </fos:errors>
   </fos:function>
   <fos:function name="document-uri" prefix="fn">
      <fos:signatures>
         <fos:proto diff="add" at="F" name="document-uri" return-type="xs:anyURI?"/>
         <fos:proto name="document-uri" return-type="xs:anyURI?">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the URI of a resource where a document can be found, if available.</p>
      </fos:summary>
      <fos:rules>
         <p diff="add" at="F">If the argument is omitted, it defaults to the context item
               (<code>.</code>). The behavior of the function if the argument is omitted is exactly
            the same as if the context item had been passed as the argument.</p>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>If <code>$arg</code> is not a document node, the function returns the empty
            sequence.</p>
         <p>Otherwise, the function returns the value of the <code>document-uri</code> accessor
            applied to <code>$arg</code>, as defined in <bibref ref="xpath-datamodel-30"/> (See
               <xspecref spec="DM30" ref="DocumentNodeAccessors"/>).</p>
      </fos:rules>
      <fos:errors>
         <p diff="add" at="I">The following errors may be raised when <code>$arg</code> is omitted: if the context
            item is <xtermref ref="dt-absent" spec="DM30">absent</xtermref>
            <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a
            node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
         
      </fos:errors>
      <fos:notes>
         <p>In the case of a document node <code>$D</code> returned by the <code>fn:doc</code>
            function, or a document node at the root of a tree containing a node returned by the
               <code>fn:collection</code> function, it will always be true that either
               <code>fn:document-uri($D)</code> returns the empty sequence, or that the following
            expression is true: <code>fn:doc(fn:document-uri($D))</code> is <code>$D</code>. It is
            <termref def="implementation-defined"/> whether this guarantee also holds for document nodes obtained by
            other means, for example a document node passed as the initial context node of a query
            or transformation.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="error" prefix="fn">
      <fos:signatures>
         <fos:proto name="error" return-type="none"/>
         <fos:proto name="error" return-type="none">
            <fos:arg name="code" type="xs:QName"/>
         </fos:proto>
         <fos:proto name="error" return-type="none">
            <fos:arg name="code" type="xs:QName?"/>
            <fos:arg name="description" type="xs:string"/>
         </fos:proto>
         <fos:proto name="error" return-type="none">
            <fos:arg name="code" type="xs:QName?"/>
            <fos:arg name="description" type="xs:string"/>
            <fos:arg name="error-object" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>nondeterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Calling the <code>fn:error</code> function raises an application-defined
            error.</p>
      </fos:summary>
      <fos:rules>
         <p>This function never returns a value. Instead it always raises an error. The effect of
            the error is identical to the effect of dynamic errors raised implicitly, for example
            when an incorrect argument is supplied to a function.</p>
         <p>The parameters to the <code>fn:error</code> function supply information that is
            associated with the error condition and that is made available to a caller that asks for
            information about the error. The error may be caught either by the host language (using
            a try/catch construct in XSLT or XQuery, for example), or by the calling application or
            external processing environment. The way in which error information is returned to the
            external processing environment is <termref def="implementation-dependent"/></p>
         <p>If <code>fn:error</code> is called with no arguments, then its behavior is the same as
            the function call: </p>
         <eg xml:space="preserve"> fn:error(fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')) </eg>
         <p>If <code>$code</code> is the empty sequence then the effective value is the
               <code>xs:QName</code> constructed by:</p>
         <eg xml:space="preserve"> fn:QName('http://www.w3.org/2005/xqt-errors', 'err:FOER0000')</eg>
         <p>There are three pieces of information that may be associated with an error:</p>
         <ulist>
            <item>
               <p>The <code>$code</code> is an error code that distinguishes this error from others.
                  It is an <code>xs:QName</code>; the namespace URI conventionally identifies the
                  component, subsystem, or authority responsible for defining the meaning of the
                  error code, while the local part identifies the specific error condition. The
                  namespace URI <code>http://www.w3.org/2005/xqt-errors</code> is used for errors
                  defined in this specification; other namespace URIs may be used for errors defined
                  by the application.</p>
               <p>If the external processing environment expects the error code to be returned as a
                  URI or a string rather than as an <code>xs:QName</code>, then an error code with
                  namespace URI <code>NS</code> and local part <code>LP</code> will be returned in
                  the form <code>NS#LP</code>. The namespace URI part of the error code should
                  therefore not include a fragment identifier.</p>
            </item>
            <item>
               <p>The <code>$description</code> is a natural-language description of the error
                  condition.</p>
            </item>
            <item>
               <p>The <code>$error-object</code> is an arbitrary value used to convey additional
                  information about the error, and may be used in any way the application
                  chooses.</p>
            </item>
         </ulist>
      </fos:rules>
      <fos:errors>
         <p>This function always raises a <phrase diff="add" at="L">dynamic</phrase> error. By default, it raises <errorref class="ER" code="0000"/></p>
      </fos:errors>
      <fos:notes>
         <p>The value of the <code>$description</code> parameter may need to be localized.</p>
         <p>The type <quote>none</quote> is a special type defined in <bibref ref="xquery-semantics"
            /> and is not available to the user. It indicates that the function never returns and
            ensures that it has the correct static type.</p>
         <p diff="add" at="L">Any QName may be used as an error code; there are no reserved names or
         namespaces. The error is always classified as a dynamic error, even if the error code used is
         one that is normally used for static errors or type errors.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:error()</fos:expression>
               <fos:error-result error-code="FOER0000"/>
               <fos:postamble>This returns the URI <code>http://www.w3.org/2005/xqt-errors#FOER0000</code> (or the corresponding
                  <code>xs:QName</code>) to the external processing environment, unless the error is
                  caught using a try/catch construct in the host language.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test><fos:expression>fn:error(fn:QName('http://www.example.com/HR', 'myerr:toohighsal'), 'Does not
               apply because salary is too high')</fos:expression>
            <fos:error-result error-code="myerr:toohighsal"/>
            <fos:postamble>This  returns
               <code>http://www.example.com/HR#toohighsal</code> and the <code>xs:string</code>
               <code>"Does not apply because salary is too high"</code> (or the corresponding
               <code>xs:QName</code>) to the external processing environment, unless the error is
               caught using a try/catch construct in the host language.</fos:postamble></fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="trace" prefix="fn">
      <fos:signatures>
         <fos:proto name="trace" return-type="item()*">
            <fos:arg name="value" type="item()*"/>
            <fos:arg name="label" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Provides an execution trace intended to be used in debugging queries.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the value of <code>$value</code>, unchanged.</p>
         <p>In addition, the values of <code>$value</code>, converted to an <code>xs:string</code>,
            and <code>$label</code>
            <rfc2119>may</rfc2119> be directed to a trace data set. The destination of the trace
            output is <termref def="implementation-defined"/>. The format of the trace output is
               <termref def="implementation-dependent"/>. The ordering of output from calls of the
               <code>fn:trace</code> function is <termref def="implementation-dependent"/>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Consider a situation in which a user wants to investigate the actual value passed to
               a function. Assume that in a particular execution, <code>$v</code> is an
                  <code>xs:decimal</code> with value <code>124.84</code>. Writing <code>fn:trace($v,
                  'the value of $v is:')</code> will put the strings <code>"124.84"</code> and
                  <code>"the value of $v is:"</code> in the trace data set in implementation
               dependent order.</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="numeric-add" prefix="op">
      <fos:signatures>
         <fos:proto name="numeric-add" return-type="numeric">
            <fos:arg name="arg1" type="numeric"/>
            <fos:arg name="arg2" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="+" types="numeric">Defines the semantics of the "+" operator applied to
         numeric values</fos:opermap>
      <fos:summary>
         <p>Returns the arithmetic sum of its operands: (<code>$arg1 + $arg2</code>).</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/>.</p>
      </fos:rules>
      <fos:notes>
         <p> For <code>xs:float</code> or <code>xs:double</code> values, if one of the operands is a
            zero or a finite number and the other is <code>INF</code> or <code>-INF</code>,
               <code>INF</code> or <code>-INF</code> is returned. If both operands are
               <code>INF</code>, <code>INF</code> is returned. If both operands are
               <code>-INF</code>, <code>-INF</code> is returned. If one of the operands is
               <code>INF</code> and the other is <code>-INF</code>, <code>NaN</code> is
            returned.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="numeric-subtract" prefix="op">
      <fos:signatures>
         <fos:proto name="numeric-subtract" return-type="numeric">
            <fos:arg name="arg1" type="numeric"/>
            <fos:arg name="arg2" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="numeric">Defines the semantics of the "-" operator applied to
         numeric values. </fos:opermap>
      <fos:summary>
         <p>Returns the arithmetic difference of its operands: (<code>$arg1 -
            $arg2</code>).</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/>.</p>
      </fos:rules>
      <fos:notes>
         <p> For <code>xs:float</code> or <code>xs:double</code> values, if one of the operands is a
            zero or a finite number and the other is <code>INF</code> or <code>-INF</code>, an
            infinity of the appropriate sign is returned. If both operands are <code>INF</code> or
               <code>-INF</code>, <code>NaN</code> is returned. If one of the operands is
               <code>INF</code> and the other is <code>-INF</code>, an infinity of the appropriate
            sign is returned.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="numeric-multiply" prefix="op">
      <fos:signatures>
         <fos:proto name="numeric-multiply" return-type="numeric">
            <fos:arg name="arg1" type="numeric"/>
            <fos:arg name="arg2" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="*" types="numeric">Defines the semantics of the "*" operator applied to
         numeric values.</fos:opermap>
      <fos:summary>
         <p>Returns the arithmetic product of its operands: (<code>$arg1 *
            $arg2</code>).</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/>.</p>
      </fos:rules>
      <fos:notes>
         <p> For <code>xs:float</code> or <code>xs:double</code> values, if one of the operands is a
            zero and the other is an infinity, <code>NaN</code> is returned. If one of the operands
            is a non-zero number and the other is an infinity, an infinity with the appropriate sign
            is returned.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="numeric-divide" prefix="op">
      <fos:signatures>
         <fos:proto name="numeric-divide" return-type="numeric">
            <fos:arg name="arg1" type="numeric"/>
            <fos:arg name="arg2" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="div" types="numeric">Defines the semantics of the "div" operator
         applied to numeric values.</fos:opermap>
      <fos:summary>
         <p>Returns the arithmetic quotient of its operands: (<code>$arg1 div
            $arg2</code>).</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/>.</p>
         <p>As a special case, if the types of both <code>$arg1</code> and <code>$arg2</code> are
               <code>xs:integer</code>, then the return type is <code>xs:decimal</code>.</p>

      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="AR" code="0001"/> for <code>xs:decimal</code> and
               <code>xs:integer</code> operands, if the divisor is (positive or negative) zero.</p>
      </fos:errors>
      <fos:notes>
         <p>For <code>xs:float</code> and <code>xs:double</code> operands, floating point division
            is performed as specified in <bibref ref="ieee754"/>. A positive number divided by
            positive zero returns <code>INF</code>. A negative number divided by positive zero
            returns <code>-INF</code>. Division by negative zero returns <code>-INF</code> and
               <code>INF</code>, respectively. Positive or negative zero divided by positive or
            negative zero returns <code>NaN</code>. Also, <code>INF</code> or <code>-INF</code>
            divided by <code>INF</code> or <code>-INF</code> returns <code>NaN</code>.</p>
      </fos:notes>

   </fos:function>
   <fos:function name="numeric-integer-divide" prefix="op">
      <fos:signatures>
         <fos:proto name="numeric-integer-divide" return-type="xs:integer">
            <fos:arg name="arg1" type="numeric"/>
            <fos:arg name="arg2" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="idiv" types="numeric">Defines the semantics of the "idiv" operator
         applied to numeric values.</fos:opermap>
      <fos:summary>
         <p diff="chg" at="A-E30">Performs an integer division.</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/>.</p>

         <p>If <code>$arg2</code> is <code>INF</code> or <code>-INF</code>, 
            and <code>$arg1</code> is not <code>INF</code> or <code>-INF</code>, then the result is zero.</p>

         <p diff="chg" at="A-E30">Otherwise, subject to limits of precision and overflow/underflow
            conditions, the result is the largest (furthest from zero) <code>xs:integer</code> value
               <code>$N</code> such that <code>fn:abs($N * $arg2) le fn:abs($arg1) and fn:compare($N
               * $arg2, 0) eq fn:compare($arg1, 0)</code>.</p>
         <note diff="chg" at="A-E30">
            <p>The second term in this condition ensures that the result has the correct sign.</p>
         </note>
         <p diff="chg" at="A-E30">The implementation may adopt a different algorithm provided that
            it is equivalent to this formulation in all cases where <termref
               def="implementation-dependent">implementation-dependent</termref> or <termref
               def="implementation-defined">implementation-defined</termref> behavior does not
            affect the outcome, for example, the implementation-defined precision of the result of
               <code>xs:decimal</code> division.</p>
      </fos:rules>
      <fos:errors>
         <p diff="chg" at="A-E30">A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="AR" code="0001"/> if the
            divisor is (positive or negative) zero.</p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="AR" code="0002"/> if either operand is
               <code>NaN</code> or if <code>$arg1</code> is <code>INF</code> or
            <code>-INF</code>.</p>
      </fos:errors>
      <fos:notes>
         <p>Except in situations involving errors, loss of precision, or overflow/underflow, the
            result of <code>$a idiv $b</code> is the same as <code>($a div $b) cast as
               xs:integer</code>.</p>
         <p>The semantics of this function are different from integer division as defined in
            programming languages such as Java and C++.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-integer-divide(10,3)</fos:expression>
               <fos:result>3</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-integer-divide(3,-2)</fos:expression>
               <fos:result>-1</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-integer-divide(-3,2)</fos:expression>
               <fos:result>-1</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-integer-divide(-3,-2)</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-integer-divide(9.0,3)</fos:expression>
               <fos:result>3</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-integer-divide(-3.5,3)</fos:expression>
               <fos:result>-1</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-integer-divide(3.0,4)</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-integer-divide(3.1E1,6)</fos:expression>
               <fos:result>5</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-integer-divide(3.1E1,7)</fos:expression>
               <fos:result>4</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="numeric-mod" prefix="op">
      <fos:signatures>
         <fos:proto name="numeric-mod" return-type="numeric">
            <fos:arg name="arg1" type="numeric"/>
            <fos:arg name="arg2" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="mod" types="numeric">Defines the semantics of the "mod" operator
         applied to numeric values.</fos:opermap>
      <fos:summary>
         <p>Returns the remainder resulting from dividing <code>$arg1</code>, the dividend,
            by <code>$arg2</code>, the divisor. </p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/>.</p>
         <p>The operation <code>a mod b</code> for operands that are <code>xs:integer</code> or
               <code>xs:decimal</code>, or types derived from them, produces a result such that
               <code>(a idiv b)*b+(a mod b)</code> is equal to <code>a</code> and the magnitude of
            the result is always less than the magnitude of <code>b</code>. This identity holds even
            in the special case that the dividend is the negative integer of largest possible
            magnitude for its type and the divisor is -1 (the remainder is 0). It follows from this
            rule that the sign of the result is the sign of the dividend.</p>

         <p> For <code>xs:float</code> and <code>xs:double</code> operands the following rules
            apply:</p>
         <ulist>
            <item>
               <p>If either operand is <code>NaN</code>, the result is <code>NaN</code>.</p>
            </item>
            <item>
               <p>If the dividend is positive or negative infinity, or the divisor is positive or
                  negative zero (0), or both, the result is <code>NaN</code>.</p>
            </item>
            <item>
               <p>If the dividend is finite and the divisor is an infinity, the result equals the
                  dividend.</p>
            </item>
            <item>
               <p>If the dividend is positive or negative zero and the divisor is finite, the result
                  is the same as the dividend.</p>
            </item>
            <item>
               <p>In the remaining cases, where neither positive or negative infinity, nor positive
                  or negative zero, nor <code>NaN</code> is involved, the result obeys <code>(a idiv
                     b)*b+(a mod b)</code> = <code>a</code>.
                  <!--float or double remainder r from a dividend n and a divisor d is defined by the mathematical relation r = n-(d * q) where q is an integer that is negative only if n/d is negative and positive only if n/d is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of n and d.  -->
                  Division is truncating division, analogous to integer division, not <bibref
                     ref="ieee754"/> rounding division i.e. additional digits are truncated, not
                  rounded to the required precision.</p>
            </item>
         </ulist>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="AR" code="0001"/> for <code>xs:integer</code> and
               <code>xs:decimal</code> operands, if <code>$arg2</code> is zero.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-mod(10,3)</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-mod(6,-2)</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-mod(4.5,1.2)</fos:expression>
               <fos:result>0.9</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:numeric-mod(1.23E2, 0.6E1)</fos:expression>
               <fos:result>3.0E0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="numeric-unary-plus" prefix="op">
      <fos:signatures>
         <fos:proto name="numeric-unary-plus" return-type="numeric">
            <fos:arg name="arg" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="+" types="numeric">Defines the semantics of the unary "+" operator
         applied to numeric values.</fos:opermap>
      <fos:summary>
         <p diff="chg" at="A-E23">Returns its operand with the sign unchanged: (<code>+
               $arg</code>).</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/>.</p>
         <p diff="chg" at="A-E23">The returned value is equal to <code>$arg</code>, and is an
            instance of <code>xs:integer</code>, <code>xs:decimal</code>, <code>xs:double</code>, or
               <code>xs:float</code> depending on the type of <code>$arg</code>.</p>
      </fos:rules>
      <fos:notes>
         <p>Because function conversion rules are applied in the normal way, the unary <code>+</code>
         can be used to force conversion of an untyped node to a number: the result of <code>+@price</code>
         is the same as <code>xs:double(@price)</code> if the type of <code>@price</code> is
         <code>xs:untypedAtomic</code>.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="numeric-unary-minus" prefix="op">
      <fos:signatures>
         <fos:proto name="numeric-unary-minus" return-type="numeric">
            <fos:arg name="arg" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="numeric">Defines the semantics of the unary "-" operator
         applied to numeric values.</fos:opermap>
      <fos:summary>
         <p diff="chg" at="A-E23">Returns its operand with the sign reversed: (<code>-
               $arg</code>).</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/>.</p>
         <p diff="chg" at="A-E23">The returned value is an instance of <code>xs:integer</code>,
               <code>xs:decimal</code>, <code>xs:double</code>, or <code>xs:float</code> depending
            on the type of <code>$arg</code>.</p>
         <p>For <code>xs:integer</code> and <code>xs:decimal</code> arguments, <code>0</code> and
               <code>0.0</code> return <code>0</code> and <code>0.0</code>, respectively. For
               <code>xs:float</code> and <code>xs:double</code> arguments, <code>NaN</code> returns
               <code>NaN</code>, <code>0.0E0</code> returns <code>-0.0E0</code> and vice versa.
               <code>INF</code> returns <code>-INF</code>. <code>-INF</code> returns
               <code>INF</code>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="numeric-equal" prefix="op">
      <fos:signatures>
         <fos:proto name="numeric-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="numeric"/>
            <fos:arg name="arg2" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="numeric" other-operators="ne le ge">Defines the semantics of
         the "eq" operator on numeric values, and is also used in defining the semantics of "ne",
         "le" and "ge".</fos:opermap>
      <fos:summary>
         <p>Returns true if and only if the value of <code>$arg1</code> is equal to the
            value of <code>$arg2</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/> and <specref ref="comp.numeric"/>.</p>
         <p> For <code>xs:float</code> and <code>xs:double</code> values, positive zero and negative
            zero compare equal. <code>INF</code> equals <code>INF</code>, and <code>-INF</code>
            equals <code>-INF</code>. <code>NaN</code> does not equal itself.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="numeric-less-than" prefix="op">
      <fos:signatures>
         <fos:proto name="numeric-less-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="numeric"/>
            <fos:arg name="arg2" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="lt" types="numeric" other-operators="le">Defines the semantics of the
         "lt" operator on numeric values, and is also used in defining the semantics of
         "le".</fos:opermap>
      <fos:summary>
         <p>Returns <code>true</code> if and only if <code>$arg1</code> is numerically less
            than <code>$arg2</code>. </p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="op.numeric"/> and <specref ref="comp.numeric"/>.</p>
         <p>For <code>xs:float</code> and <code>xs:double</code> values, positive infinity is
            greater than all other non-<code>NaN</code> values; negative infinity is less than all
            other non-<code>NaN</code> values. If <code>$arg1</code> or <code>$arg2</code> is
               <code>NaN</code>, the function returns <code>false</code>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="numeric-greater-than" prefix="op">
      <fos:signatures>
         <fos:proto name="numeric-greater-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="numeric"/>
            <fos:arg name="arg2" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="gt" types="numeric" other-operators="ge">Defines the semantics of the
         "gt" operator on numeric values, and is also used in defining the semantics of
         "ge".</fos:opermap>
      <fos:summary>
         <p>Returns <code>true</code> if and only if <code>$arg1</code> is numerically
            greater than <code>$arg2</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The function call <code>op:numeric-greater-than($A, $B)</code> is defined to return the
            same result as <code>op:numeric-less-than($B, $A)</code></p>
      </fos:rules>
   </fos:function>
   <fos:function name="abs" prefix="fn">
      <fos:signatures>
         <fos:proto name="abs" return-type="numeric?">
            <fos:arg name="arg" type="numeric?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the absolute value of <code>$arg</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="numeric-value-functions"/>.</p>
         <p>If <code>$arg</code> is negative the function returns <code>-$arg</code>, otherwise it
            returns <code>$arg</code>.</p>
         <p>If the type of <code>$arg</code> is one of the four numeric types <code>xs:float</code>,
               <code>xs:double</code>, <code>xs:decimal</code> or <code>xs:integer</code> the type
            of the result is the same as the type of <code>$arg</code>. If the type of
               <code>$arg</code> is a type derived from one of the numeric types, the result is an
            instance of the base numeric type.</p>
         <p>For <code>xs:float</code> and <code>xs:double</code> arguments, if the argument is
            positive zero or negative zero, then positive zero is returned. If the argument is
            positive or negative infinity, positive infinity is returned.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:abs(10.5)</fos:expression>
               <fos:result>10.5</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:abs(-10.5)</fos:expression>
               <fos:result>10.5</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="ceiling" prefix="fn">
      <fos:signatures>
         <fos:proto name="ceiling" return-type="numeric?">
            <fos:arg name="arg" type="numeric?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Rounds <code>$arg</code> upwards to a whole number.</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="numeric-value-functions"/>.</p>
         <p>The function returns the smallest (closest to negative infinity) number with no
            fractional part that is not less than the value of <code>$arg</code>.</p>
         <p>If the type of <code>$arg</code> is one of the four numeric types <code>xs:float</code>,
               <code>xs:double</code>, <code>xs:decimal</code> or <code>xs:integer</code> the type
            of the result is the same as the type of <code>$arg</code>. If the type of
               <code>$arg</code> is a type derived from one of the numeric types, the result is an
            instance of the base numeric type.</p>
         <p>For <code>xs:float</code> and <code>xs:double</code> arguments, if the argument is
            positive zero, then positive zero is returned. If the argument is negative zero, then
            negative zero is returned. If the argument is less than zero and greater than -1,
            negative zero is returned.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ceiling(10.5)</fos:expression>
               <fos:result>11</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ceiling(-10.5)</fos:expression>
               <fos:result>-10</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="floor" prefix="fn">
      <fos:signatures>
         <fos:proto name="floor" return-type="numeric?">
            <fos:arg name="arg" type="numeric?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Rounds <code>$arg</code> downwards to a whole number.</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="numeric-value-functions"/>.</p>
         <p>The function returns the largest (closest to positive infinity) number with no
            fractional part that is not greater than the value of <code>$arg</code>.</p>
         <p>If the type of <code>$arg</code> is one of the four numeric types <code>xs:float</code>,
               <code>xs:double</code>, <code>xs:decimal</code> or <code>xs:integer</code> the type
            of the result is the same as the type of <code>$arg</code>. If the type of
               <code>$arg</code> is a type derived from one of the numeric types, the result is an
            instance of the base numeric type.</p>
         <p>For <code>xs:float</code> and <code>xs:double</code> arguments, if the argument is
            positive zero, then positive zero is returned. If the argument is negative zero, then
            negative zero is returned.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:floor(10.5)</fos:expression>
               <fos:result>10</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:floor(-10.5)</fos:expression>
               <fos:result>-11</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="round" prefix="fn">
      <fos:signatures>
         <fos:proto name="round" return-type="numeric?">
            <fos:arg name="arg" type="numeric?"/>
         </fos:proto>
         <fos:proto name="round" return-type="numeric?">
            <fos:arg name="arg" type="numeric?"/>
            <fos:arg name="precision" type="xs:integer"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Rounds a value to a specified number of decimal places, rounding upwards if two
            such values are equally near.</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="numeric-value-functions"/>.</p>
         <p>The function returns the nearest (that is, numerically closest) value to
               <code>$arg</code> that is a multiple of ten to the power of minus
               <code>$precision</code>. If two such values are equally near (for example, if the
            fractional part in <code>$arg</code> is exactly .5), the function returns the one that
            is closest to positive infinity.</p>
         <p>If the type of <code>$arg</code> is one of the four numeric types <code>xs:float</code>,
               <code>xs:double</code>, <code>xs:decimal</code> or <code>xs:integer</code> the type
            of the result is the same as the type of <code>$arg</code>. If the type of
               <code>$arg</code> is a type derived from one of the numeric types, the result is an
            instance of the base numeric type.</p>
         <p>The single-argument version of this function produces the same result as the
            two-argument version with <code>$precision=0</code> (that is, it rounds to a whole
            number).</p>
         <p>When <code>$arg</code> is of type <code>xs:float</code> and <code>xs:double</code>:</p>
         <olist>
            <item>
               <p>If <code>$arg</code> is NaN, positive or negative zero, or positive or negative
                  infinity, then the result is the same as the argument.</p>
            </item>
            <item>
               <p>For other values, the argument is cast to <code>xs:decimal</code> using an
                  implementation of <code>xs:decimal</code> that imposes no limits on the number of
                  digits that can be represented. The function is applied to this
                     <code>xs:decimal</code> value, and the resulting <code>xs:decimal</code> is
                  cast back to <code>xs:float</code> or <code>xs:double</code> as appropriate to
                  form the function result. If the resulting <code>xs:decimal</code> value is zero,
                  then positive or negative zero is returned according to the sign of
                     <code>$arg</code>.</p>
            </item>
         </olist>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>This function is typically used with a non-zero <code>$precision</code> in financial
            applications where the argument is of type <code>xs:decimal</code>. For arguments of
            type <code>xs:float</code> and <code>xs:double</code> the results may be
            counter-intuitive. For example, consider <code>round(35.425e0, 2)</code>. The result is
            not 35.43, as might be expected, but 35.42. This is because the <code>xs:double</code> written as 35.425e0
            has an exact value equal to 35.42499999999..., which is closer
            to 35.42 than to 35.43.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round(2.5)</fos:expression>
               <fos:result>3.0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round(2.4999)</fos:expression>
               <fos:result>2.0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round(-2.5)</fos:expression>
               <fos:result>-2.0</fos:result>
               <fos:postamble>Not the possible alternative, <code>-3</code></fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test xslt-version="3.0">
               <fos:expression>fn:round(1.125, 2)</fos:expression>
               <fos:result>1.13</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test xslt-version="3.0">
               <fos:expression>fn:round(8452, -2)</fos:expression>
               <fos:result>8500</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test xslt-version="3.0">
               <fos:expression>fn:round(3.1415e0, 2)</fos:expression>
               <fos:result>3.14e0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="round-half-to-even" prefix="fn">
      <fos:signatures>
         <fos:proto name="round-half-to-even" return-type="numeric?">
            <fos:arg name="arg" type="numeric?"/>
         </fos:proto>
         <fos:proto name="round-half-to-even" return-type="numeric?">
            <fos:arg name="arg" type="numeric?"/>
            <fos:arg name="precision" type="xs:integer"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Rounds a value to a specified number of decimal places, rounding to make the
            last digit even if two such values are equally near.</p>
      </fos:summary>
      <fos:rules>
         <p>General rules: see <specref ref="numeric-value-functions"/>.</p>
         <p>The function returns the nearest (that is, numerically closest) value to
               <code>$arg</code> that is a multiple of ten to the power of minus
               <code>$precision</code>. If two such values are equally near (e.g. if the fractional
            part in <code>$arg</code> is exactly .500...), the function returns the one whose least
            significant digit is even.</p>
         <p>If the type of <code>$arg</code> is one of the four numeric types <code>xs:float</code>,
               <code>xs:double</code>, <code>xs:decimal</code> or <code>xs:integer</code> the type
            of the result is the same as the type of <code>$arg</code>. If the type of
               <code>$arg</code> is a type derived from one of the numeric types, the result is an
            instance of the base numeric type.</p>
         <p> The first signature of this function produces the same result as the second signature
            with <code>$precision=0</code>.</p>
         <p>For arguments of type <code>xs:float</code> and <code>xs:double</code>:</p>
         <olist>
            <item>
               <p>If the argument is <code>NaN</code>, positive or negative zero, or positive or
                  negative infinity, then the result is the same as the argument.</p>
            </item>
            <item>
               <p>In all other cases, the argument is cast to <code>xs:decimal</code>
                  <phrase diff="add" at="A">using an implementation of xs:decimal that imposes no
                     limits on the number of digits that can be represented.</phrase> The function
                  is applied to this <code>xs:decimal</code> value, and the resulting
                     <code>xs:decimal</code> is cast back to <code>xs:float</code> or
                     <code>xs:double</code> as appropriate to form the function result. If the
                  resulting <code>xs:decimal</code> value is zero, then positive or negative zero is
                  returned according to the sign of the original argument.</p>
            </item>
         </olist>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p diff="chg" at="A">This function is typically used in financial applications where the
            argument is of type <code>xs:decimal</code>. For arguments of type <code>xs:float</code>
            and <code>xs:double</code> the results may be counter-intuitive. For example, consider
               <code>round-half-to-even(xs:float(150.015), 2)</code>. The result is not 150.02 as
            might be expected, but 150.01. This is because the conversion of the
               <code>xs:float</code> value represented by the literal 150.015 to an
               <code>xs:decimal</code> produces the <code>xs:decimal</code> value 150.014999389...,
            which is closer to 150.01 than to 150.02.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round-half-to-even(0.5)</fos:expression>
               <fos:result>0.0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round-half-to-even(1.5)</fos:expression>
               <fos:result>2.0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round-half-to-even(2.5)</fos:expression>
               <fos:result>2.0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round-half-to-even(3.567812e+3, 2)</fos:expression>
               <fos:result>3567.81e0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round-half-to-even(4.7564e-3, 2)</fos:expression>
               <fos:result>0.0e0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round-half-to-even(35612.25, -2)</fos:expression>
               <fos:result>35600</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="format-integer" prefix="fn">
      <fos:signatures>
         <fos:proto name="format-integer" return-type="xs:string">
            <fos:arg name="value" type="xs:integer?"/>
            <fos:arg name="picture" type="xs:string"/>
         </fos:proto>
         <fos:proto name="format-integer" return-type="xs:string" diff="chg" at="J">
            <fos:arg name="value" type="xs:integer?"/>
            <fos:arg name="picture" type="xs:string"/>
            <fos:arg name="lang" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="default-language">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="3">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Formats an integer according to a given picture string, using the conventions
            of a given natural language if specified.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$value</code> is an empty sequence, the function returns a zero-length
            string.</p>
         <p>In all other cases, the <code>$picture</code> argument describes the format in which
               <code>$value</code> is output.</p>
         <p>The rules that follow describe how non-negative numbers are output. If the value of
               <code>$value</code> is negative, the rules below are applied to the absolute value of
               <code>$value</code>, and a minus sign is prepended to the result.</p>
         
         <p diff="chg" at="L">The value of <code>$picture</code> consists of a primary format token, 
            optionally followed
            by a format modifier. The primary format token is always present and <rfc2119>must not</rfc2119>
            be zero-length. If the string contains one or more semicolons then everything that
            precedes the last semicolon is taken as the primary format token and everything
            that follows is taken as the format modifier; if the string contains no
            semicolon then the entire picture is taken as the primary format token, and the
            format modifier is taken to be absent (which is equivalent to supplying a
            zero-length string).</p>
         
  
         
         <p>The primary format token is classified as one of the following:</p>
         <ulist>
            <item>
               <p>A <var>decimal-digit-pattern</var> made up of <var>optional-digit-signs</var>,
                     <var>mandatory-digit-signs</var>, and <var>grouping-separator-signs</var>.</p>

               <ulist>
                  <item>
                     <p>The <var>optional-digit-sign</var> is the character "#".</p>
                  </item>
                  <item>
                     <p>A <var>mandatory-digit-sign</var> is a <termref def="character"
                           >character</termref> in Unicode category Nd. All
                           <var>mandatory-digit-signs</var> within the format token <rfc2119>must</rfc2119> be from the
                        same digit family, where a digit family is a sequence of ten consecutive
                        characters in Unicode category Nd, having digit values 0 through 9. Within
                        the format token, these digits are interchangeable: a three-digit number may
                        thus be indicated equivalently by <code>000</code>, <code>001</code>, or
                           <code>999</code>.</p>
                  </item>
                  <item>
                     <p>a <var>grouping-separator-sign</var> is a non-alphanumeric character, that
                        is a <termref def="character">character</termref> whose Unicode category is
                        other than Nd, Nl, No, Lu, Ll, Lt, Lm or Lo.</p>
                  </item>
               </ulist>
               
               <p diff="chg" at="L">If the primary format token contains at least one Unicode digit 
                  then it is taken as a decimal digit pattern, and in this case it <rfc2119>must</rfc2119>
                  match the regular expression <code>^((\p{Nd}|#|[^\p{N}\p{L}])+?)$</code>. If it contains
                  a digit but does not match this pattern, a <phrase diff="add" at="L">dynamic</phrase> error 
                  is raised <errorref class="DF" code="1310"/>.</p>
               
               <note><p diff="add" at="L">If a semicolon is to be used as a grouping separator, then the primary
               format token as a whole must be followed by another semicolon, to ensure that
               the grouping separator is not mistaken as a separator between the primary format
               token and the format modifier.</p></note>


               <p>There <rfc2119>must</rfc2119> be at least one <var>mandatory-digit-sign</var>. There may be zero or
                  more <var>optional-digit-signs</var>, and (if present) these <rfc2119>must</rfc2119> precede all
                     <var>mandatory-digit-signs</var>. There may be zero or more
                     <var>grouping-separator-signs</var>. A <var>grouping-separator-sign</var> <rfc2119>must
                  not</rfc2119> appear at the start or end of the <var>decimal-digit-pattern</var>, nor
                  adjacent to another <var>grouping-separator-sign</var>.</p>

               <p>The corresponding output format is a decimal number, using this digit family, with
                  at least as many digits as there are <var>mandatory-digit-signs</var> in the
                  format token. Thus, a format token <code>1</code> generates the sequence <code>0 1
                     2 ... 10 11 12 ...</code>, and a format token <code>01</code> (or equivalently,
                     <code>00</code> or <code>99</code>) generates the sequence <code>00 01 02 ...
                     09 10 11 12 ... 99 100 101</code>. A format token of <code>&amp;#x661;</code>
                  (Arabic-Indic digit one) generates the sequence <code>١</code> then <code>٢</code>
                  then <code>٣</code> ...</p>

               <p>The <var>grouping-separator-signs</var> are handled as follows. The position of
                  grouping separators within the format token, counting backwards from the last
                  digit, indicates the position of grouping separators to appear within the
                  formatted number, and the character used as the <var>grouping-separator-sign</var>
                  within the format token indicates the character to be used as the corresponding
                  grouping separator in the formatted number. If <var>grouping-separator-signs</var>
                  appear at regular intervals within the format token, that is if the same grouping
                  separator appears at positions forming a sequence <var>N</var>, 2<var>N</var>,
                     3<var>N</var>, ... for some integer value <var>N</var> (including the case
                  where there is only one number in the list), then the sequence is extrapolated to
                  the left, so grouping separators will be used in the formatted number at every
                  multiple of <var>N</var>. For example, if the format token is <code>0'000</code>
                  then the number one million will be formatted as <code>1'000'000</code>, while the
                  number fifteen will be formatted as <code>0'015</code>.</p>

               <p>The only purpose of <var>optional-digit-signs</var> is to mark the position of
                     <var>grouping-separator-signs</var>. For example, if the format token is
                     <code>#'##0</code> then the number one million will be formatted as
                     <code>1'000'000</code>, while the number fifteen will be formatted as
                     <code>15</code>. A grouping separator is included in the formatted number only
                  if there is a digit to its left, which will only be the case if either (a) the
                  number is large enough to require that digit, or (b) the number of
                     <var>mandatory-digit-signs</var> in the format token requires insignificant
                  leading zeros to be present.</p>

               <note>
                  <p>Numbers will never be truncated. Given the <var>decimal-digit-pattern</var>
                     <code>01</code>, the number three hundred will be output as <code>300</code>,
                     despite the absence of any <var>optional-digit-sign</var>.</p>
               </note>
            </item>




            <item>
               <p>The format token <code>A</code>, which generates the sequence <code>A B C ... Z AA AB
                     AC...</code>.</p>
            </item>
            <item>
               <p>The format token <code>a</code>, which generates the sequence <code>a b c ... z aa ab
                     ac...</code>.</p>
            </item>
            <item>
               <p>The format token <code>i</code>, which generates the sequence <code>i ii iii iv v vi vii
                     viii ix x ...</code>.</p>
            </item>
            <item>
               <p>The format token <code>I</code>, which generates the sequence <code>I II III IV V VI VII
                     VIII IX X ...</code>.</p>
            </item>
            <item>
               <p>The format token <code>w</code>, which generates numbers written as lower-case words, for
                  example in English, <code>one two three four ...</code>
               </p>
            </item>
            <item>
               <p>The format token <code>W</code>, which generates numbers written as upper-case words, for
                  example in English, <code>ONE TWO THREE FOUR ...</code>
               </p>
            </item>
            <item>
               <p>The format token <code>Ww</code>, which generates numbers written as title-case words, for
                  example in English, <code>One Two Three Four ...</code>
               </p>
            </item>
            <item>
               <p>Any other format token, which indicates a numbering sequence in which that token
                  represents the number 1 (one) (but see the note below).
                  <!-- Where possible (given the constraint that format tokens
						must be alphanumeric, and that they must be distinct) the format token
						used to represent a numbering sequence should be the same as the representation
						of the number 1 (one) in that sequence.-->
                  It is <termref def="implementation-defined">implementation-defined</termref> which
                  numbering sequences, additional to those listed above, are supported. If an
                  implementation does not support a numbering sequence represented by the given
                  token, it <rfc2119>must</rfc2119> use a format token of <code>1</code>.</p>
               <note>
                  <p>In some traditional numbering sequences additional signs are added to denote
                     that the letters should be interpreted as numbers; these are not included in
                     the format token. An example (see also the example below) is classical Greek
                     where a <emph>dexia keraia</emph> (x0374, &#x0374;) and sometimes an <emph>aristeri keraia</emph>
                     (x0375, &#x0375;) is added.</p>
               </note>
            </item>
         </ulist>
         <p>For all format tokens other than the first kind above (one that consists of decimal
            digits), there <rfc2119>may</rfc2119> be <termref def="implementation-defined"
               >implementation-defined</termref> lower and upper bounds on the range of numbers that
            can be formatted using this format token; indeed, for some numbering sequences there may
            be intrinsic limits. For example, the format token <code>&amp;#x2460;</code> (circled
            digit one, ①) has a range of 1 to 20 imposed by the Unicode character repertoire. For
            the numbering sequences described above any upper bound imposed by the implementation
               <rfc2119>must not</rfc2119> be less than 1000 (one thousand) and any lower bound must
            not be greater than 1. Numbers that fall outside this range <rfc2119>must</rfc2119> be
            formatted using the format token <code>1</code>.</p>
         <p>The above expansions of numbering sequences for format tokens such as <code>a</code> and
               <code>i</code> are indicative but not prescriptive. There are various conventions in
            use for how alphabetic sequences continue when the alphabet is exhausted, and differing
            conventions for how roman numerals are written (for example, <code>IV</code> versus
               <code>IIII</code> as the representation of the number 4). Sometimes alphabetic
            sequences are used that omit letters such as <code>i</code> and <code>o</code>. This
            specification does not prescribe the detail of any sequence other than those sequences
            consisting entirely of decimal digits.</p>
         <p>Many numbering sequences are language-sensitive. This applies especially to the sequence
            selected by the tokens <code>w</code>, <code>W</code> and <code>Ww</code>. It also
            applies to other sequences, for example different languages using the Cyrillic alphabet
            use different sequences of characters, each starting with the letter #x410 (Cyrillic
            capital letter A). In such cases, the <code>$lang</code> argument specifies which
            language's conventions are to be used. <phrase diff="chg" at="L">If the argument
            is specified, the value <rfc2119>should</rfc2119> be either an empty sequence
            or a value that would be valid for the <code>xml:lang</code> attribute (see <bibref ref="XML"/>).
            Note that this permits the identification of sublanguages based on country codes (from ISO 3166-1)
            as well as identification of dialects and regions within a country.</phrase>.</p> 
         <p>The set of languages
            for which numbering is supported is <termref def="implementation-defined"/>.
            If the <code>$lang</code> argument is absent, 
            or is set to an empty sequence, or is invalid, or is not a language supported by the
            implementation, then the number is formatted using <phrase diff="chg" at="K">the
            default language from the dynamic context</phrase>. 
            </p>
         <p>The format modifier <phrase diff="chg" at="L"><rfc2119>must</rfc2119>
            be a string that matches the regular expression <code diff="chg" at="M">^([co](\(.+\))?)?[at]?$</code>. </phrase>
            That is, if it is present it must consist of one <phrase diff="add" at="G">or more</phrase> of
            the following, in <phrase diff="del" at="K">any</phrase> order:</p>
         <ulist>
            <item>
               <p diff="chg" at="G">either <code>c</code> or <code>o</code>, optionally followed by
                  a sequence of characters enclosed between parentheses, to indicate cardinal or
                  ordinal numbering respectively, the default being cardinal numbering</p>
            </item>
            <item>
               <p diff="chg" at="G">either <code>a</code> or <code>t</code>, to indicate alphabetic
                  or traditional numbering respectively, the default being <termref
                     def="implementation-defined">implementation-defined</termref>.</p>
            </item>
         </ulist>
         <p>If the <code>o</code> modifier is present, this indicates a request to output ordinal
            numbers rather than cardinal numbers. For example, in English, when used with the format
            token <code>1</code>, this outputs the sequence <code>1st 2nd 3rd 4th ...</code>, and
            when used with the format token <code>w</code> outputs the sequence <code>first second
            third fourth ...</code>.</p>
         <p diff="add" at="L">The string of characters between the parentheses, if present, is used to
         select between other possible variations of cardinal or ordinal numbering sequences.
         The interpretation of this string is <termref def="implemementation-defined">implementation-defined</termref>. No error occurs
         if the implementation does not define any interpretation for the defined string.</p>
         <p>For example, in some languages, ordinal numbers vary depending on the grammatical context:
            they may have different genders and may decline with the noun that they qualify.
            In such cases the string appearing in parentheses after the letter <code>o</code> may be
            used to indicate the variation of the ordinal number required. The way in which the
            variation is indicated will depend on the conventions of the language. For inflected
            languages that vary the ending of the word, the <rfc2119>recommended</rfc2119> approach is to indicate the
            required ending, preceded by a hyphen: for example in German, appropriate values are
               <code>o(-e)</code>, <code>o(-er)</code>, <code>o(-es)</code>, <code>o(-en)</code>. </p>
         <p>It is <termref def="implementation-defined">implementation-defined</termref> what
            combinations of values of the format token, the language, and the cardinal/ordinal
            modifier are supported. If ordinal numbering is not supported for the combination of the
            format token, the language, and the string appearing in parentheses, the request is
            ignored and cardinal numbers are generated instead.</p>
         <example>
            <head>Ordinal Numbering in Italian</head>
            <p>The specification <code>"1o(-º)"</code> with <code>$lang</code> equal to
                  <code>it</code>, if supported, should produce the sequence:</p>
            <eg xml:space="preserve">1º 2º 3º 4º ...</eg>
            <p>The specification <code>"Wwo"</code> with <code>$lang</code> equal to
                  <code>it</code>, if supported, should produce the sequence:</p>
            <eg xml:space="preserve">Primo Secondo Terzo Quarto Quinto ...</eg>
         </example>
         <p>The <phrase diff="chg" at="G">use of the <code>a</code> or <code>t</code>
               modifier</phrase> disambiguates between numbering sequences that use letters. In many
            languages there are two commonly used numbering sequences that use letters. One
            numbering sequence assigns numeric values to letters in alphabetic sequence, and the
            other assigns numeric values to each letter in some other manner traditional in that
            language. In English, these would correspond to the numbering sequences specified by the
            format tokens <code>a</code> and <code>i</code>. In some languages, the first member of
            each sequence is the same, and so the format token alone would be ambiguous. <phrase
               diff="chg" at="G">In the absence of the <code>a</code> or <code>t</code> modifier,
               the default is <termref def="implementation-defined"
               >implementation-defined</termref></phrase>.</p>
      </fos:rules>
      <fos:errors>
         <p diff="add" at="L">A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DF" code="1310"/> if the format token is invalid,
            that is, if it violates any mandatory rules (indicated by an emphasized <rfc2119>must</rfc2119>
            or <rfc2119>required</rfc2119> keyword in the above rules). For example, the error is raised if
            the primary format token contains a digit but does not match the required regular expression.</p>
      </fos:errors>
      <fos:notes>
         <p diff="add" at="L">Note the careful distinction between conditions that are errors and conditions
         where fallback occurs. The principle is that an error in the syntax of the format picture will be reported by
         all processors, while a construct that is recognized by some implementations but not others will never result
         in an error, but will instead cause a fallback representation of the integer to be used.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test xslt-version="3.0">
               <fos:expression>format-integer(123, '0000')</fos:expression>
               <fos:result>"0123"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p><code>format-integer(123, 'w')</code> might return <code>"one hundred and
                  twenty-three"</code></p>
         </fos:example>
         <fos:example>
            <fos:test xslt-version="3.0">
               <fos:expression>format-integer(21, '1;o', 'en')</fos:expression>
               <fos:result>"21st"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p><code>format-integer(14, 'Ww;o(-e)', 'de')</code> might return
                  <code>"Vierzehnte"</code></p>
         </fos:example>
         <fos:example>
            <fos:test xslt-version="3.0">
               <fos:expression>format-integer(7, 'a')</fos:expression>
               <fos:result>"g"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test xslt-version="3.0">
               <fos:expression>format-integer(57, 'I')</fos:expression>
               <fos:result>"LVII"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test xslt-version="3.0">
               <fos:expression>format-integer(1234, '#;##0;')</fos:expression>
               <fos:result>"1;234"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="format-number" prefix="fn">
      <fos:signatures>
         <fos:proto name="format-number" return-type="xs:string">
            <fos:arg name="value" type="numeric?"/>
            <fos:arg name="picture" type="xs:string"/>
         </fos:proto>
         <fos:proto name="format-number" return-type="xs:string">
            <fos:arg name="value" type="numeric?"/>
            <fos:arg name="picture" type="xs:string"/>
            <fos:arg name="decimal-format-name" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="3">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="decimal-formats namespaces">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a string containing a number formatted according to a given picture
            string, taking account of decimal formats specified in the static context.</p>
      </fos:summary>
      <fos:rules>
         <p diff="add" at="K">The effect of the two-argument form of the function is equivalent to calling
         the three-argument form with an empty sequence as the value of the third argument.</p>
         <p>The function formats <code>$value</code> as a string using the <termref
               def="dt-picture-string">picture string</termref> specified by the
               <code>$picture</code> argument and the decimal-format named by the
               <code>$decimal-format-name</code> argument, or the default decimal-format, if there
            is no <code>$decimal-format-name</code> argument. The syntax of the picture string is
            described in <specref ref="syntax-of-picture-string"/>.</p>
         <p>The <code>$value</code> argument may be of any numeric data type
            (<code>xs:double</code>, <code>xs:float</code>, <code>xs:decimal</code>, or their
            subtypes including <code>xs:integer</code>). Note that if an <code>xs:decimal</code> is
            supplied, it is not automatically promoted to an <code>xs:double</code>, as such
            promotion can involve a loss of precision.</p>
         <p>If the supplied value of the <code>$value</code> argument is an empty sequence, the
            function behaves as if the supplied value were the <code>xs:double</code> value
               <code>NaN</code>.</p>
         <p>The value of <code>$decimal-format-name</code>, 
            <phrase diff="add" at="K">if present and non-empty, </phrase>
            <rfc2119>must</rfc2119> <phrase diff="chg" at="L">be a string which after removal of leading and trailing whitespace is in the form of an
            an <code>EQName</code> as defined in the XPath 3.0 grammar, that is one of the following</phrase>:</p>
         
         <ulist>
            <item><p>A lexical QName, which is expanded using the 
               <phrase diff="chg" at="J">statically known namespaces</phrase>. 
               The default namespace is not used (no prefix means no namespace).</p></item>
            <item><p diff="add" at="L">A <code>URIQualifiedName</code> using the syntax <code>Q{uri}local</code>,
            where the URI can be zero-length to indicate a name in no namespace.</p></item>
         </ulist>
         
         
         <p diff="add" at="K">The decimal format that is used is the decimal format
         in the static context whose name matches <code>$decimal-format-name</code> if supplied,
         or the default decimal format in the static context otherwise.</p>
         
         <p>The evaluation of the <function>format-number</function> function takes place in two
            phases, an analysis phase described in <specref ref="analysing-picture-string"/> and a
            formatting phase described in <specref ref="formatting-the-number"/>.</p>

         <p>The analysis phase takes as its inputs the <termref def="dt-picture-string">picture
               string</termref> and the variables derived from the relevant decimal format in the
            static context, and produces as its output a number of variables with defined values.
            The formatting phase takes as its inputs the number to be formatted and the variables
            produced by the analysis phase, and produces as its output a string containing a
            formatted representation of the number.</p>

         <p>The result of the function is the formatted string representation of the supplied
            number.</p>

      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DF" code="1280"/> if the name specified as the
               <code>$decimal-format-name</code> argument is 
            <phrase diff="chg" at="L">neither a valid lexical QName nor a valid <code>URIQualifiedName</code></phrase>, or if it
            uses a prefix <phrase diff="add" at="J">that is not found in the statically known namespaces</phrase>, or if the static
            context does not contain a declaration of a decimal-format with a matching expanded
            QName. If the processor is able to detect the error statically (for example, when the
            argument is supplied as a string literal), then the processor <rfc2119>may</rfc2119>
            optionally signal this as a static error.</p>
      </fos:errors>
      <fos:notes>
         <p>Numbers will always be formatted with the most significant digit on the left.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p>The following examples assume a default decimal format in which the
            chosen digits are the ASCII digits 0-9, the
            decimal separator is ".", the grouping separator is ",", the minus-sign is
            "-", and the percent-sign is "%".</p>
            <fos:test>
               <fos:expression>format-number(12345.6, '#,###.00')</fos:expression>
               <fos:result>"12,345.00"</fos:result>
            </fos:test> 
            <fos:test>
               <fos:expression>format-number(12345678.9, '9,999.99')</fos:expression>
               <fos:result>"12,345,678.90"</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>format-number(123.9, '9999')</fos:expression>
               <fos:result>"0124"</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>format-number(0.14, '01%')</fos:expression>
               <fos:result>"14%"</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>format-number(-6, '000')</fos:expression>
               <fos:result>"-006"</fos:result>
            </fos:test>
            <p>The following example assumes the existence of a decimal format named 'ch' in which the grouping
            separator is <code>&#x2b9;</code> and the decimal separator is <code>&#xb7;</code>:</p>
            <fos:test>
               <fos:expression>format-number(1234.5678, '#&#x2b9;##0&#xb7;00', 'ch')</fos:expression>
               <fos:result>"1&#x2b9;234&#xb7;57"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="pi" prefix="math" diff="add" at="C">
      <fos:signatures>
         <fos:proto name="pi" return-type="xs:double"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns an approximation to the mathematical constant <var>π</var>.</p>
      </fos:summary>
      <fos:rules>
         <p>This function returns the <code>xs:double</code> value whose lexical representation is
            3.141592653589793e0</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test xslt-version="3.0">
               <fos:expression>2*math:pi()</fos:expression>
               <fos:result>6.283185307179586e0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p>The expression <code>60 * (math:pi() div 180)</code> converts an angle of 60 degrees
               to radians. </p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="exp" prefix="math" diff="add" at="G">
      <fos:signatures>
         <fos:proto name="exp" return-type="xs:double?">
            <fos:arg name="arg" type="xs:double?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the value of <var>e</var><sup><var>x</var></sup>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p diff="chg" at="G">Otherwise the result is the mathematical constant <var>e</var>
            raised to the power of <code>$arg</code>, as defined in the <bibref ref="ieee754-2008"/>
            specification of the <code>exp</code> function applied to 64-bit binary floating point
            values.</p>
      </fos:rules>
      <fos:notes>
         <p>The treatment of overflow and underflow is defined in <specref ref="op.numeric"/>.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>math:exp(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:exp(0)</fos:expression>
               <fos:result>1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:exp(1)</fos:expression>
               <fos:result>2.7182818284590455e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:exp(2)</fos:expression>
               <fos:result>7.38905609893065e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:exp(-1)</fos:expression>
               <fos:result>0.36787944117144233e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:exp(math:pi())</fos:expression>
               <fos:result>23.140692632779267e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:exp(xs:double('NaN'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:exp(xs:double('INF'))</fos:expression>
               <fos:result>xs:double('INF')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:exp(xs:double('-INF'))</fos:expression>
               <fos:result>0.0e0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="exp10" prefix="math" diff="add" at="G">
      <fos:signatures>
         <fos:proto name="exp10" return-type="xs:double?">
            <fos:arg name="arg" type="xs:double?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the value of <code>10</code><sup><var>x</var></sup>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p diff="chg" at="G">Otherwise the result is ten raised to the power of <code>$arg</code>,
            as defined in the <bibref ref="ieee754-2008"/> specification of the <code>exp10</code>
            function applied to 64-bit binary floating point values.</p>
      </fos:rules>
      <fos:notes>
         <p>The treatment of overflow and underflow is defined in <specref ref="op.numeric"/>.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>math:exp10(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:exp10(0)</fos:expression>
               <fos:result>1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:exp10(1)</fos:expression>
               <fos:result>1.0e1</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:exp10(0.5)</fos:expression>
               <fos:result>3.1622776601683795e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:exp10(-1)</fos:expression>
               <fos:result>1.0e-1</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:exp10(xs:double('NaN'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:exp10(xs:double('INF'))</fos:expression>
               <fos:result>xs:double('INF')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:exp10(xs:double('-INF'))</fos:expression>
               <fos:result>0.0e0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="log" prefix="math" diff="add" at="G">
      <fos:signatures>
         <fos:proto name="log" return-type="xs:double?">
            <fos:arg name="arg" type="xs:double?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the natural logarithm of the argument.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p diff="chg" at="G">Otherwise the result is the natural logarithm of <code>$arg</code>, as
            defined in the <bibref ref="ieee754-2008"/> specification of the <code>log</code>
            function applied to 64-bit binary floating point values.</p>
      </fos:rules>
      <fos:notes>
         <p>The treatment of <code>divideByZero</code> and <code>invalidOperation</code> exceptions
            is defined in <specref ref="op.numeric"/>. The effect is that if the argument is less
            than or equal to zero, the result is <code>NaN</code>.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>math:log(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:log(0)</fos:expression>
               <fos:result>xs:double('-INF')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:log(math:exp(1))</fos:expression>
               <fos:result>1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:log(1.0e-3)</fos:expression>
               <fos:result>-6.907755278982137e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:log(2)</fos:expression>
               <fos:result>0.6931471805599453e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:log(-1)</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:log(xs:double('NaN'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:log(xs:double('INF'))</fos:expression>
               <fos:result>xs:double('INF')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:log(xs:double('-INF'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="log10" prefix="math" diff="add" at="G">
      <fos:signatures>
         <fos:proto name="log10" return-type="xs:double?">
            <fos:arg name="arg" type="xs:double?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the base-ten logarithm of the argument.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p diff="chg" at="G">Otherwise the result is the base-10 logarithm of <code>$arg</code>, as
            defined in the <bibref ref="ieee754-2008"/> specification of the <code>log10</code>
            function applied to 64-bit binary floating point values.</p>
      </fos:rules>
      <fos:notes>
         <p>The treatment of <code>divideByZero</code> and <code>invalidOperation</code> exceptions
            is defined in <specref ref="op.numeric"/>. The effect is that if the argument is less
            than or equal to zero, the result is <code>NaN</code>.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>math:log10(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:log10(0)</fos:expression>
               <fos:result>xs:double('-INF')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:log10(1.0e3)</fos:expression>
               <fos:result>3.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:log10(1.0e-3)</fos:expression>
               <fos:result>-3.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:log10(2)</fos:expression>
               <fos:result>0.3010299956639812e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:log10(-1)</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:log10(xs:double('NaN'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:log10(xs:double('INF'))</fos:expression>
               <fos:result>xs:double('INF')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:log10(xs:double('-INF'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="sqrt" prefix="math" diff="add" at="C">
      <fos:signatures>
         <fos:proto name="sqrt" return-type="xs:double?">
            <fos:arg name="arg" type="xs:double?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the non-negative square root of the argument.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p diff="chg" at="G">Otherwise the result is the mathematical non-negative square root of
               <code>$arg</code> as defined in the <bibref ref="ieee754-2008"/> specification of the
               <code>squareRoot</code> function applied to 64-bit binary floating point values.</p>
      </fos:rules>
      <fos:notes>

         <p>The treatment of the <code>invalidOperation</code> exception is defined in <specref
               ref="op.numeric"/>. The effect is that if the argument is less than zero, the result
            is <code>NaN</code>.</p>

         <p>If <code>$arg</code> is positive or negative zero, positive infinity, or
               <code>NaN</code>, then the result is <code>$arg</code>. (Negative zero is the only
            case where the result can have negative sign)</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>math:sqrt(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:sqrt(0.0e0)</fos:expression>
               <fos:result>0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:sqrt(-0.0e0)</fos:expression>
               <fos:result>-0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:sqrt(1.0e6)</fos:expression>
               <fos:result>1.0e3</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:sqrt(2.0e0)</fos:expression>
               <fos:result>1.4142135623730951e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:sqrt(-2.0e0)</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:sqrt(xs:double('NaN'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:sqrt(xs:double('INF'))</fos:expression>
               <fos:result>xs:double('INF')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:sqrt(xs:double('-INF'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="pow" prefix="math" diff="add" at="G">
      <fos:signatures>
         <fos:proto name="pow" return-type="xs:double?">
            <fos:arg name="x" type="xs:double?"/>
            <fos:arg name="y" type="numeric"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the result of raising the first argument to the power of the
            second.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$x</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>If <code>$y</code> is an instance of <code>xs:integer</code>, the result is
               <code>$x</code> raised to the power of <code>$y</code> as defined in the <bibref
               ref="ieee754-2008"/> specification of the <code>pown</code> function applied to a
            64-bit binary floating point value and an integer.</p>
         <p>Otherwise <code>$y</code> is converted to an <code>xs:double</code> by numeric
            promotion, and the result is the value of <code>$x</code> raised to the power of
               <code>$y</code> as defined in the <bibref ref="ieee754-2008"/> specification of the
               <code>pow</code> function applied to two 64-bit binary floating point values.</p>
      </fos:rules>
      <fos:notes>

         <p>The treatment of the <code>divideByZero</code> and <code>invalidOperation</code>
            exceptions is defined in <specref ref="op.numeric"/>. Some of the consequences are
            illustrated in the examples below.</p>

      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>math:pow((), 93.7)</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(2, 3)</fos:expression>
               <fos:result>8.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(-2, 3)</fos:expression>
               <fos:result>-8.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(2, -3)</fos:expression>
               <fos:result>0.125e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(-2, -3)</fos:expression>
               <fos:result>-0.125e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(2, 0)</fos:expression>
               <fos:result>1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(0, 0)</fos:expression>
               <fos:result>1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(xs:double('INF'), 0)</fos:expression>
               <fos:result>1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(xs:double('NaN'), 0)</fos:expression>
               <fos:result>1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(-math:pi(), 0)</fos:expression>
               <fos:result>1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(0e0, 3)</fos:expression>
               <fos:result>0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(0e0, 4)</fos:expression>
               <fos:result>0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(-0e0, 3)</fos:expression>
               <fos:result>-0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(0, 4)</fos:expression>
               <fos:result>0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(0e0, -3)</fos:expression>
               <fos:result>xs:double('INF')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(0e0, -4)</fos:expression>
               <fos:result>xs:double('INF')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(-0e0, -3)</fos:expression>
               <fos:result>xs:double('-INF')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(0, -4)</fos:expression>
               <fos:result>xs:double('INF')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(16, 0.5e0)</fos:expression>
               <fos:result>4.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(16, 0.25e0)</fos:expression>
               <fos:result>2.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(0e0, -3.0e0)</fos:expression>
               <fos:result>xs:double('INF')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(-0e0, -3.0e0)</fos:expression>
               <fos:result>xs:double('-INF')</fos:result>
               <fos:postamble>Odd-valued whole numbers are treated specially</fos:postamble>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(0e0, -3.1e0)</fos:expression>
               <fos:result>xs:double('INF')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(-0e0, -3.1e0)</fos:expression>
               <fos:result>xs:double('INF')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(0e0, 3.0e0)</fos:expression>
               <fos:result>0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(-0e0, 3.0e0)</fos:expression>
               <fos:result>-0.0e0</fos:result>
               <fos:postamble>Odd-valued whole numbers are treated specially</fos:postamble>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(0e0, 3.1e0)</fos:expression>
               <fos:result>0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(-0e0, 3.1e0)</fos:expression>
               <fos:result>0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(-1, xs:double('INF'))</fos:expression>
               <fos:result>1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(-1, xs:double('-INF'))</fos:expression>
               <fos:result>1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(1, xs:double('INF'))</fos:expression>
               <fos:result>1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(1, xs:double('-INF'))</fos:expression>
               <fos:result>1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(1, xs:double('NaN'))</fos:expression>
               <fos:result>1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(-2.5e0, 2.0e0)</fos:expression>
               <fos:result>6.25e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:pow(-2.5e0, 2.00000001e0)</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="sin" prefix="math" diff="add" at="C">
      <fos:signatures>
         <fos:proto name="sin" return-type="xs:double?">
            <fos:arg name="θ" type="xs:double?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the sine of the argument, expressed in radians.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$</code><var>θ</var> is the empty sequence, the function returns the empty
            sequence.</p>

         <p diff="chg" at="G">Otherwise the result is the sine of <code>$</code><var>θ</var>,
            treated as an angle in radians, as defined in the <bibref ref="ieee754-2008"/>
            specification of the <code>sin</code> function applied to 64-bit binary floating point
            values.</p>

      </fos:rules>
      <fos:notes>
         <p>The treatment of the <code>invalidOperation</code> and <code>underflow</code> exceptions
            is defined in <specref ref="op.numeric"/>. </p>
         <p>If <code>$</code><var>θ</var> is positive or negative zero, the result is
               <code>$</code><var>θ</var>.</p>
         <p>If <code>$</code><var>θ</var> is positive or negative infinity, or <code>NaN</code>,
            then the result is <code>NaN</code>.</p>
         <p>Otherwise the result is always in the range -1.0e0 to +1.0e0</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>math:sin(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:sin(0)</fos:expression>
               <fos:result>0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:sin(-0.0e0)</fos:expression>
               <fos:result>-0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:sin(math:pi() div 2)</fos:expression>
               <fos:result>1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:sin(-math:pi() div 2)</fos:expression>
               <fos:result>-1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:sin(math:pi())</fos:expression>
               <fos:result approx="true">0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:sin(xs:double('NaN'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:sin(xs:double('INF'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:sin(xs:double('-INF'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="cos" prefix="math" diff="add" at="C">
      <fos:signatures>
         <fos:proto name="cos" return-type="xs:double?">
            <fos:arg name="θ" type="xs:double?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the cosine of the argument, expressed in radians.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$</code><var>θ</var> is the empty sequence, the function returns the empty
            sequence.</p>
         <p>If <code>$</code><var>θ</var> is positive or negative infinity, or <code>NaN</code>,
            then the result is <code>NaN</code>.</p>
         <p diff="chg" at="G">Otherwise the result is the cosine of <code>$</code><var>θ</var>,
            treated as an angle in radians, as defined in the <bibref ref="ieee754-2008"/>
            specification of the <code>cos</code> function applied to 64-bit binary floating point
            values.</p>
      </fos:rules>
      <fos:notes>
         <p>The treatment of the <code>invalidOperation</code> exception is defined in <specref
               ref="op.numeric"/>. </p>
         <p>If <code>$</code><var>θ</var> is positive or negative zero, the result is
               <code>$</code><var>θ</var>.</p>
         <p>If <code>$</code><var>θ</var> is positive or negative infinity, or <code>NaN</code>,
            then the result is <code>NaN</code>.</p>
         <p>Otherwise the result is always in the range -1.0e0 to +1.0e0</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>math:cos(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:cos(0)</fos:expression>
               <fos:result>1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:cos(-0.0e0)</fos:expression>
               <fos:result>1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:cos(math:pi() div 2)</fos:expression>
               <fos:result approx="true">0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:cos(-math:pi() div 2)</fos:expression>
               <fos:result approx="true">0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:cos(math:pi())</fos:expression>
               <fos:result>-1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:cos(xs:double('NaN'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:cos(xs:double('INF'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:cos(xs:double('-INF'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="tan" prefix="math" diff="add" at="C">
      <fos:signatures>
         <fos:proto name="tan" return-type="xs:double?">
            <fos:arg name="θ" type="xs:double?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the tangent of the argument, expressed in radians.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$</code><var>θ</var> is the empty sequence, the function returns the empty
            sequence.</p>
         <p diff="chg" at="G">Otherwise the result is the tangent of <code>$</code><var>θ</var>,
            treated as an angle in radians, as defined in the <bibref ref="ieee754-2008"/>
            specification of the <code>tan</code> function applied to 64-bit binary floating point
            values.</p>

      </fos:rules>
      <fos:notes>
         <p>The treatment of the <code>invalidOperation</code> and <code>underflow</code> exceptions
            is defined in <specref ref="op.numeric"/>. </p>
         <p>If <code>$</code><var>θ</var> is positive or negative infinity, or <code>NaN</code>,
            then the result is <code>NaN</code>.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>math:tan(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:tan(0)</fos:expression>
               <fos:result>0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:tan(-0.0e0)</fos:expression>
               <fos:result>-0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:tan(math:pi() div 4)</fos:expression>
               <fos:result approx="true">1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:tan(-math:pi() div 4)</fos:expression>
               <fos:result approx="true">-1.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:tan(math:pi() div 2)</fos:expression>
               <fos:result approx="true">1.633123935319537E16</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:tan(-math:pi() div 2)</fos:expression>
               <fos:result approx="true">-1.633123935319537E16</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:tan(math:pi())</fos:expression>
               <fos:result approx="true">0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:tan(xs:double('NaN'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:tan(xs:double('INF'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:tan(xs:double('-INF'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="asin" prefix="math" diff="add" at="C">
      <fos:signatures>
         <fos:proto name="asin" return-type="xs:double?">
            <fos:arg name="arg" type="xs:double?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the arc sine of the argument, the result being in the range
               -<var>π</var>/2 to +<var>π</var>/2 radians.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p diff="chg" at="G">Otherwise the result is the arc sine of <code>$</code><var>θ</var>,
            treated as an angle in radians, as defined in the <bibref ref="ieee754-2008"/>
            specification of the <code>asin</code> function applied to 64-bit binary floating point
            values.</p>
      </fos:rules>
      <fos:notes>
         <p>The treatment of the <code>invalidOperation</code> and <code>underflow</code> exceptions
            is defined in <specref ref="op.numeric"/>. </p>
         <p>If <code>$arg</code> is positive or negative zero, the result is <code>$arg</code>.</p>
         <p>If <code>$arg</code> is <code>NaN</code>, or if its absolute value is greater than one,
            then the result is <code>NaN</code>.</p>
         <p>In other cases the result is an <code>xs:double</code> value representing an angle
               <var>θ</var> in radians in the range -<var>π</var><code>/2 &lt;=
               $</code><var>θ</var><code> &lt;= +</code><var>π</var><code>/2</code>. </p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>math:asin(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:asin(0)</fos:expression>
               <fos:result>0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:asin(-0.0e0)</fos:expression>
               <fos:result>-0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:asin(1.0e0)</fos:expression>
               <fos:result approx="true">1.5707963267948966e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:asin(-1.0e0)</fos:expression>
               <fos:result approx="true">-1.5707963267948966e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:asin(2.0e0)</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:asin(xs:double('NaN'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:asin(xs:double('INF'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:asin(xs:double('-INF'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="acos" prefix="math" diff="add" at="C">
      <fos:signatures>
         <fos:proto name="acos" return-type="xs:double?">
            <fos:arg name="arg" type="xs:double?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the arc cosine of the argument, the result being in the range zero to
               +<var>π</var> radians.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p diff="chg" at="G">Otherwise the result is the arc cosine of <code>$</code><var>θ</var>,
            treated as an angle in radians, as defined in the <bibref ref="ieee754-2008"/>
            specification of the <code>acos</code> function applied to 64-bit binary floating point
            values.</p>
      </fos:rules>
      <fos:notes>
         <p>The treatment of the <code>invalidOperation</code> exception is defined in <specref
               ref="op.numeric"/>. </p>
         <p>If <code>$arg</code> is <code>NaN</code>, or if its absolute value is greater than one,
            then the result is <code>NaN</code>.</p>
         <p>In other cases the result is an <code>xs:double</code> value representing an angle
               <var>θ</var> in radians in the range <code>0 &lt;= $</code><var>θ</var><code> &lt;=
               +</code><var>π</var>. </p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>math:acos(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:acos(0)</fos:expression>
               <fos:result approx="true">1.5707963267948966e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:acos(-0.0e0)</fos:expression>
               <fos:result approx="true">1.5707963267948966e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:acos(1.0e0)</fos:expression>
               <fos:result>0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:acos(-1.0e0)</fos:expression>
               <fos:result approx="true">3.141592653589793e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:acos(2.0e0)</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:acos(xs:double('NaN'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:acos(xs:double('INF'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:acos(xs:double('-INF'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="atan" prefix="math" diff="add" at="C">
      <fos:signatures>
         <fos:proto name="atan" return-type="xs:double?">
            <fos:arg name="arg" type="xs:double?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the arc tangent of the argument, the result being in the range
               -<var>π</var>/2 to +<var>π</var>/2 radians.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p diff="chg" at="G">Otherwise the result is the arc tangent of <code>$</code><var>θ</var>,
            treated as an angle in radians, as defined in the <bibref ref="ieee754-2008"/>
            specification of the <code>atan</code> function applied to 64-bit binary floating point
            values.</p>
      </fos:rules>
      <fos:notes>
         <p>The treatment of the <code>underflow</code> exception is defined in <specref
               ref="op.numeric"/>. </p>
         <p>If <code>$arg</code> is positive or negative zero, the result is <code>$arg</code>.</p>
         <p>If <code>$arg</code> is <code>NaN</code> then the result is <code>NaN</code>.</p>
         <p>In other cases the result is an <code>xs:double</code> value representing an angle
               <var>θ</var> in radians in the range -<var>π</var><code>/2 &lt;=
               $</code><var>θ</var><code> &lt;= +</code><var>π</var><code>/2</code>. </p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>math:atan(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:atan(0)</fos:expression>
               <fos:result>0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:atan(-0.0e0)</fos:expression>
               <fos:result>-0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:atan(1.0e0)</fos:expression>
               <fos:result approx="true">0.7853981633974483e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:atan(-1.0e0)</fos:expression>
               <fos:result approx="true">-0.7853981633974483e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:atan(xs:double('NaN'))</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:atan(xs:double('INF'))</fos:expression>
               <fos:result approx="true">1.5707963267948966e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:atan(xs:double('-INF'))</fos:expression>
               <fos:result approx="true">-1.5707963267948966e0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="atan2" prefix="math" diff="add" at="G">
      <fos:signatures>
         <fos:proto name="atan2" return-type="xs:double">
            <fos:arg name="y" type="xs:double"/>
            <fos:arg name="x" type="xs:double"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the angle in radians subtended at the origin by the point on a plane
            with coordinates (x, y) and the positive x-axis, the result being in the range
               -<var>π</var> to +<var>π</var>.</p>
      </fos:summary>
      <fos:rules>
         <p diff="chg" at="G">The result is the value of <code>atan2(y, x)</code> as defined in the
               <bibref ref="ieee754-2008"/> specification of the <code>atan2</code> function applied
            to 64-bit binary floating point values.</p>
      </fos:rules>
      <fos:notes>
         <p>The treatment of the <code>underflow</code> exception is defined in <specref
               ref="op.numeric"/>. </p>
         <p>If <phrase diff="chg" at="L">either argument</phrase> is <code>NaN</code> 
            then the result is <code>NaN</code>.</p>
         <p>If <code>$y</code> is positive and <code>$x</code> is positive and finite, then 
            (subject to rules for overflow, underflow and approximation) 
         the value of <code>atan2($y, $x)</code> is <code>atan($y div $x)</code>.</p>
         <p>If <code>$y</code> is positive and <code>$x</code> is negative and finite, then 
            (subject to the same caveats) 
            the value of <code>atan2($y, $x)</code> is <var>π</var> <code>- atan($y div $x)</code>.</p>
         <p>Some results for special values of the arguments are shown in the examples below.</p>
          
      </fos:notes>
      <fos:examples>


         <fos:example>
            <fos:test>
               <fos:expression>math:atan2(+0.0e0, 0.0e0)</fos:expression>
               <fos:result>0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:atan2(-0.0e0, 0.0e0)</fos:expression>
               <fos:result>-0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:atan2(+0.0e0, -0.0e0)</fos:expression>
               <fos:result>math:pi()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:atan2(-0.0e0, -0.0e0)</fos:expression>
               <fos:result>-math:pi()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:atan2(-1, 0.0e0)</fos:expression>
               <fos:result>-math:pi() div 2</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:atan2(+1, 0.0e0)</fos:expression>
               <fos:result>+math:pi() div 2</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:atan2(-0.0e0, -1)</fos:expression>
               <fos:result>-math:pi()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:atan2(+0.0e0, -1)</fos:expression>
               <fos:result>+math:pi()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:atan2(-0.0e0, +1)</fos:expression>
               <fos:result>-0.0e0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>math:atan2(+0.0e0, +1)</fos:expression>
               <fos:result>+0.0e0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="codepoints-to-string" prefix="fn">
      <fos:signatures>
         <fos:proto name="codepoints-to-string" return-type="xs:string">
            <fos:arg name="arg" type="xs:integer*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Creates an <code>xs:string</code> from a sequence of <termref def="codepoint"
               >codepoints</termref>.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the string made up from the <termref def="character"
               >characters</termref> whose Unicode <termref def="codepoint">codepoints</termref> are
            supplied in <code>$arg</code>. This will be the zero-length string if <code>$arg</code>
            is the empty sequence. </p>

      </fos:rules>
      <fos:errors>
         <p>An error is raised <errorref class="CH" code="0001"/> if any of the codepoints in
               <code>$arg</code> is not a permitted XML character.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:codepoints-to-string((66, 65, 67, 72))</fos:expression>
               <fos:result>"BACH"</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:codepoints-to-string((2309, 2358, 2378, 2325))</fos:expression>
               <fos:result>"अशॊक"</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:codepoints-to-string(())</fos:expression>
               <fos:result>""</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:codepoints-to-string(0)</fos:expression>
               <fos:error-result error-code="FOCH0001"/>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="string-to-codepoints" prefix="fn">
      <fos:signatures>
         <fos:proto name="string-to-codepoints" return-type="xs:integer*">
            <fos:arg name="arg" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the sequence of <termref def="codepoint">codepoints</termref> that
            constitute an <code>xs:string</code> value. </p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence of integers, each integer being the Unicode <termref
               def="codepoint">codepoints</termref> of the corresponding <termref def="character"
               >character</termref> in <code>$arg</code>.</p>
         <p>If <code>$arg</code> is a zero-length string or the empty sequence, the function returns
            the empty sequence.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:string-to-codepoints("Thérèse")</fos:expression>
               <fos:result>(84, 104, 233, 114, 232, 115, 101)</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="compare" prefix="fn">
      <fos:signatures>
         <fos:proto name="compare" return-type="xs:integer?">
            <fos:arg name="comparand1" type="xs:string?"/>
            <fos:arg name="comparand2" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="compare" return-type="xs:integer?">
            <fos:arg name="comparand1" type="xs:string?"/>
            <fos:arg name="comparand2" type="xs:string?"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="3">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations static-base-uri">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns -1, 0, or 1, depending on whether <code>$comparand1</code> collates
            before, equal to, or after <code>$comparand2</code> according to the rules of a selected
            collation.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns -1, 0, or 1, depending on whether the value of the <code>$comparand1</code> is
            respectively less than, equal to, or greater than the value of <code>$comparand2</code>,
            according to the rules of the collation that is used. </p>
         <p>The collation used by this function is determined according to the rules in <specref
               ref="choosing-a-collation"/>. </p>
         <p>If either <code>$comparand1</code> or <code>$comparand2</code> is the empty sequence,
            the function returns the empty sequence.</p>
         <p>This function, called with the first signature, defines the semantics of the "eq", "ne",
            "gt", "lt", "le" and "ge" operators on <code>xs:string</code> values.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:compare('abc', 'abc')</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test default-collation="http://example.com/deutsch">
               <fos:expression>fn:compare('Strasse', 'Straße')</fos:expression>
               <fos:result>0</fos:result>
               <fos:postamble>Assuming the default collation includes provisions that equate
                     <quote>ss</quote> and the (German) character <quote>ß</quote>
                     (<quote>sharp-s</quote>). Otherwise, the returned value depends on the
                  semantics of the default collation.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:compare('Strasse', 'Straße',
                  'http://example.com/deutsch')</fos:expression>
               <fos:result>0</fos:result>
               <fos:postamble>Assuming the collation identified by the URI
                     <code>http://example.com/deutsch</code> includes provisions that equate
                     <quote>ss</quote> and the (German) character <quote>ß</quote>
                     (<quote>sharp-s</quote>). Otherwise, the returned value depends on the
                  semantics of that collation.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test default-collation="http://example.com/deutsch">
               <fos:expression>fn:compare('Strassen', 'Straße')</fos:expression>
               <fos:result>1</fos:result>
               <fos:postamble>Assuming the default collation includes provisions that treat
                  differences between <quote>ss</quote> and the (German) character <quote>ß</quote>
                     (<quote>sharp-s</quote>) with less strength than the differences between the
                  base characters, such as the final <quote>n</quote>. </fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="codepoint-equal" prefix="fn">
      <fos:signatures>
         <fos:proto name="codepoint-equal" return-type="xs:boolean?">
            <fos:arg name="comparand1" type="xs:string?"/>
            <fos:arg name="comparand2" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns true if two strings are equal, considered codepoint-by-codepoint.</p>
      </fos:summary>
      <fos:rules>
         <p>If either argument is the empty sequence, the function returns the empty sequence. </p>
         <p>Otherwise, the function returns <code>true</code> or <code>false</code> depending on
            whether the value of <code>$comparand1</code> is equal to the value of
               <code>$comparand2</code>, according to the Unicode codepoint collation
               (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>).</p>

      </fos:rules>
      <fos:notes>
         <p>This function allows <code>xs:anyURI</code> values to be compared without having to
            specify the Unicode codepoint collation.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:codepoint-equal("abcd", "abcd")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:codepoint-equal("abcd", "abcd ")</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:codepoint-equal("", "")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:codepoint-equal("", ())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:codepoint-equal((), ())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="concat" prefix="fn">
      <fos:signatures>
         <fos:proto name="concat" return-type="xs:string">
            <fos:arg name="arg1" type="xs:anyAtomicType?"/>
            <fos:arg name="arg2" type="xs:anyAtomicType?"/>
            <fos:arg name="..." type="xs:anyAtomicType?"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="||" types="xs:anyAtomicType xs:anyAtomicType">
         The two-argument form of this function defines the semantics of the "||" operator.</fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the concatenation of the string values of the arguments.</p>
      </fos:summary>
      <fos:rules>
         <p>This function accepts two or more <code>xs:anyAtomicType</code> arguments and casts each
            one to <code>xs:string</code>. The function returns the <code>xs:string</code> that is
            the concatenation of the values of its arguments after conversion. If any argument is
            the empty sequence, that argument is treated as the zero-length string.</p>
         <p diff="chg" at="A-E19">The <code>fn:concat</code> function is specified to allow two or
            more arguments, which are concatenated together. This is the only function specified in
            this document that allows a variable number of arguments. This capability is retained
            for compatibility with <bibref ref="xpath"/>. </p>
      </fos:rules>
      <fos:notes>
         <p>As mentioned in <specref ref="string-types"/> Unicode normalization is not automatically
            applied to the result of <code>fn:concat</code>. If a normalized result is required,
               <code>fn:normalize-unicode</code> can be applied to the <code>xs:string</code>
            returned by <code>fn:concat</code>. The following XQuery:</p>
         <eg xml:space="preserve">
let $v1 := "I plan to go to Mu"
let $v2 := "?nchen in September"
return concat($v1, $v2)</eg>
         <p>where the "?" represents either the actual Unicode character COMBINING DIARESIS (Unicode
            codepoint U+0308) or "&amp;#x0308;", will return:</p>
         <p>"I plan to go to Mu?nchen in September"</p>
         <p>where the "?" represents either the actual Unicode character COMBINING DIARESIS (Unicode
            codepoint U+0308) or "&amp;#x0308;". It is worth noting that the returned value is not
            normalized in NFC; however, it is normalized in NFD. .</p>
         <p> However, the following XQuery:</p>
         <eg xml:space="preserve">
let $v1 := "I plan to go to Mu"
let $v2 := "?nchen in September"
return normalize-unicode(concat($v1, $v2))</eg>
         <p>where the "?" represents either the actual Unicode character COMBINING DIARESIS (Unicode
            codepoint U+0308) or "&amp;#x0308;", will return:</p>
         <p> "I plan to go to München in September"</p>
         <p>This returned result is normalized in NFC.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:concat('un', 'grateful')</fos:expression>
               <fos:result>"ungrateful"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:concat('Thy ', (), 'old ', "groans", "", ' ring', ' yet', ' in', '
                  my', ' ancient',' ears.')</fos:expression>
               <fos:result>"Thy old groans ring yet in my ancient ears."</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:concat('Ciao!',())</fos:expression>
               <fos:result>"Ciao!"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:concat('Ingratitude, ', 'thou ', 'marble-hearted', ' fiend!')</fos:expression>
               <fos:result>"Ingratitude, thou marble-hearted fiend!"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:concat(01, 02, 03, 04, true())</fos:expression>
               <fos:result>"1234true"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>10 || '/' || 6</fos:expression>
               <fos:result>"10/6"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="string-join" prefix="fn">
      <fos:signatures>
         <fos:proto name="string-join" return-type="xs:string" diff="add" at="B">
            <fos:arg name="arg1" type="xs:string*"/>
         </fos:proto>
         <fos:proto name="string-join" return-type="xs:string">
            <fos:arg name="arg1" type="xs:string*"/>
            <fos:arg name="arg2" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a string created by concatenating the items in a sequence, with a
            defined separator between adjacent items.</p>
      </fos:summary>
      <fos:rules>
         <p diff="add" at="B">The effect of calling the single-argument version of this function is
            the same as calling the two-argument version with <code>$arg2</code> set to a
            zero-length string.</p>
         <p>The function returns an <code>xs:string</code> created by concatenating the items in the
            sequence <code>$arg1</code>, in order, using the value of <code>$arg2</code> as a
            separator between adjacent items. If the value of <code>$arg2</code> is the zero-length
            string, then the members of <code>$arg1</code> are concatenated without a separator.</p>

      </fos:rules>
      <fos:notes>
         <p>If the value of <code>$arg1</code> is the empty sequence, the function returns the
            zero-length string.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:string-join(('Now', 'is', 'the', 'time', '...'), ' ')</fos:expression>
               <fos:result>"Now is the time ..."</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:string-join(('Blow, ', 'blow, ', 'thou ', 'winter ', 'wind!'), '')</fos:expression>
               <fos:result>"Blow, blow, thou winter wind!"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:string-join((), 'separator')</fos:expression>
               <fos:result>""</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p>Assume a document:</p>
            <eg xml:space="preserve">&lt;doc&gt;
  &lt;chap&gt;
    &lt;section/&gt;
  &lt;/chap&gt;
&lt;/doc&gt;</eg>
            <p>with the <code>&lt;section&gt;</code> element as the context node, the <bibref
                  ref="xpath20"/> expression: </p>
            <p>
               <code>fn:string-join(ancestor-or-self::*/name(), '/')</code>
            </p>
            <p> returns <code>"doc/chap/section"</code></p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="substring" prefix="fn">
      <fos:signatures>
         <fos:proto name="substring" return-type="xs:string">
            <fos:arg name="sourceString" type="xs:string?"/>
            <fos:arg name="start" type="xs:double"/>
         </fos:proto>
         <fos:proto name="substring" return-type="xs:string">
            <fos:arg name="sourceString" type="xs:string?"/>
            <fos:arg name="start" type="xs:double"/>
            <fos:arg name="length" type="xs:double"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the portion of the value of <code>$sourceString</code> beginning at the
            position indicated by the value of <code>$start</code> and continuing for the number of
               <termref def="character">characters</termref> indicated by the value of
               <code>$length</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$sourceString</code> is the empty sequence, the function returns
            the zero-length string. </p>
         <p>Otherwise, the function returns a string comprising those <termref def="character"
               >characters</termref> of <code>$sourceString</code> whose index position (counting
            from one) is greater than or equal to the value of <code>$start</code> (rounded to an
            integer), and (if <code>$length</code> is specified) less than the sum of
               <code>$start</code> and <code>$length</code> (both rounded to integers).</p>
         <p>The characters returned do not extend beyond <code>$sourceString</code>. If
               <code>$start</code> is zero or negative, only those characters in positions greater
            than zero are returned.</p>
         <p>More specifically, the three argument version of the function returns the characters in
               <code>$sourceString</code> whose position <code>$p</code> satisfies:</p>
         <p>
            <code>fn:round($start) &lt;= $p &lt; fn:round($start) + fn:round($length)</code>
         </p>
         <p>The two argument version of the function assumes that <code>$length</code> is infinite
            and thus returns the <termref def="character">characters</termref> in
               <code>$sourceString</code> whose position <code>$p</code> satisfies:</p>
         <p>
            <code>fn:round($start) &lt;= $p</code>
         </p>
         <p>In the above computations, the rules for <code>op:numeric-less-than</code> and
               <code>op:numeric-greater-than</code> apply.</p>
      </fos:rules>
      <fos:notes>
         <p>The first character of a string is located at position 1, not position 0.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("motor car", 6)</fos:expression>
               <fos:result>" car"</fos:result>
               <fos:postamble>Characters starting at position 6 to the end of
                     <code>$sourceString</code> are selected.</fos:postamble>
            </fos:test>
            <p/>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("metadata", 4, 3)</fos:expression>
               <fos:result>"ada"</fos:result>
               <fos:postamble>Characters at positions greater than or equal to 4 and less than 7 are
                  selected.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("12345", 1.5, 2.6)</fos:expression>
               <fos:result>"234"</fos:result>
               <fos:postamble>Characters at positions greater than or equal to 2 and less than 5 are
                  selected.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("12345", 0, 3)</fos:expression>
               <fos:result>"12"</fos:result>
               <fos:postamble>Characters at positions greater than or equal to 0 and less than 3 are
                  selected. Since the first position is 1, these are the characters at positions 1
                  and 2.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("12345", 5, -3)</fos:expression>
               <fos:result>""</fos:result>
               <fos:postamble>Characters at positions greater than or equal to 5 and less than 2 are
                  selected.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("12345", -3, 5)</fos:expression>
               <fos:result>"1"</fos:result>
               <fos:postamble>Characters at positions greater than or equal to -3 and less than 2
                  are selected. Since the first position is 1, this is the character at position
                  1.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("12345", 0 div 0E0, 3)</fos:expression>
               <fos:result>""</fos:result>
               <fos:postamble>Since <code>0 div 0E0</code> returns <code>NaN</code>, and
                     <code>NaN</code> compared to any other number returns <code>false</code>, no
                  characters are selected.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("12345", 1, 0 div 0E0)</fos:expression>
               <fos:result>""</fos:result>
               <fos:postamble>As above.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring((), 1, 3)</fos:expression>
               <fos:result>""</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("12345", -42, 1 div 0E0)</fos:expression>
               <fos:result>"12345"</fos:result>
               <fos:postamble>Characters at positions greater than or equal to -42 and less than <code>INF</code>
                  are selected.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring("12345", -1 div 0E0, 1 div 0E0)</fos:expression>
               <fos:result>""</fos:result>
               <fos:postamble>Since the value of <code>-INF + INF</code> is <code>NaN</code>, no
                  characters are selected.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="string-length" prefix="fn">
      <fos:signatures>
         <fos:proto name="string-length" return-type="xs:integer"/>
         <fos:proto name="string-length" return-type="xs:integer">
            <fos:arg name="arg" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the number of <termref def="character">characters</termref> in a
            string.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns an <code>xs:integer</code> equal to the length in <termref
               def="character">characters</termref> of the value of <code>$arg</code>.</p>
         <p>Calling the zero-argument version of the function is equivalent to calling
               <code>fn:string-length(fn:string(.))</code>.</p>
         <p>If the value of <code>$arg</code> is the empty sequence, the function returns the
               <code>xs:integer</code> value zero (0).</p>
      </fos:rules>
      <fos:errors>
         <p>If <code>$arg</code> is not specified and the context item is <xtermref ref="dt-absent"
               spec="DM30">absent</xtermref>, an error is raised: <xerrorref spec="XP" class="DY"
               code="0002" type="type"/>.</p>
      </fos:errors>
      <fos:notes>
         <p>Unlike some programming languages, a <termref def="codepoint">codepoint</termref>
            greater than 65535 counts as one character, not two.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:string-length("Harp not on that string, madam; that is past.")</fos:expression>
               <fos:result>45</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:string-length(())</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="normalize-space" prefix="fn">
      <fos:signatures>
         <fos:proto name="normalize-space" return-type="xs:string"/>
         <fos:proto name="normalize-space" return-type="xs:string">
            <fos:arg name="arg" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the value of <code>$arg</code> with leading and trailing whitespace
            removed, and sequences of internal whitespace reduced to a single space character.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg</code> is the empty sequence, the function returns the
            zero-length string.</p>
         <p>The function returns a string constructed by stripping leading and trailing whitespace
            from the value of <code>$arg</code>, and replacing sequences of one or more adjacent
            whitespace characters with a single space, <code>#x20</code>.</p>
         <p>The whitespace characters are defined in the metasymbol S (Production 3) of <bibref
               ref="REC-xml"/>.</p>

         <p diff="chg" at="A-E14">If no argument is supplied, then <code>$arg</code> defaults to the
            string value (calculated using <code>fn:string</code>) of the context item
               (<code>.</code>). </p>
      </fos:rules>
      <fos:errors>
         <p>If no argument is supplied and the context item is <xtermref ref="dt-absent" spec="DM30"
               >absent</xtermref> then an error is raised: <xerrorref spec="XP" class="DY"
               code="0002" type="type"/>.</p>
      </fos:errors>
      <fos:notes>
         <p>The definition of whitespace is unchanged in <bibref ref="xml11"/>. </p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression xml:space="preserve">fn:normalize-space(" The    wealthy curled darlings
                                        of    our    nation. ")</fos:expression>
               <fos:result>"The wealthy curled darlings of our nation."</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:normalize-space(())</fos:expression>
               <fos:result>""</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="normalize-unicode" prefix="fn">
      <fos:signatures>
         <fos:proto name="normalize-unicode" return-type="xs:string">
            <fos:arg name="arg" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="normalize-unicode" return-type="xs:string">
            <fos:arg name="arg" type="xs:string?"/>
            <fos:arg name="normalizationForm" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the value of <code>$arg</code> after applying Unicode
            normalization.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg</code> is the empty sequence, the function returns the
            zero-length string.</p>
         <p>If the single-argument version of the function is used, the result is the same as
            calling the two-argument version with <code>$normalizationForm</code> set to the string
            "NFC".</p>
         <p>Otherwise, the function returns the value of <code>$arg</code> normalized according to
            the rules of the normalization form identified by the value of
               <code>$normalizationForm</code>.</p>
         <p>The effective value of <code>$normalizationForm</code> is the value of the expression
               <code>fn:upper-case(fn:normalize-space($normalizationForm))</code>.</p>
         <p diff="del" at="D">See <bibref ref="charmod-normalization"/> for a description of the
            normalization forms.</p>

         <ulist>
            <item>
               <p>If the effective value of <code>$normalizationForm</code> is <quote>NFC</quote>,
                  then the function returns the value of <code>$arg</code> converted to Unicode
                  Normalization Form C (NFC).</p>
            </item>
            <item>
               <p>If the effective value of <code>$normalizationForm</code> is <quote>NFD</quote>,
                  then the function returns the value of <code>$arg</code> converted to Unicode
                  Normalization Form D (NFD).</p>
            </item>
            <item>
               <p>If the effective value of <code>$normalizationForm</code> is <quote>NFKC</quote>,
                  then the function returns the value of <code>$arg</code> in Unicode Normalization
                  Form KC (NFKC).</p>
            </item>
            <item>
               <p>If the effective value of <code>$normalizationForm</code> is <quote>NFKD</quote>,
                  then the function returns the value of <code>$arg</code> converted to Unicode
                  Normalization Form KD (NFKD).</p>
            </item>
            <item>
               <p>If the effective value of <code>$normalizationForm</code> is
                     <quote>FULLY-NORMALIZED</quote>, then the function returns the value of
                     <code>$arg</code> converted to fully normalized form. </p>
            </item>
            <item>
               <p>If the effective value of <code>$normalizationForm</code> is the zero-length
                  string, no normalization is performed and <code>$arg</code> is returned.</p>
            </item>
         </ulist>
         <p diff="add" at="D">Normalization forms NFC, NFD, NFKC, and NFKD, and the algorithms to be
            used for converting a string to each of these forms, are defined in <bibref
               ref="Unicode-Normalization"/>.</p>
         <p diff="add" at="D">The motivation for normalization form FULLY-NORMALIZED is explained in
               <bibref ref="charmod-normalization"/>. However, as that specification did not
            progress beyond working draft status, the normative specification is as follows:</p>
         <ulist diff="add" at="D">
            <item>
               <p>A string is <term>fully-normalized</term> if (a) it is in normalization form NFC
                  as defined in <bibref ref="Unicode-Normalization"/>, and (b) it does not start
                  with a composing character.</p>
            </item>
            <item>
               <p>A composing character is a character that is one or both of the following:</p>
               <ulist>
                  <item>
                     <p>the second character in the canonical decomposition mapping of some
                        character that is not listed in the Composition Exclusion Table defined in
                           <bibref ref="Unicode-Normalization"/>;</p>
                  </item>
                  <item>
                     <p>of non-zero canonical combining class (as defined in <bibref ref="Unicode"
                        />).</p>
                  </item>

               </ulist>
            </item>
            <item>
               <p>A string is converted to FULLY-NORMALIZED form as follows:</p>
               <ulist>
                  <item>
                     <p>if the first character in the string is a composing character, prepend a
                        single space (x20);</p>
                  </item>
                  <item>
                     <p>convert the resulting string to normalization form NFC.</p>
                  </item>
               </ulist>
            </item>
         </ulist>

         <p diff="add" At="L">Conforming implementations <rfc2119>must</rfc2119> support normalization form "NFC" and
               <rfc2119>may</rfc2119> support normalization forms "NFD", "NFKC", "NFKD", and
            "FULLY-NORMALIZED". They <rfc2119>may</rfc2119> also support other normalization forms
            with <termref def="implementation-defined">implementation-defined</termref> semantics. </p>
         <p diff="add" at="L">It is <termref def="dt-implementation-defined">implementation-defined</termref> which version of
            Unicode (and therefore, of the normalization algorithms and their underlying
            data) is supported by the implementation. See <bibref ref="Unicode-Normalization"/> for details of the
            stability policy regarding changes to the normalization rules in future
            versions of Unicode. If the input string contains codepoints that are
            unassigned in the relevant version of Unicode, or for which no normalization
            rules are defined, the <code>fn:normalize-unicode</code> function leaves such codepoints
            unchanged. If the implementation supports the requested normalization form then
            it <rfc2119>must</rfc2119> be able to handle every input string without raising an error.</p>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="CH" code="0003"/> if the effective value of the
               <code>$normalizationForm</code> argument is not one of the values supported by the
            implementation.</p>
      </fos:errors>
   </fos:function>
   <fos:function name="upper-case" prefix="fn">
      <fos:signatures>
         <fos:proto name="upper-case" return-type="xs:string">
            <fos:arg name="arg" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Converts a string to upper case.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg</code> is the empty sequence, the zero-length string is
            returned.</p>
         <p>Otherwise, the function returns the value of <code>$arg</code> after translating every
               <termref def="character">character</termref> to its upper-case correspondent as
            defined in the appropriate case mappings section in the Unicode standard <bibref
               ref="Unicode"/>. For versions of Unicode beginning with the 2.1.8 update, only
            locale-insensitive case mappings should be applied. Beginning with version 3.2.0 (and
            likely future versions) of Unicode, precise mappings are described in default case
            operations, which are full case mappings in the absence of tailoring for particular
            languages and environments. Every lower-case character that does not have an upper-case
            correspondent, as well as every upper-case character, is included in the returned value
            in its original form. </p>
      </fos:rules>
      <fos:notes>
         <p>Case mappings may change the length of a string. In general, the
               <code>fn:upper-case</code> and <code>fn:lower-case</code> functions are not inverses
            of each other: <code>fn:lower-case(fn:upper-case($arg))</code> is not guaranteed to
            return <code>$arg</code>, nor is <code>fn:upper-case(fn:lower-case($arg))</code>. The
            Latin small letter dotless i (as used in Turkish) is perhaps the most prominent
            lower-case letter which will not round-trip. The Latin capital letter i with dot above
            is the most prominent upper-case letter which will not round trip; there are others,
            such as Latin capital letter Sharp S (#1E9E) which is introduced in Unicode 5.1.</p>
         <p> These functions may not always be linguistically appropriate (e.g. Turkish i without
            dot) or appropriate for the application (e.g. titlecase). In cases such as Turkish, a
            simple translation should be used first.</p>
         <p> Because the function is not sensitive to locale, results will not always match user
            expectations. In Quebec, for example, the standard uppercase equivalent of "è" is "È",
            while in metropolitan France it is more commonly "E"; only one of these is supported by
            the functions as defined.</p>
         <p> Many characters of class Ll lack uppercase equivalents in the Unicode case mapping
            tables; many characters of class Lu lack lowercase equivalents.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:upper-case("abCd0")</fos:expression>
               <fos:result>"ABCD0"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="lower-case" prefix="fn">
      <fos:signatures>
         <fos:proto name="lower-case" return-type="xs:string">
            <fos:arg name="arg" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Converts a string to lower case.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg</code> is the empty sequence, the zero-length string is
            returned.</p>
         <p>Otherwise, the function returns the value of <code>$arg</code> after translating every
               <termref def="character">character</termref> to its lower-case correspondent as
            defined in the appropriate case mappings section in the Unicode standard <bibref
               ref="Unicode"/>. For versions of Unicode beginning with the 2.1.8 update, only
            locale-insensitive case mappings should be applied. Beginning with version 3.2.0 (and
            likely future versions) of Unicode, precise mappings are described in default case
            operations, which are full case mappings in the absence of tailoring for particular
            languages and environments. Every upper-case character that does not have a lower-case
            correspondent, as well as every lower-case character, is included in the returned value
            in its original form. </p>
      </fos:rules>
      <fos:notes>
         <p>Case mappings may change the length of a string. In general, the
               <code>fn:upper-case</code> and <code>fn:lower-case</code> functions are not inverses
            of each other: <code>fn:lower-case(fn:upper-case($arg))</code> is not guaranteed to
            return <code>$arg</code>, nor is <code>fn:upper-case(fn:lower-case($arg))</code>. The
            Latin small letter dotless i (as used in Turkish) is perhaps the most prominent
            lower-case letter which will not round-trip. The Latin capital letter i with dot above
            is the most prominent upper-case letter which will not round trip; there are others,
            such as Latin capital letter Sharp S (#1E9E) which is introduced in Unicode 5.1.</p>
         <p> These functions may not always be linguistically appropriate (e.g. Turkish i without
            dot) or appropriate for the application (e.g. titlecase). In cases such as Turkish, a
            simple translation should be used first.</p>
         <p> Because the function is not sensitive to locale, results will not always match user
            expectations. In Quebec, for example, the standard uppercase equivalent of "è" is "È",
            while in metropolitan France it is more commonly "E"; only one of these is supported by
            the functions as defined.</p>
         <p> Many characters of class Ll lack uppercase equivalents in the Unicode case mapping
            tables; many characters of class Lu lack lowercase equivalents.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:lower-case("ABc!D")</fos:expression>
               <fos:result>"abc!d"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="translate" prefix="fn">
      <fos:signatures>
         <fos:proto name="translate" return-type="xs:string">
            <fos:arg name="arg" type="xs:string?"/>
            <fos:arg name="mapString" type="xs:string"/>
            <fos:arg name="transString" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the value of <code>$arg</code> modified by replacing or removing
            individual characters. </p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg</code> is the empty sequence, the function returns the
            zero-length string.</p>
         <p>Otherwise, the function returns a result string constructed by processing each <termref
               def="character">character</termref> in the value of <code>$arg</code>, in order,
            according to the following rules:</p>
         <olist>
            <item>
               <p>If the character does not appear in the value of <code>$mapString</code> then it
                  is added to the result string unchanged.</p>
            </item>
            <item>
               <p>If the character first appears in the value of <code>$mapString</code> at some
                  position <emph>M</emph>, where the value of <code>$transString</code> is
                     <emph>M</emph> or more characters in length, then the character at position
                     <emph>M</emph> in <code>$transString</code> is added to the result string.</p>
            </item>
            <item>
               <p>If the character first appears in the value of <code>$mapString</code> at some
                  position <emph>M</emph>, where the value of <code>$transString</code> is less than
                     <emph>M</emph> characters in length, then the character is omitted from the
                  result string.</p>
            </item>
         </olist>
      </fos:rules>
      <fos:notes>
         <p>If <code>$mapString</code> is the zero-length string then the function returns
               <code>$arg</code> unchanged.</p>
         <p>If a character occurs more than once in <code>$mapString</code>, then the first
            occurrence determines the action taken.</p>
         <p>If <code>$transString</code> is longer than <code>$mapString</code>, the excess
            characters are ignored.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:translate("bar","abc","ABC")</fos:expression>
               <fos:result>"BAr"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:translate("--aaa--","abc-","ABC")</fos:expression>
               <fos:result>"AAA"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:translate("abcdabc", "abc", "AB")</fos:expression>
               <fos:result>"ABdAB"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="encode-for-uri" prefix="fn">
      <fos:signatures>
         <fos:proto name="encode-for-uri" return-type="xs:string">
            <fos:arg name="uri-part" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Encodes reserved characters in a string that is intended to be used in the path
            segment of a URI.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$uri-part</code> is the empty sequence, the function returns the zero-length
            string.</p>
         <p>This function applies the URI escaping rules defined in section 2 of <bibref
               ref="rfc3986"/> to the <code>xs:string</code> supplied as <code>$uri-part</code>. The
            effect of the function is to escape reserved characters. Each such character in the
            string is replaced with its percent-encoded form as described in <bibref ref="rfc3986"
            />.</p>
         <p>Since <bibref ref="rfc3986"/> recommends that, for consistency, URI producers and
            normalizers should use uppercase hexadecimal digits for all percent-encodings, this
            function must always generate hexadecimal values using the upper-case letters A-F.</p>
      </fos:rules>
      <fos:notes>
         <p>All characters are escaped except those identified as "unreserved" by <bibref
               ref="rfc3986"/>, that is the upper- and lower-case letters A-Z, the digits 0-9,
            HYPHEN-MINUS ("-"), LOW LINE ("_"), FULL STOP ".", and TILDE "~".</p>
         <p>This function escapes URI delimiters and therefore cannot be used indiscriminately to
            encode "invalid" characters in a path segment.</p>
         <p>This function is invertible but not idempotent. This is because a string containing a
            percent character will be modified by applying the function: for example
               <code>100%</code> becomes <code>100%25</code>, while <code>100%25</code> becomes
               <code>100%2525</code>.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:encode-for-uri("http://www.example.com/00/Weather/CA/Los%20Angeles#ocean")</fos:expression>
               <fos:result>"http%3A%2F%2Fwww.example.com%2F00%2FWeather%2FCA%2FLos%2520Angeles%23ocean"</fos:result>
               <fos:postamble>This is probably not what the user intended because all of the
                  delimiters have been encoded.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>concat("http://www.example.com/",
                  encode-for-uri("~bébé"))</fos:expression>
               <fos:result>"http://www.example.com/~b%C3%A9b%C3%A9"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>concat("http://www.example.com/", encode-for-uri("100%
                  organic"))</fos:expression>
               <fos:result>"http://www.example.com/100%25%20organic"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="iri-to-uri" prefix="fn">
      <fos:signatures>
         <fos:proto name="iri-to-uri" return-type="xs:string">
            <fos:arg name="iri" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Converts a string containing an IRI into a URI according to the rules of
               <bibref ref="rfc3987"/>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$iri</code> is the empty sequence, the function returns the zero-length
            string.</p>
         <p>Otherwise, the function converts the value of <code>$iri</code> into a URI according to
            the rules given in Section 3.1 of <bibref ref="rfc3987"/> by percent-encoding characters
            that are allowed in an IRI but not in a URI. If <code>$iri</code> contains a character
            that is invalid in an IRI, such as the space character (see note below), the invalid
            character is replaced by its percent-encoded form as described in <bibref ref="rfc3986"
            /> before the conversion is performed.</p>
         <p>Since <bibref ref="rfc3986"/> recommends that, for consistency, URI producers and
            normalizers should use uppercase hexadecimal digits for all percent-encodings, this
            function must always generate hexadecimal values using the upper-case letters A-F.</p>
      </fos:rules>
      <fos:notes>
         <p>The function is idempotent but not invertible. Both the inputs <code>My Documents</code>
            and <code>My%20Documents</code> will be converted to the output
               <code>My%20Documents</code>.</p>
         <p>This function does not check whether <code>$iri</code> is a valid IRI. It treats it as
            an <termref def="string">string</termref> and operates on the <termref def="character"
               >characters</termref> in the string.</p>
         <!--Text replaced by erratum E8 change 1"-->
         <p> The following printable ASCII characters are invalid in an IRI: "&lt;", "&gt;", <quote>
               " </quote> (double quote), space, "{", "}", "|", "\", "^", and "`". Since these
            characters should not appear in an IRI, if they do appear in <code>$iri</code> they will
            be percent-encoded. In addition, characters outside the range x20-<phrase diff="chg"
               at="A-E8">x7E</phrase> will be percent-encoded because they are invalid in a URI. </p>
         <!--End of text replaced by erratum E8-->
         <p> Since this function does not escape the PERCENT SIGN "%" and this character is not
            allowed in data within a URI, users wishing to convert character strings (such as file
            names) that include "%" to a URI should manually escape "%" by replacing it with "%25".
         </p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:iri-to-uri
                  ("http://www.example.com/00/Weather/CA/Los%20Angeles#ocean")</fos:expression>
               <fos:result>"http://www.example.com/00/Weather/CA/Los%20Angeles#ocean"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:iri-to-uri ("http://www.example.com/~bébé")</fos:expression>
               <fos:result>"http://www.example.com/~b%C3%A9b%C3%A9"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="escape-html-uri" prefix="fn">
      <fos:signatures>
         <fos:proto name="escape-html-uri" return-type="xs:string">
            <fos:arg name="uri" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Escapes a URI in the same way that HTML user agents handle attribute values
            expected to contain URIs.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$uri</code> is the empty sequence, the function returns the zero-length
            string.</p>
         <p>Otherwise, the function escapes all <termref def="character">characters</termref> except
            printable characters of the US-ASCII coded character set, specifically the <termref
               def="codepoint">codepoints</termref> between 32 and 126 (decimal) inclusive. Each
            character in <code>$uri</code> to be escaped is replaced by an escape sequence, which is
            formed by encoding the character as a sequence of octets in UTF-8, and then representing
            each of these octets in the form %HH, where HH is the hexadecimal representation of the
            octet. This function must always generate hexadecimal values using the upper-case
            letters A-F.</p>
      </fos:rules>
      <fos:notes>
         <p>The behavior of this function corresponds to the recommended handling of non-ASCII
            characters in URI attribute values as described in <bibref ref="HTML40"/> Appendix
            B.2.1.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:escape-html-uri ("http://www.example.com/00/Weather/CA/Los
                  Angeles#ocean")</fos:expression>
               <fos:result>"http://www.example.com/00/Weather/CA/Los Angeles#ocean"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:escape-html-uri ("javascript:if (navigator.browserLanguage ==
                  'fr') window.open('http://www.example.com/~bébé');")</fos:expression>
               <fos:result>"javascript:if (navigator.browserLanguage == 'fr')
                  window.open('http://www.example.com/~b%C3%A9b%C3%A9');"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="contains" prefix="fn">
      <fos:signatures>
         <fos:proto name="contains" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="contains" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="3">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations static-base-uri">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns true if the string <code>$arg1</code> contains <code>$arg2</code> as a
            substring, taking collations into account.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg1</code> or <code>$arg2</code> is the empty sequence, or
            contains only ignorable collation units, it is interpreted as the zero-length
            string.</p>
         <p>If the value of <code>$arg2</code> is the zero-length string, then the function returns
               <code>true</code>.</p>
         <p>If the value of <code>$arg1</code> is the zero-length string, the function returns
               <code>false</code>.</p>
         <p>The collation used by this function is determined according to the rules in <specref
               ref="choosing-a-collation"/>.</p>
         <p>The function returns an <code>xs:boolean</code> indicating whether or not the value of
               <code>$arg1</code> contains (at the beginning, at the end, or anywhere within) at
            least one sequence of collation units that provides a <term>minimal match</term> to the
            collation units in the value of <code>$arg2</code>, according to the collation that is
            used.</p>
         <note>
            <p><term>Minimal match</term> is defined in <bibref ref="Unicode-Collations"/>. </p>
         </note>

      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error <rfc2119>may</rfc2119> be raised <errorref class="CH" code="0004"/> if the
            specified collation does not support collation units.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <p>The collation used in these examples, <code>http://example.com/CollationA</code> is a
               collation in which both "-" and "*" are ignorable collation units.</p>
            <p>"Ignorable collation unit" is equivalent to "ignorable collation element" in <bibref
                  ref="Unicode-Collations"/>.</p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:contains ( "tattoo", "t")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:contains ( "tattoo", "ttt")</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:contains ( "", ())</fos:expression>
               <fos:result>true()</fos:result>
               <fos:postamble>The first rule is applied, followed by the second
                  rule.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:contains ( "abcdefghi", "-d-e-f-",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:contains ( "a*b*c*d*e*f*g*h*i*", "d-ef-",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:contains ( "abcd***e---f*--*ghi", "def",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:contains ( (), "--***-*---",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
               <fos:postamble>The second argument contains only ignorable collation units and is
                  equivalent to the zero-length string.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="starts-with" prefix="fn">
      <fos:signatures>
         <fos:proto name="starts-with" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="starts-with" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="3">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations static-base-uri">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns true if the string <code>$arg1</code> contains <code>$arg2</code> as a
            leading substring, taking collations into account.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg1</code> or <code>$arg2</code> is the empty sequence, or
            contains only ignorable collation units, it is interpreted as the zero-length
            string.</p>
         <p>If the value of <code>$arg2</code> is the zero-length string, then the function returns
               <code>true</code>. If the value of <code>$arg1</code> is the zero-length string and
            the value of <code>$arg2</code> is not the zero-length string, then the function returns
               <code>false</code>.</p>
         <p>The collation used by this function is determined according to the rules in <specref
               ref="choosing-a-collation"/>.</p>
         <p>The function returns an <code>xs:boolean</code> indicating whether or not the value of
               <code>$arg1</code> starts with a sequence of collation units that provides a
               <term>match</term> to the collation units of <code>$arg2</code> according to the
            collation that is used.</p>
         <note>
            <p><term>Match</term> is defined in <bibref ref="Unicode-Collations"/>.</p>
         </note>

      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error <rfc2119>may</rfc2119> be raised <errorref class="CH" code="0004"/> if the
            specified collation does not support collation units.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <p>The collation used in these examples, <code>http://example.com/CollationA</code> is a
               collation in which both "-" and "*" are ignorable collation units.</p>
            <p>"Ignorable collation unit" is equivalent to "ignorable collation element" in <bibref
                  ref="Unicode-Collations"/>.</p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:starts-with("tattoo", "tat")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:starts-with ( "tattoo", "att")</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:starts-with ((), ())</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:starts-with ( "abcdefghi", "-a-b-c-",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:starts-with ( "a*b*c*d*e*f*g*h*i*", "a-bc-",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:starts-with ( "abcd***e---f*--*ghi", "abcdef",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:starts-with ( (), "--***-*---",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
               <fos:postamble>The second argument contains only ignorable collation units and is
                  equivalent to the zero-length string.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:starts-with ( "-abcdefghi", "-abc",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="ends-with" prefix="fn">
      <fos:signatures>
         <fos:proto name="ends-with" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="ends-with" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="3">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations static-base-uri">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns true if the string <code>$arg1</code> contains <code>$arg2</code> as a
            trailing substring, taking collations into account.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg1</code> or <code>$arg2</code> is the empty sequence, or
            contains only ignorable collation units, it is interpreted as the zero-length
            string.</p>
         <p>If the value of <code>$arg2</code> is the zero-length string, then the function returns
               <code>true</code>. If the value of <code>$arg1</code> is the zero-length string and
            the value of <code>$arg2</code> is not the zero-length string, then the function returns
               <code>false</code>.</p>
         <p>The collation used by this function is determined according to the rules in <specref
               ref="choosing-a-collation"/>.</p>
         <p>The function returns an <code>xs:boolean</code> indicating whether or not the value of
               <code>$arg1</code> starts with a sequence of collation units that provides a
               <term>match</term> to the collation units of <code>$arg2</code> according to the
            collation that is used.</p>
         <note>
            <p>
               <term>Match</term> is defined in <bibref ref="Unicode-Collations"/>. </p>
         </note>

      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error <rfc2119>may</rfc2119> be raised <errorref class="CH" code="0004"/> if the
            specified collation does not support collation units.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <p>The collation used in these examples, <code>http://example.com/CollationA</code> is a
               collation in which both "-" and "*" are ignorable collation units.</p>
            <p>"Ignorable collation unit" is equivalent to "ignorable collation element" in <bibref
                  ref="Unicode-Collations"/>.</p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ends-with ( "tattoo", "tattoo")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ends-with ( "tattoo", "atto")</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ends-with ((), ())</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ends-with ( "abcdefghi", "-g-h-i-",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ends-with ( "abcd***e---f*--*ghi", "defghi",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ends-with ( "abcd***e---f*--*ghi", "defghi",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ends-with ( (), "--***-*---",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
               <fos:postamble>The second argument contains only ignorable collation units and is
                  equivalent to the zero-length string.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:ends-with ( "abcdefghi", "ghi-",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="substring-before" prefix="fn">
      <fos:signatures>
         <fos:proto name="substring-before" return-type="xs:string">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="substring-before" return-type="xs:string">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="3">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations static-base-uri">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the part of <code>$arg1</code> that precedes the first occurrence of
               <code>$arg2</code>, taking collations into account.</p>
      </fos:summary>
      <fos:rules>
         <p> If the value of <code>$arg1</code> or <code>$arg2</code> is the empty sequence, or
            contains only ignorable collation units, it is interpreted as the zero-length
            string.</p>
         <p>If the value of <code>$arg2</code> is the zero-length string, then the function returns
            the zero-length string. </p>
         <p>If the value of <code>$arg1</code> does not contain a string that is equal to the value
            of <code>$arg2</code>, then the function returns the zero-length string. </p>
         <p>The collation used by this function is determined according to the rules in <specref
               ref="choosing-a-collation"/>.</p>
         <p>The function returns the substring of the value of <code>$arg1</code> that precedes in
            the value of <code>$arg1</code> the first occurrence of a sequence of collation units
            that provides a <term>minimal match</term> to the collation units of <code>$arg2</code>
            according to the collation that is used.</p>
         <note>
            <p><term>Minimal match</term> is defined in <bibref ref="Unicode-Collations"/>. </p>
         </note>

      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error <rfc2119>may</rfc2119> be raised <errorref class="CH" code="0004"/> if the
            specified collation does not support collation units.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <p>The collation used in these examples, <code>http://example.com/CollationA</code> is a
               collation in which both "-" and "*" are ignorable collation units.</p>
            <p>"Ignorable collation unit" is equivalent to "ignorable collation element" in <bibref
                  ref="Unicode-Collations"/>.</p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-before ( "tattoo", "attoo")</fos:expression>
               <fos:result>"t"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-before ( "tattoo", "tatto")</fos:expression>
               <fos:result>""</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-before ((), ())</fos:expression>
               <fos:result>""</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-before ( "abcdefghi", "--d-e-",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>"abc"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-before ( "abc--d-e-fghi", "--d-e-",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>"abc--"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-before ( "a*b*c*d*e*f*g*h*i*", "***cde",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>"a*b*"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-before ( "Eureka!", "--***-*---",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>""</fos:result>
               <fos:postamble>The second argument contains only ignorable collation units and is
                  equivalent to the zero-length string.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="substring-after" prefix="fn">
      <fos:signatures>
         <fos:proto name="substring-after" return-type="xs:string">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="substring-after" return-type="xs:string">
            <fos:arg name="arg1" type="xs:string?"/>
            <fos:arg name="arg2" type="xs:string?"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="3">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations static-base-uri">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the part of <code>$arg1</code> that follows the first occurrence of
               <code>$arg2</code>, taking collations into account.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg1</code> or <code>$arg2</code> is the empty sequence, or
            contains only ignorable collation units, it is interpreted as the zero-length
            string.</p>
         <p>If the value of <code>$arg2</code> is the zero-length string, then the function returns
            the value of <code>$arg1</code>.</p>
         <p>If the value of <code>$arg1</code> does not contain a string that is equal to the value
            of <code>$arg2</code>, then the function returns the zero-length string. </p>
         <p>The collation used by this function is determined according to the rules in <specref
               ref="choosing-a-collation"/>.</p>
         <p>The function returns the substring of the value of <code>$arg1</code> that follows in
            the value of <code>$arg1</code> the first occurrence of a sequence of collation units
            that provides a <term>minimal match</term> to the collation units of <code>$arg2</code>
            according to the collation that is used. </p>
         <note>
            <p><term>Minimal match</term> is defined in <bibref ref="Unicode-Collations"/>. </p>
         </note>

      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error <rfc2119>may</rfc2119> be raised <errorref class="CH" code="0004"/> if the
            specified collation does not support collation units.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <p>The collation used in these examples, <code>http://example.com/CollationA</code> is a
               collation in which both "-" and "*" are ignorable collation units.</p>
            <p>"Ignorable collation unit" is equivalent to "ignorable collation element" in <bibref
                  ref="Unicode-Collations"/>.</p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-after("tattoo", "tat")</fos:expression>
               <fos:result>"too"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-after("tattoo", "tattoo")</fos:expression>
               <fos:result>""</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-after((), ())</fos:expression>
               <fos:result>""</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression> fn:substring-after("abcdefghi", "--d-e-",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>"fghi"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-after("abc--d-e-fghi", "--d-e-",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>"-fghi"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-after ( "a*b*c*d*e*f*g*h*i*", "***cde***",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>"*f*g*h*i*"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:substring-after ( "Eureka!", "--***-*---",
                  "http://example.com/CollationA")</fos:expression>
               <fos:result>"Eureka!"</fos:result>
               <fos:postamble>The second argument contains only ignorable collation units and is
                  equivalent to the zero-length string.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="matches" prefix="fn">
      <fos:signatures>
         <fos:proto name="matches" return-type="xs:boolean">
            <fos:arg name="input" type="xs:string?"/>
            <fos:arg name="pattern" type="xs:string"/>
         </fos:proto>
         <fos:proto name="matches" return-type="xs:boolean">
            <fos:arg name="input" type="xs:string?"/>
            <fos:arg name="pattern" type="xs:string"/>
            <fos:arg name="flags" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns true if the supplied string matches a given regular expression.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of calling the first version of this function (omitting the argument
               <code>$flags</code>) is the same as the effect of calling the second version with the
               <code>$flags</code> argument set to a zero-length string. Flags are defined in
               <specref ref="flags"/>.</p>
         <p>If <code>$input</code> is the empty sequence, it is interpreted as the zero-length
            string.</p>
         <p>The function returns <code>true</code> if <code>$input</code> or some substring of
               <code>$input</code> matches the regular expression supplied as <code>$pattern</code>.
            Otherwise, the function returns <code>false</code>. The matching rules are influenced by
            the value of <code>$flags</code> if present. </p>

      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RX" code="0002"/> if the value of
               <code>$pattern</code> is invalid according to the rules described in <specref
               ref="regex-syntax"/>. </p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RX" code="0001"/> if the value of
               <code>$flags</code> is invalid according to the rules described in <specref
               ref="flags"/>. </p>
      </fos:errors>
      <fos:notes>
         <p>Unless the metacharacters <code>^</code> and <code>$</code> are used as anchors, the
            string is considered to match the pattern if any substring matches the pattern. But if
            anchors are used, the anchors must match the start/end of the string (in string mode),
            or the start/end of a line (in multi-line mode). </p>
         <p>This is different from the behavior of patterns in <bibref ref="xmlschema-2"/>, where
            regular expressions are <emph>implicitly</emph> anchored.</p>
         <p>Regular expression matching is defined on the basis of Unicode code points; it takes no
            account of collations.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:matches("abracadabra", "bra")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:matches("abracadabra", "^a.*a$")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:matches("abracadabra", "^bra")</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p>Given the source document:</p>
         </fos:example>
         <fos:variable name="poem" as="element()"><![CDATA[
<poem author="Wilhelm Busch"> 
Kaum hat dies der Hahn gesehen, 
Fängt er auch schon an zu krähen: 
Kikeriki! Kikikerikih!! 
Tak, tak, tak! - da kommen sie. 
</poem>]]></fos:variable>
         <fos:example>
            <p>the following function calls produce the following results, with the
                  <code>poem</code> element as the context node:</p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:matches($poem, "Kaum.*krähen")</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:matches($poem, "Kaum.*krähen", "s")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:matches($poem, "^Kaum.*gesehen,$", "m")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:matches($poem, "^Kaum.*gesehen,$")</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:matches($poem, "kiki", "i")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="replace" prefix="fn">
      <fos:signatures>
         <fos:proto name="replace" return-type="xs:string">
            <fos:arg name="input" type="xs:string?"/>
            <fos:arg name="pattern" type="xs:string"/>
            <fos:arg name="replacement" type="xs:string"/>
         </fos:proto>
         <fos:proto name="replace" return-type="xs:string">
            <fos:arg name="input" type="xs:string?"/>
            <fos:arg name="pattern" type="xs:string"/>
            <fos:arg name="replacement" type="xs:string"/>
            <fos:arg name="flags" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a string produced from the input string by replacing any substrings
            that match a given regular expression with a supplied replacement string.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of calling the first version of this function (omitting the argument
               <code>$flags</code>) is the same as the effect of calling the second version with the
               <code>$flags</code> argument set to a zero-length string. Flags are defined in
               <specref ref="flags"/>.</p>
         <p>The <code>$flags</code> argument is interpreted in the same manner as for the
               <code>fn:matches</code> function. </p>
         <p>If <code>$input</code> is the empty sequence, it is interpreted as the zero-length
            string.</p>
         <p>The function returns the <code>xs:string</code> that is obtained by replacing each
            non-overlapping substring of <code>$input</code> that matches the given
               <code>$pattern</code> with an occurrence of the <code>$replacement</code> string.</p>
         <p>If two overlapping substrings of <code>$input</code> both match the
               <code>$pattern</code>, then only the first one (that is, the one whose first <termref
               def="character">character</termref> comes first in the <code>$input</code> string) is
            replaced.</p>
         <p diff="add" at="B">If the <code>q</code> flag is present, the replacement string is used
               <emph>as is</emph>.</p>
         <p><phrase diff="add" at="B">Otherwise,</phrase> within the <code>$replacement</code>
            string, a variable <code>$N</code> may be used to refer to the substring captured by the
            Nth parenthesized sub-expression in the regular expression. For each match of the
            pattern, these variables are assigned the value of the content matched by the relevant
            sub-expression, and the modified replacement string is then substituted for the <termref
               def="character">characters</termref> in <code>$input</code> that matched the pattern.
               <code>$0</code> refers to the substring captured by the regular expression as a
            whole.</p>
         <p>More specifically, the rules are as follows, where <code>S</code> is the number of
            parenthesized sub-expressions in the regular expression, and <code>N</code> is the
            decimal number formed by taking all the digits that consecutively follow the
               <code>$</code> character:</p>

         <olist>
            <item>
               <p>If <code>N</code>=<code>0</code>, then the variable is replaced by the substring
                  matched by the regular expression as a whole.</p>
            </item>
            <item>
               <p>If <code>1</code>&lt;=<code>N</code>&lt;=<code>S</code>, then the variable is
                  replaced by the substring captured by the Nth parenthesized sub-expression. If the
                     <code>Nth</code> parenthesized sub-expression was not matched, then the
                  variable is replaced by the zero-length string.</p>
            </item>
            <item>
               <p>If <code>S</code>&lt;<code>N</code>&lt;=<code>9</code>, then the variable is
                  replaced by the zero-length string.</p>
            </item>
            <item>
               <p>Otherwise (if <code>N</code>&gt;<code>S</code> and
                     <code>N</code>&gt;<code>9</code>), the last digit of <code>N</code> is taken to
                  be a literal character to be included "as is" in the replacement string, and the
                  rules are reapplied using the number <code>N</code> formed by stripping off this
                  last digit.</p>
            </item>
         </olist>

         <p>For example, if the replacement string is <quote>
               <code>$23</code>
            </quote> and there are 5 substrings, the result contains the value of the substring that
            matches the second sub-expression, followed by the digit <quote>
               <code>3</code>
            </quote>.</p>
         <p diff="chg" at="B">Unless the <code>q</code> flag is used, a literal <code>$</code>
            character within the replacement string must be written as <code>\$</code>, and a
            literal <code>\</code> character must be written as <code>\\</code>.</p>

         <p> If two alternatives within the pattern both match at the same position in the
               <code>$input</code>, then the match that is chosen is the one matched by the first
            alternative. For example:</p>
         <eg xml:space="preserve"> fn:replace("abcd", "(ab)|(a)", "[1=$1][2=$2]") returns "[1=ab][2=]cd"</eg>

      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RX" code="0002"/> if the value of
               <code>$pattern</code> is invalid according to the rules described in section <specref
               ref="regex-syntax"/>. </p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RX" code="0001"/> if the value of
               <code>$flags</code> is invalid according to the rules described in section <specref
               ref="regex-syntax"/>. </p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RX" code="0003"/> if the pattern matches a
            zero-length string, that is, if the expression <code>fn:matches("", $pattern,
               $flags)</code> returns <code>true</code>. It is not an error, however, if a captured
            substring is zero-length.</p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RX" code="0004"/> if the value of
               <code>$replacement</code> contains a "<code>$</code>" character that is not
            immediately followed by a digit <code>0-9</code> and not immediately preceded by a
            "\".</p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RX" code="0004"/> if the value of
               <code>$replacement</code> contains a "<code>\</code>" character that is not part of a
               "<code>\\</code>" pair, unless it is immediately followed by a "<code>$</code>"
            character.</p>
      </fos:errors>
      <fos:notes>
         <p diff="add" at="G"><!--bug 10261-->If the input string contains no substring that matches
            the regular expression, the result of the function is a single string identical to the
            input string.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>replace("abracadabra", "bra", "*")</fos:expression>
               <fos:result>"a*cada*"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>replace("abracadabra", "a.*a", "*")</fos:expression>
               <fos:result>"*"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>replace("abracadabra", "a.*?a", "*")</fos:expression>
               <fos:result>"*c*bra"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>replace("abracadabra", "a", "")</fos:expression>
               <fos:result>"brcdbr"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>replace("abracadabra", "a(.)", "a$1$1")</fos:expression>
               <fos:result>"abbraccaddabbra"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p>The expression <code>replace("abracadabra", ".*?", "$1")</code> raises an error,
               because the pattern matches the zero-length string </p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>replace("AAAA", "A+", "b")</fos:expression>
               <fos:result>"b"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>replace("AAAA", "A+?", "b")</fos:expression>
               <fos:result>"bbbb"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>replace("darted", "^(.*?)d(.*)$", "$1c$2")</fos:expression>
               <fos:result>"carted"</fos:result>
               <fos:postamble>The first <code>d</code> is replaced.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="tokenize" prefix="fn">
      <fos:signatures>
         <fos:proto name="tokenize" return-type="xs:string*">
            <fos:arg name="input" type="xs:string?"/>
            <fos:arg name="pattern" type="xs:string"/>
         </fos:proto>
         <fos:proto name="tokenize" return-type="xs:string*">
            <fos:arg name="input" type="xs:string?"/>
            <fos:arg name="pattern" type="xs:string"/>
            <fos:arg name="flags" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a sequence of strings constructed by splitting the input wherever a
            separator is found; the separator is any substring that matches a given regular
            expression.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of calling the first version of this function (omitting the argument
               <code>$flags</code>) is the same as the effect of calling the second version with the
               <code>$flags</code> argument set to a zero-length string. Flags are defined in
               <specref ref="flags"/>.</p>
         <p>The <code>$flags</code> argument is interpreted in the same way as for the
               <code>fn:matches</code> function.</p>
         <p>If <code>$input</code> is the empty sequence, or if <code>$input</code> is the
            zero-length string, the function returns the empty sequence.</p>

         <p>The function returns a sequence of strings formed by breaking the <code>$input</code>
            string into a sequence of strings, treating any substring that matches
               <code>$pattern</code> as a separator. The separators themselves are not returned.</p>
         <p>If a separator occurs at the start of the <code>$input</code> string, the result
            sequence will start with a zero-length string. Zero-length strings will also occur in
            the result sequence if a separator occurs at the end of the <code>$input</code> string,
            or if two adjacent substrings match the supplied <code>$pattern</code>.</p>
         <p> If two alternatives within the supplied <code>$pattern</code> both match at the same
            position in the <code>$input</code> string, then the match that is chosen is the first.
            For example:</p>
         <eg xml:space="preserve"> fn:tokenize("abracadabra", "(ab)|(a)") returns ("", "r", "c", "d", "r", "")</eg>

      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RX" code="0002"/> if the value of
               <code>$pattern</code> is invalid according to the rules described in section <specref
               ref="regex-syntax"/>.</p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RX" code="0001"/> if the value of
               <code>$flags</code> is invalid according to the rules described in section <specref
               ref="regex-syntax"/>.</p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RX" code="0003"/> if the supplied
               <code>$pattern</code> matches a zero-length string, that is, if <code>fn:matches("",
               $pattern, $flags)</code> returns <code>true</code>. </p>

      </fos:errors>
      <fos:notes>
         <p diff="add" at="G"><!--bug 10261-->If the input string is not zero length, and no
            separators are found in the input string, the result of the function is a single string
            identical to the input string.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:tokenize("The cat sat on the mat", "\s+")</fos:expression>
               <fos:result>("The", "cat", "sat", "on", "the", "mat")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:tokenize("1, 15, 24, 50", ",\s*")</fos:expression>
               <fos:result>("1", "15", "24", "50")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:tokenize("1,15,,24,50,", ",")</fos:expression>
               <fos:result>("1", "15", "", "24", "50", "")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p><code>fn:tokenize("abba", ".?")</code> raises the <phrase diff="add" at="L">dynamic</phrase> error <errorref class="RX"
                  code="0003"/>.</p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:tokenize("Some unparsed &lt;br&gt; HTML &lt;BR&gt; text",
                  "\s*&lt;br&gt;\s*", "i")</fos:expression>
               <fos:result>("Some unparsed", "HTML", "text")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="analyze-string" diff="add" at="B" prefix="fn">
      <fos:signatures>
         <fos:proto name="analyze-string" return-type="element(fn:analyze-string-result)">
            <fos:arg name="input" type="xs:string?"/>
            <fos:arg name="pattern" type="xs:string"/>
         </fos:proto>
         <fos:proto name="analyze-string" return-type="element(fn:analyze-string-result)">
            <fos:arg name="input" type="xs:string?"/>
            <fos:arg name="pattern" type="xs:string"/>
            <fos:arg name="flags" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>nondeterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Analyzes a string using a regular expression, returning an XML structure that
            identifies which parts of the input string matched or failed to match the regular
            expression, and in the case of matched substrings, which substrings matched each
            capturing group in the regular expression.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of calling the first version of this function (omitting the argument
               <code>$flags</code>) is the same as the effect of calling the second version with the
               <code>$flags</code> argument set to a zero-length string. Flags are defined in
               <specref ref="flags"/>.</p>
         <p>The <code>$flags</code> argument is interpreted in the same way as for the
               <code>fn:matches</code> function.</p>
         <p>If <code>$input</code> is the empty sequence the function behaves as if
               <code>$input</code> were the zero-length string. In this situation the result will be
            an element node with no children.</p>
         <p>The function returns an element node whose local name is
               <code>analyze-string-result</code>. This element and all its descendant elements have
            the namespace URI <code>http://www.w3.org/2005/xpath-functions</code>. The namespace
            prefix is <termref def="implementation-dependent"/>. The children of this element are a
            sequence of <code>fn:match</code> and <code>fn:non-match</code> elements. This sequence
            is formed by breaking the <code>$input</code> string into a sequence of strings,
            returning any substring that matches <code>$pattern</code> as the content of a
               <code>match</code> element, and any intervening substring as the content of a
               <code>non-match</code> element.</p>
         <p>More specifically, the function starts at the beginning of the input string and attempts
            to find the first substring that matches the regular expression. If there are several
            matches, the first match is defined to be the one whose starting position comes first in
            the string. If several alternatives within the regular expression both match at the same
            position in the input string, then the match that is chosen is the first alternative
            that matches. For example, if the input string is <code>The quick brown fox jumps</code>
            and the regular expression is <code>jump|jumps</code>, then the match that is chosen is
               <code>jump</code>.</p>

         <p>Having found the first match, the instruction proceeds to find the second and subsequent
            matches by repeating the search, starting at the first <termref def="character"
               >character</termref> that was not included in the previous match.</p>

         <p>The input string is thus partitioned into a sequence of substrings, some of which match
            the regular expression, others which do not match it. Each substring will contain at
            least one character. This sequence is represented in the result by the sequence of
               <code>fn:match</code> and <code>fn:non-match</code> children of the returned element
            node; the string value of the <code>fn:match</code> or <code>fn:non-match</code> element
            will be the corresponding substring of <code>$input</code>, and the string value of the
            returned element node will therefore be the same as <code>$input</code>.</p>

         <p>The content of an <code>fn:non-match</code> element is always a single text node.</p>

         <p>The content of a <code>fn:match</code> element, however, is in general a sequence of
            text nodes and <code>fn:group</code> element children. An <code>fn:group</code> element
            with a <code>nr</code> attribute having the integer value <var>N</var> identifies the
            substring captured by the <var>Nth</var> parenthesized sub-expression in the regular
            expression. For each capturing subexpression there will be at most one corresponding
               <code>fn:group</code> element in each <code>fn:match</code> element in the
            result.</p>

         <p>If the function is called twice with the same arguments, it is <termref
               def="implementation-dependent"/> whether the two calls return the same element node
            or distinct (but deep equal) element nodes. In this respect it is
            <termref def="nondeterministic">nondeterministic</termref>.</p>
         
         <p diff="add" at="J">The base URI of the element nodes in the result is
         <termref def="implementation-dependent"/></p>

         <p>A schema is defined for the structure of the returned element, containing the
            definitions below. The returned element and its descendants will have type annotations
            obtained by validating the returned element against this schema, unless the function is
            used in an environment where type annotations are not supported (for example, a Basic
            XSLT Processor), in which case the elements will all be annotated as
               <code>xs:untyped</code> and the attributes as <code>xs:untypedAtomic</code>.</p>
         
         <note><p diff="add" at="M">A free-standing copy of this schema can be found at <loc href="analyze-string.xsd">analyze-string.xsd</loc></p></note>

         <p>
            <eg><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
    targetNamespace="http://www.w3.org/2005/xpath-functions"
    xmlns:fn="http://www.w3.org/2005/xpath-functions"
    elementFormDefault="qualified"> 

    <xs:element name="analyze-string-result" type="fn:analyze-string-result-type"/>
    <xs:element name="match" type="fn:match-type"/>
    <xs:element name="non-match" type="xs:string"/>
    <xs:element name="group" type="fn:group-type"/>
    
    <xs:complexType name="analyze-string-result-type" mixed="true">
        <xs:choice minOccurs="0" maxOccurs="unbounded">
            <xs:element ref="fn:match"/>
            <xs:element ref="fn:non-match"/>
        </xs:choice>
    </xs:complexType>
        
    <xs:complexType name="match-type" mixed="true">
        <xs:sequence>
            <xs:element ref="fn:group" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>
    
    <xs:complexType name="group-type" mixed="true">
        <xs:sequence>
            <xs:element ref="fn:group" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="nr" type="xs:positiveInteger"/>
    </xs:complexType>    
 
</xs:schema>
]]></eg>
         </p>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RX" code="0002"/> if the value of
               <code>$pattern</code> is invalid according to the rules described in section <specref
               ref="regex-syntax"/>.</p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RX" code="0001"/> if the value of
               <code>$flags</code> is invalid according to the rules described in section <specref
               ref="regex-syntax"/>.</p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RX" code="0003"/> if the supplied
               <code>$pattern</code> matches a zero-length string, that is, if <code>fn:matches("",
               $pattern, $flags)</code> returns <code>true</code>.</p>
      </fos:errors>
      <fos:notes>
         <p diff="add" at="L">The declarations and definitions in the above schema are not automatically
            available in the static context of the <code>fn:analyze-string</code> call (or of any other expression).
            The contents of the static context are host-language defined, and in some host languages are implementation-defined.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p>In the following examples, the result document is shown in serialized form, with
               whitespace between the element nodes. This whitespace is not actually present in the
               result.</p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:analyze-string("The cat sat on the mat.", "\w+")</fos:expression>
               <fos:result as="element()"><![CDATA[
<analyze-string-result xmlns="http://www.w3.org/2005/xpath-functions">
  <match>The</match>
  <non-match> </non-match>
  <match>cat</match>
  <non-match> </non-match>
  <match>sat</match>
  <non-match> </non-match>
  <match>on</match>
  <non-match> </non-match>
  <match>the</match>
  <non-match> </non-match>
  <match>mat</match>
  <non-match>.</non-match>
</analyze-string-result>]]></fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:analyze-string("2008-12-03",
                  "^(\d+)\-(\d+)\-(\d+)$")</fos:expression>
               <fos:result as="element()"><![CDATA[
<analyze-string-result xmlns="http://www.w3.org/2005/xpath-functions">
  <match><group nr="1">2008</group>-<group nr="2">12</group>-<group nr="3">03</group></match>
</analyze-string-result>]]></fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:analyze-string("A1,C15,,D24, X50,",
                  "([A-Z])([0-9]+)")</fos:expression>
               <fos:result as="element()"><![CDATA[
<analyze-string-result xmlns="http://www.w3.org/2005/xpath-functions">                  
  <match><group nr="1">A</group><group nr="2">1</group></match>
  <non-match>,</non-match>
  <match><group nr="1">C</group><group nr="2">15</group></match>
  <non-match>,,</non-match>
  <match><group nr="1">D</group><group nr="2">24</group></match>
  <non-match>, </non-match>
  <match><group nr="1">X</group><group nr="2">50</group></match>
  <non-match>,</non-match>
</analyze-string-result>]]></fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="resolve-uri" diff="chg" at="F" prefix="fn">
      <fos:signatures>
         <fos:proto name="resolve-uri" return-type="xs:anyURI?">
            <fos:arg name="relative" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="resolve-uri" return-type="xs:anyURI?">
            <fos:arg name="relative" type="xs:string?"/>
            <fos:arg name="base" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="static-base-uri">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Resolves a relative IRI reference against an absolute IRI.</p>
      </fos:summary>
      <fos:rules>
         <p>If the second argument is absent, the effect is the same as calling the two-argument
            function with the value of <code>fn:static-base-uri()</code> as the second argument.</p>

         <p>The function is defined to operate on IRI references as defined in <bibref ref="rfc3987"
            />, and the implementation <rfc2119>must</rfc2119> permit all arguments that are valid
            according to that specification. In addition, the implementation <rfc2119>may</rfc2119>
            accept some or all strings that conform to the rules for (absolute or relative) Legacy
            Extended IRI references as defined in <bibref ref="LEIRI"/>. For the purposes of this
            section, the terms IRI and IRI reference include these extensions, insofar as the
            implementation chooses to support them.</p>

         <p>If <code>$relative</code> is the empty sequence, the function returns the empty
            sequence.</p>

         <p>If <code>$relative</code> is an absolute IRI (as defined above), then it is returned
            unchanged.</p>

         <p>Otherwise, the function resolves the relative IRI reference <code>$relative</code>
            against the base IRI <code>$base</code> using the algorithm defined in <bibref
               ref="rfc3986"/>, adapted by treating any <termref def="character">character</termref>
            that would not be valid in an RFC3986 URI or relative reference in the same way that
            RFC3986 treats unreserved characters. No percent-encoding takes place.</p>



      </fos:rules>
      <fos:errors>
         <p>The first form of this function resolves <code>$relative</code> against the value of the
            base-uri property from the static context. A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="NS"
               code="0005"/> if the base-uri property is not initialized in the static context. </p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RG" code="0002"/> if <code>$relative</code> is not a
            valid IRI according to the rules of RFC3987, extended with an implementation-defined
            subset of the extensions permitted in LEIRI, or if it is not a suitable relative
            reference to use as input to the RFC3986 resolution algorithm extended to handle
            additional unreserved characters. </p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RG" code="0002"/> if <code>$base</code> is not a
            valid IRI according to the rules of RFC3987, extended with an implementation-defined
            subset of the extensions permitted in LEIRI, or if it is not a suitable IRI to use as
            input to the chosen resolution algorithm (for example, if it is a relative IRI
            reference, if it is a non-hierarchic URI, or if it contains a fragment identifier). </p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RG" code="0009"/> if the chosen resolution algorithm
            fails for any other reason. </p>
      </fos:errors>
      <fos:notes>
         <p>Resolving a URI does not dereference it. This is merely a syntactic operation on two
               <termref def="string">strings</termref>.</p>
         <p>The algorithms in the cited RFCs include some variations that are optional or
            recommended rather than mandatory; they also describe some common practices that are not
            recommended, but which are permitted for backwards compatibility. Where the cited RFCs
            permit variations in behavior, so does this specification. </p>
         <p>Throughout this family of specifications, the phrase "resolving a relative URI (or IRI)
            reference" should be understood as using the rules of this function, unless otherwise
            stated.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="true" prefix="fn">
      <fos:signatures>
         <fos:proto name="true" return-type="xs:boolean"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the <code>xs:boolean</code> value <code>true</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The result is equivalent to <code>xs:boolean("1")</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:true()</fos:expression>
               <fos:result>xs:boolean(1)</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="false" prefix="fn">
      <fos:signatures>
         <fos:proto name="false" return-type="xs:boolean"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the <code>xs:boolean</code> value <code>false</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The result is equivalent to <code>xs:boolean("0")</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:false()</fos:expression>
               <fos:result>xs:boolean(0)</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="boolean-equal" prefix="op">
      <fos:signatures>
         <fos:proto name="boolean-equal" return-type="xs:boolean">
            <fos:arg name="value1" type="xs:boolean"/>
            <fos:arg name="value2" type="xs:boolean"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:boolean numeric">Defines the semantics of the "eq"
         operator on <code>xs:boolean</code> values.</fos:opermap>
      <fos:summary>
         <p>Returns <code>true</code> if the two arguments are the same boolean value.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns <code>true</code> if both arguments are <code>true</code> or if
            both arguments are <code>false</code>. It returns <code>false</code> if one of the
            arguments is <code>true</code> and the other argument is <code>false</code>. </p>
      </fos:rules>
   </fos:function>
   <fos:function name="boolean-less-than" prefix="op">
      <fos:signatures>
         <fos:proto name="boolean-less-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:boolean"/>
            <fos:arg name="arg2" type="xs:boolean"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="lt" types="xs:boolean numeric" other-operators="ge">Defines the
         semantics of the "lt" operator on <code>xs:boolean</code> values. Also used in the
         definition of the "ge" operator.</fos:opermap>
      <fos:summary>
         <p>Returns true if the first argument is false and the second is true.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns <code>true</code> if <code>$arg1</code> is <code>false</code> and
               <code>$arg2</code> is <code>true</code>. Otherwise, it returns
            <code>false</code>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="boolean-greater-than" prefix="op">
      <fos:signatures>
         <fos:proto name="boolean-greater-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:boolean"/>
            <fos:arg name="arg2" type="xs:boolean"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="gt" types="xs:boolean numeric" other-operators="le">Defines the
         semantics of the "gt" operator on <code>xs:boolean</code> values. Also used in the
         definition of the "le" operator.</fos:opermap>
      <fos:summary>
         <p>Returns true if the first argument is true and the second is false.</p>
      </fos:summary>
      <fos:rules>
         <p>The function call <code>op:boolean-greater-than($A, $B)</code> is defined to return the
            same result as <code>op:boolean-less-than($B, $A)</code></p>
      </fos:rules>
   </fos:function>
   <fos:function name="boolean" prefix="fn">
      <fos:signatures>
         <fos:proto name="boolean" return-type="xs:boolean">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:summary>
         <p>Computes the effective boolean value of the sequence <code>$arg</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The function computes the effective boolean value of a sequence, defined according to
            the following rules. See also <xspecref spec="XP30" ref="id-ebv"/>.</p>
         <ulist>
            <item>
               <p>If <code>$arg</code> is the empty sequence, <code>fn:boolean</code> returns
                     <code>false</code>.</p>
            </item>
            <item>
               <p>If <code>$arg</code> is a sequence whose first item is a node,
                     <code>fn:boolean</code> returns <code>true</code>.</p>
            </item>
            <item>
               <p>If <code>$arg</code> is a singleton value of type <code>xs:boolean</code> or a
                  derived from <code>xs:boolean</code>, <code>fn:boolean</code> returns
                     <code>$arg</code>.</p>
            </item>
            <item>
               <p>If <code>$arg</code> is a singleton value of type <code>xs:string</code> or a type
                  derived from <code>xs:string</code>, <code>xs:anyURI</code> or a type derived from
                     <code>xs:anyURI</code> or <code>xs:untypedAtomic</code>,
                     <code>fn:boolean</code> returns <code>false</code> if the operand value has
                  zero length; otherwise it returns <code>true</code>.</p>
            </item>
            <item>
               <p>If <code>$arg</code> is a singleton value of any numeric type or a type derived
                  from a numeric type, <code>fn:boolean</code> returns <code>false</code> if the
                  operand value is <code>NaN</code> or is numerically equal to zero; otherwise it
                  returns <code>true</code>.</p>
            </item>
            <item>
               <p>In all other cases, <code>fn:boolean</code> raises a type error <errorref
                     class="RG" code="0006"/>.</p>
            </item>
         </ulist>
         <p diff="del" at="F">The static semantics of this function are described in [Formal
            Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>The result of this function is not necessarily the same as <code>$arg cast as
               xs:boolean</code>. For example, <code>fn:boolean("false")</code> returns the value
               <code>true</code> whereas <code>"false" cast as xs:boolean</code> (which can also be
            written <code>xs:boolean("false")</code>) returns <code>false</code>.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="abc" select="(&quot;a&quot;, &quot;b&quot;, &quot;&quot;)"/>
         <fos:example>
            <p><code>fn:boolean($abc)</code> raises a type error <errorref class="RG" code="0006"
               />.</p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:boolean($abc[1])</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:boolean($abc[0])</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:boolean($abc[3])</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="not" prefix="fn">
      <fos:signatures>
         <fos:proto name="not" return-type="xs:boolean">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns <code>true</code> if the effective boolean value of <code>$arg</code>
            is <code>false</code>, or <code>false</code> if it is <code>true</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The value of <code>$arg</code> is first reduced to an effective boolean value by
            applying the <code>fn:boolean()</code> function. The function returns <code>true</code>
            if the effective boolean value is <code>false</code>, or <code>false</code> if the
            effective boolean value is <code>true</code>. </p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:not(fn:true())</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:not("false")</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="yearMonthDuration-less-than" prefix="op">
      <fos:signatures>
         <fos:proto name="yearMonthDuration-less-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:yearMonthDuration"/>
            <fos:arg name="arg2" type="xs:yearMonthDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="lt" types="xs:yearMonthDuration numeric" other-operators="ge">Defines
         the semantics of the "lt" operator on <code>xs:yearMonthDuration</code> values. Also used
         in the definition of the "ge" operator.</fos:opermap>
      <fos:summary>
         <p>Returns true if <code>$arg1</code> is a shorter duration than
               <code>$arg2</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If the number of months in the value of <code>$arg1</code> is numerically less than the
            number of months in the value of <code>$arg2</code>, the function returns true.</p>
         <p>Otherwise, the function returns false.</p>
      </fos:rules>
      <fos:notes>
         <p>Either or both durations may be negative</p>
      </fos:notes>
   </fos:function>
   <fos:function name="yearMonthDuration-greater-than" prefix="op">
      <fos:signatures>
         <fos:proto name="yearMonthDuration-greater-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:yearMonthDuration"/>
            <fos:arg name="arg2" type="xs:yearMonthDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="gt" types="xs:yearMonthDuration numeric" other-operators="le">Defines
         the semantics of the "gt" operator on <code>xs:yearMonthDuration</code> values. Also used
         in the definition of the "le" operator.</fos:opermap>
      <fos:summary>
         <p>Returns true if <code>$arg1</code> is a longer duration than
            <code>$arg2</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The function call <code>op:yearMonthDuration-greater-than($A, $B)</code> is defined to
            return the same result as <code>op:yearMonthDuration-less-than($B, $A)</code></p>
      </fos:rules>
   </fos:function>
   <fos:function name="dayTimeDuration-less-than" prefix="op">
      <fos:signatures>
         <fos:proto name="dayTimeDuration-less-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:dayTimeDuration"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="lt" types="xs:dayTimeDuration numeric" other-operators="ge">Defines the
         semantics of the "lt" operator on <code>xs:dayTimeDuration</code> values. Also used in the
         definition of the "ge" operator.</fos:opermap>
      <fos:summary>
         <p>Returns true if <code>$arg1</code> is a shorter duration than
               <code>$arg2</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If the number of seconds in the value of <code>$arg1</code> is numerically less than the
            number of seconds in the value of <code>$arg2</code>, the function returns true.</p>
         <p>Otherwise, the function returns false.</p>
      </fos:rules>
      <fos:notes>
         <p>Either or both durations may be negative</p>
      </fos:notes>
   </fos:function>
   <fos:function name="dayTimeDuration-greater-than" prefix="op">
      <fos:signatures>
         <fos:proto name="dayTimeDuration-greater-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:dayTimeDuration"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="gt" types="xs:dayTimeDuration numeric" other-operators="le">Defines the
         semantics of the "gt" operator on <code>xs:dayTimeDuration</code> values. Also used in the
         definition of the "le" operator.</fos:opermap>
      <fos:summary>
         <p>Returns true if <code>$arg1</code> is a longer duration than
            <code>$arg2</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The function call <code>op:dayTimeDuration-greater-than($A, $B)</code> is defined to
            return the same result as <code>op:dayTimeDuration-less-than($B, $A)</code></p>
      </fos:rules>
   </fos:function>
   <fos:function name="duration-equal" prefix="op">
      <fos:signatures>
         <fos:proto name="duration-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:duration"/>
            <fos:arg name="arg2" type="xs:duration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:duration numeric" other-operators="ne">Defines the
         semantics of the "eq" operators on <code>xs:duration</code> values. Also used in the
         definition of the "ne" operator.</fos:opermap>
      <fos:summary>
         <p>Returns true if <code>$arg1</code> and <code>$arg2</code> are durations of the
            same length.</p>
      </fos:summary>
      <fos:rules>
         <p>If the <code>xs:yearMonthDuration</code> components of <code>$arg1</code> and
               <code>$arg2</code> are equal and the <code>xs:dayTimeDuration</code> components of
               <code>$arg1</code> and <code>$arg2</code> are equal, the function returns
               <code>true</code>.</p>
         <p>Otherwise, the function returns false.</p>
         <p>The semantics of this function are:</p>
         <eg xml:space="preserve">
xs:yearMonthDuration($arg1) div xs:yearMonthDuration('P1M')  eq
xs:yearMonthDuration($arg2) div xs:yearMonthDuration('P1M')
    and
xs:dayTimeDuration($arg1) div xs:dayTimeDuration('PT1S')  eq
xs:dayTimeDuration($arg2) div xs:dayTimeDuration('PT1S')
</eg>
         <p>that is, the function returns <code>true</code> if the months and seconds values of the
            two durations are equal.</p>
      </fos:rules>
      <fos:notes>
         <p>Note that this function, like any other, may be applied to arguments that are derived
            from the types given in the function signature, including the two subtypes
               <code>xs:dayTimeDuration</code> and <code>xs:yearMonthDuration</code>. With the
            exception of the zero-length duration, no instance of <code>xs:dayTimeDuration</code>
            can ever be equal to an instance of <code>xs:yearMonthDuration</code>.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:duration-equal(xs:duration("P1Y"),
                  xs:duration("P12M"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:duration-equal(xs:duration("PT24H"),
                  xs:duration("P1D"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:duration-equal(xs:duration("P1Y"),
                  xs:duration("P365D"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:duration-equal(xs:yearMonthDuration("P0Y"),
                  xs:dayTimeDuration("P0D"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:duration-equal(xs:yearMonthDuration("P1Y"),
                  xs:dayTimeDuration("P365D"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:duration-equal(xs:yearMonthDuration("P2Y"),
                  xs:yearMonthDuration("P24M"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:duration-equal(xs:dayTimeDuration("P10D"),
                  xs:dayTimeDuration("PT240H"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:duration-equal(xs:duration("P2Y0M0DT0H0M0S"),
                  xs:yearMonthDuration("P24M"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:duration-equal(xs:duration("P0Y0M10D"),
                  xs:dayTimeDuration("PT240H"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="years-from-duration" prefix="fn">
      <fos:signatures>
         <fos:proto name="years-from-duration" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:duration?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the number of years in a duration.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> representing the years
            component in the value of <code>$arg</code>. The result is obtained by casting
               <code>$arg</code> to an <code>xs:yearMonthDuration</code> (see <specref
               ref="casting-to-durations"/>) and then computing the years component as described in
               <specref ref="canonical-yearMonthDuration"/>.</p>
         <p>If <code>$arg</code> is a negative duration then the result will be negative..</p>
         <p>If <code>$arg</code> is an <code>xs:dayTimeDuration</code> the function returns 0.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:years-from-duration(xs:yearMonthDuration("P20Y15M"))</fos:expression>
               <fos:result>21</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:years-from-duration(xs:yearMonthDuration("-P15M"))</fos:expression>
               <fos:result>-1</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:years-from-duration(xs:dayTimeDuration("-P2DT15H"))</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="months-from-duration" prefix="fn">
      <fos:signatures>
         <fos:proto name="months-from-duration" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:duration?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the number of months in a duration.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> representing the months
            component in the value of <code>$arg</code>. The result is obtained by casting
               <code>$arg</code> to an <code>xs:yearMonthDuration</code> (see <specref
               ref="casting-to-durations"/>) and then computing the months component as described in
               <specref ref="canonical-yearMonthDuration"/>.</p>
         <p>If <code>$arg</code> is a negative duration then the result will be negative..</p>
         <p>If <code>$arg</code> is an <code>xs:dayTimeDuration</code> the function returns 0.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:months-from-duration(xs:yearMonthDuration("P20Y15M"))</fos:expression>
               <fos:result>3</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:months-from-duration(xs:yearMonthDuration("-P20Y18M"))</fos:expression>
               <fos:result>-6</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:months-from-duration(xs:dayTimeDuration("-P2DT15H0M0S"))</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="days-from-duration" prefix="fn">
      <fos:signatures>
         <fos:proto name="days-from-duration" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:duration?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the number of days in a duration.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> representing the days
            component in the value of <code>$arg</code>. The result is obtained by casting
               <code>$arg</code> to an <code>xs:dayTimeDuration</code> (see <specref
               ref="casting-to-durations"/>) and then computing the days component as described in
               <specref ref="canonical-dayTimeDuration"/>.</p>
         <p>If <code>$arg</code> is a negative duration then the result will be negative..</p>
         <p>If <code>$arg</code> is an <code>xs:yearMonthDuration</code> the function returns 0.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:days-from-duration(xs:dayTimeDuration("P3DT10H"))</fos:expression>
               <fos:result>3</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:days-from-duration(xs:dayTimeDuration("P3DT55H"))</fos:expression>
               <fos:result>5</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:days-from-duration(xs:yearMonthDuration("P3Y5M"))</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="hours-from-duration" prefix="fn">
      <fos:signatures>
         <fos:proto name="hours-from-duration" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:duration?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the number of hours in a duration.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> representing the hours
            component in the value of <code>$arg</code>. The result is obtained by casting
               <code>$arg</code> to an <code>xs:dayTimeDuration</code> (see <specref
               ref="casting-to-durations"/>) and then computing the hours component as described in
               <specref ref="canonical-dayTimeDuration"/>.</p>
         <p>If <code>$arg</code> is a negative duration then the result will be negative..</p>
         <p>If <code>$arg</code> is an <code>xs:yearMonthDuration</code> the function returns 0.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-duration(xs:dayTimeDuration("P3DT10H"))</fos:expression>
               <fos:result>10</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-duration(xs:dayTimeDuration("P3DT12H32M12S"))</fos:expression>
               <fos:result>12</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-duration(xs:dayTimeDuration("PT123H"))</fos:expression>
               <fos:result>3</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-duration(xs:dayTimeDuration("-P3DT10H"))</fos:expression>
               <fos:result>-10</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="minutes-from-duration" prefix="fn">
      <fos:signatures>
         <fos:proto name="minutes-from-duration" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:duration?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the number of minutes in a duration.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> representing the minutes
            component in the value of <code>$arg</code>. The result is obtained by casting
               <code>$arg</code> to an <code>xs:dayTimeDuration</code> (see <specref
               ref="casting-to-durations"/>) and then computing the minutes component as described
            in <specref ref="canonical-dayTimeDuration"/>.</p>
         <p>If <code>$arg</code> is a negative duration then the result will be negative..</p>
         <p>If <code>$arg</code> is an <code>xs:yearMonthDuration</code> the function returns 0.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:minutes-from-duration(xs:dayTimeDuration("P3DT10H"))</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:minutes-from-duration(xs:dayTimeDuration("-P5DT12H30M"))</fos:expression>
               <fos:result>-30</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="seconds-from-duration" prefix="fn">
      <fos:signatures>
         <fos:proto name="seconds-from-duration" return-type="xs:decimal?">
            <fos:arg name="arg" type="xs:duration?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the number of seconds in a duration.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:decimal</code> representing the seconds
            component in the value of <code>$arg</code>. The result is obtained by casting
               <code>$arg</code> to an <code>xs:dayTimeDuration</code> (see <specref
               ref="casting-to-durations"/>) and then computing the seconds component as described
            in <specref ref="canonical-dayTimeDuration"/>.</p>
         <p>If <code>$arg</code> is a negative duration then the result will be negative..</p>
         <p>If <code>$arg</code> is an <code>xs:yearMonthDuration</code> the function returns 0.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:seconds-from-duration(xs:dayTimeDuration("P3DT10H12.5S"))</fos:expression>
               <fos:result>12.5</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:seconds-from-duration(xs:dayTimeDuration("-PT256S"))</fos:expression>
               <fos:result>-16.0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="add-yearMonthDurations" prefix="op">
      <fos:signatures>
         <fos:proto name="add-yearMonthDurations" return-type="xs:yearMonthDuration">
            <fos:arg name="arg1" type="xs:yearMonthDuration"/>
            <fos:arg name="arg2" type="xs:yearMonthDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="+" types="xs:yearMonthDuration numeric">Defines the semantics of the
         "+" operator on <code>xs:yearMonthDuration</code> values.</fos:opermap>
      <fos:summary>
         <p>Returns the result of adding two <code>xs:yearMonthDuration</code> values. </p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of adding the value of <code>$arg1</code> to the value
            of <code>$arg2</code>. The result will be an <code>xs:yearMonthDuration</code> whose
            length in months is equal to the length in months of <code>$arg1</code> plus the length
            in months of <code>$arg2</code>.</p>
         <p>For handling of overflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>Either duration (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:add-yearMonthDurations(xs:yearMonthDuration("P2Y11M"),
                  xs:yearMonthDuration("P3Y3M"))</fos:expression>
               <fos:result>xs:yearMonthDuration("P6Y2M")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-yearMonthDurations" prefix="op">
      <fos:signatures>
         <fos:proto name="subtract-yearMonthDurations" return-type="xs:yearMonthDuration">
            <fos:arg name="arg1" type="xs:yearMonthDuration"/>
            <fos:arg name="arg2" type="xs:yearMonthDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:yearMonthDuration numeric">Defines the semantics of the
         "-" operator on <code>xs:yearMonthDuration</code> values.</fos:opermap>
      <fos:summary>
         <p>Returns the result of subtracting one <code>xs:yearMonthDuration</code> value
            from another. </p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of subtracting the value of <code>$arg2</code> from the
            value of <code>$arg1</code>. The result will be an <code>xs:yearMonthDuration</code>
            whose length in months is equal to the length in months of <code>$arg1</code> minus the
            length in months of <code>$arg2</code>.</p>
         <p>For handling of overflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>Either duration (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-yearMonthDurations(xs:yearMonthDuration("P2Y11M"),
                  xs:yearMonthDuration("P3Y3M"))</fos:expression>
               <fos:result>xs:yearMonthDuration("-P4M")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="multiply-yearMonthDuration" prefix="op">
      <fos:signatures>
         <fos:proto name="multiply-yearMonthDuration" return-type="xs:yearMonthDuration">
            <fos:arg name="arg1" type="xs:yearMonthDuration"/>
            <fos:arg name="arg2" type="xs:double"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="*" types="xs:yearMonthDuration numeric">Defines the semantics of the
         "*" operator on <code>xs:yearMonthDuration</code> values.</fos:opermap>
      <fos:summary>
         <p diff="chg" at="A-E12">Returns the result of multiplying the value of
               <code>$arg1</code> by <code>$arg2</code>. The result is rounded to the nearest
            month.</p>
      </fos:summary>
      <fos:rules>
         <p diff="chg" at="A-E12">The result is the <code>xs:yearMonthDuration</code> whose length
            in months is equal to the result of applying the <code>fn:round</code> function to the
            value obtained by multiplying the length in months of <code>$arg1</code> by the value of
               <code>$arg2</code>.</p>
         <p>If <code>$arg2</code> is positive or negative zero, the result is a zero-length
            duration. If <code>$arg2</code> is positive or negative infinity, the result overflows
            and is handled as discussed in <specref ref="duration-limits"/>. </p>
         <p>For handling of overflow and underflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="CA" code="0005"/> if <code>$arg2</code> is
               <code>NaN</code>.</p>
      </fos:errors>
      <fos:notes>
         <p>Either duration (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:multiply-yearMonthDuration(xs:yearMonthDuration("P2Y11M"),
                  2.3)</fos:expression>
               <fos:result>xs:yearMonthDuration("P6Y9M")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="divide-yearMonthDuration" prefix="op">
      <fos:signatures>
         <fos:proto name="divide-yearMonthDuration" return-type="xs:yearMonthDuration">
            <fos:arg name="arg1" type="xs:yearMonthDuration"/>
            <fos:arg name="arg2" type="xs:double"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="div" types="xs:yearMonthDuration numeric">Defines the semantics of the
         "div" operator on <code>xs:yearMonthDuration</code> and numeric values.</fos:opermap>
      <fos:summary>
         <p diff="chg" at="A-E12">Returns the result of dividing the value of
               <code>$arg1</code> by <code>$arg2</code>. The result is rounded to the nearest
            month.</p>
      </fos:summary>
      <fos:rules>
         <p diff="chg" at="A-E12">The result is the <code>xs:yearMonthDuration</code> whose length
            in months is equal to the result of applying the <code>fn:round</code> function to the
            value obtained by dividing the length in months of <code>$arg1</code> by the value of
               <code>$arg2</code>.</p>
         <p>If <code>$arg2</code> is positive or negative infinity, the result is a zero-length
            duration. If <code>$arg2</code> is positive or negative zero, the result overflows and
            is handled as discussed in <specref ref="duration-limits"/>. </p>
         <p>For handling of overflow and underflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="CA" code="0005"/> if <code>$arg2</code> is
               <code>NaN</code>.</p>
      </fos:errors>
      <fos:notes>
         <p>Either operand (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:divide-yearMonthDuration(xs:yearMonthDuration("P2Y11M"),
                  1.5)</fos:expression>
               <fos:result>xs:yearMonthDuration("P1Y11M")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="divide-yearMonthDuration-by-yearMonthDuration" prefix="op">
      <fos:signatures>
         <fos:proto name="divide-yearMonthDuration-by-yearMonthDuration" return-type="xs:decimal">
            <fos:arg name="arg1" type="xs:yearMonthDuration"/>
            <fos:arg name="arg2" type="xs:yearMonthDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="div" types="xs:yearMonthDuration numeric">Defines the semantics of the
         "div" operator on <code>xs:yearMonthDuration</code> values.</fos:opermap>
      <fos:summary>
         <p>Returns the ratio of two <code>xs:yearMonthDuration</code> values.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of dividing the length in months of <code>$arg1</code>
            by the length in months of <code>$arg2</code>, according to the rules of the
               <code>op:numeric-divide</code> function for integer operands.</p>
         <p>For handling of overflow and underflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>Either duration (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:divide-yearMonthDuration-by-yearMonthDuration(xs:yearMonthDuration("P3Y4M"),
                  xs:yearMonthDuration("-P1Y4M"))</fos:expression>
               <fos:result>-2.5</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p>The following example demonstrates how to calculate the length of an
                  <code>xs:yearMonthDuration</code> value in months:</p>
            <fos:test>
               <fos:expression>op:divide-yearMonthDuration-by-yearMonthDuration(xs:yearMonthDuration("P3Y4M"),
                  xs:yearMonthDuration("P1M"))</fos:expression>
               <fos:result>40</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="add-dayTimeDurations" prefix="op">
      <fos:signatures>
         <fos:proto name="add-dayTimeDurations" return-type="xs:dayTimeDuration">
            <fos:arg name="arg1" type="xs:dayTimeDuration"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="+" types="xs:dayTimeDuration numeric">Defines the semantics of the "+"
         operator on <code>xs:dayTimeDuration</code> values.</fos:opermap>
      <fos:summary>
         <p>Returns the sum of two <code>xs:dayTimeDuration</code> values.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of adding the value of <code>$arg1</code> to the value
            of <code>$arg2</code>. The result is the <code>xs:dayTimeDuration</code> whose length in
            seconds is equal to the sum of the length in seconds of the two input durations.</p>
         <p>For handling of overflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>Either duration (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:add-dayTimeDurations(xs:dayTimeDuration("P2DT12H5M"),
                  xs:dayTimeDuration("P5DT12H"))</fos:expression>
               <fos:result>xs:dayTimeDuration('P8DT5M')</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-dayTimeDurations" prefix="op">
      <fos:signatures>
         <fos:proto name="subtract-dayTimeDurations" return-type="xs:dayTimeDuration">
            <fos:arg name="arg1" type="xs:dayTimeDuration"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:dayTimeDuration numeric">Defines the semantics of the "-"
         operator on <code>xs:dayTimeDuration</code> values.</fos:opermap>
      <fos:summary>
         <p>Returns the result of subtracting one <code>xs:dayTimeDuration</code> from
            another.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of subtracting the value of <code>$arg2</code> from the
            value of <code>$arg1</code>. The result is the <code>xs:dayTimeDuration</code> whose
            length in seconds is equal to the length in seconds of <code>$arg1</code> minus the
            length in seconds of <code>$arg2</code>.</p>
         <p>For handling of overflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>Either duration (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-dayTimeDurations(xs:dayTimeDuration("P2DT12H"),
                  xs:dayTimeDuration("P1DT10H30M"))</fos:expression>
               <fos:result>xs:dayTimeDuration('P1DT1H30M')</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="multiply-dayTimeDuration" prefix="op">
      <fos:signatures>
         <fos:proto name="multiply-dayTimeDuration" return-type="xs:dayTimeDuration">
            <fos:arg name="arg1" type="xs:dayTimeDuration"/>
            <fos:arg name="arg2" type="xs:double"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="*" types="xs:dayTimeDuration numeric">Defines the semantics of the "*"
         operator on <code>xs:dayTimeDuration</code> and numeric values.</fos:opermap>
      <fos:summary>
         <p>Returns the result of multiplying a <code>xs:dayTimeDuration</code> by a
            number.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of multiplying the value of <code>$arg1</code> by
               <code>$arg2</code>. The result is the <code>xs:dayTimeDuration</code> whose length in
            seconds is equal to the length in seconds of <code>$arg1</code> multiplied by the
            numeric value <code>$arg2</code>.</p>
         <!--<ednote>
            <edtext>We ought to say whether the calculation is performed using double or decimal
               arithmetic.</edtext>
         </ednote>-->
         <p>If <code>$arg2</code> is positive or negative zero, the result is a zero-length
            duration. If <code>$arg2</code> is positive or negative infinity, the result overflows
            and is handled as discussed in <specref ref="date-time-duration-conformance"/>. </p>
         <p>For handling of overflow and underflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="CA" code="0005"/> if <code>$arg2</code> is
               <code>NaN</code>.</p>
      </fos:errors>
      <fos:notes>
         <p>Either operand (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:multiply-dayTimeDuration(xs:dayTimeDuration("PT2H10M"),
                  2.1)</fos:expression>
               <fos:result>xs:dayTimeDuration('PT4H33M')</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="divide-dayTimeDuration" prefix="op">
      <fos:signatures>
         <fos:proto name="divide-dayTimeDuration" return-type="xs:dayTimeDuration">
            <fos:arg name="arg1" type="xs:dayTimeDuration"/>
            <fos:arg name="arg2" type="xs:double"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="div" types="xs:dayTimeDuration numeric">Defines the semantics of the
         "div" operator on <code>xs:dayTimeDuration</code> values.</fos:opermap>
      <fos:summary>
         <p>Returns the result of multiplying a <code>xs:dayTimeDuration</code> by a
            number.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of dividing the value of <code>$arg1</code> by
               <code>$arg2</code>. The result is the <code>xs:dayTimeDuration</code> whose length in
            seconds is equal to the length in seconds of <code>$arg1</code> divided by the numeric
            value <code>$arg2</code>.</p>
         <p>If <code>$arg2</code> is positive or negative infinity, the result is a zero-length
            duration. If <code>$arg2</code> is positive or negative zero, the result overflows and
            is handled as discussed in <specref ref="date-time-duration-conformance"/>. </p>
         <!--<ednote>
            <edtext>We ought to say whether the calculation is performed using double or decimal
               arithmetic.</edtext>
         </ednote>-->
         <p>For handling of overflow and underflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="CA" code="0005"/> if <code>$arg2</code> is
               <code>NaN</code>.</p>
      </fos:errors>
      <fos:notes>
         <p>Either operand (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:divide-dayTimeDuration(xs:dayTimeDuration("P1DT2H30M10.5S"),
                  1.5)</fos:expression>
               <fos:result>xs:duration("PT17H40M7S")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="divide-dayTimeDuration-by-dayTimeDuration" prefix="op">
      <fos:signatures>
         <fos:proto name="divide-dayTimeDuration-by-dayTimeDuration" return-type="xs:decimal">
            <fos:arg name="arg1" type="xs:dayTimeDuration"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="div" types="xs:dayTimeDuration numeric">Defines the semantics of the
         "div" operator on <code>xs:dayTimeDuration</code> values.</fos:opermap>
      <fos:summary>
         <p>Returns the ratio of two <code>xs:dayTimeDuration</code> values, as a decimal
            number.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of dividing the value of <code>$arg1</code> by
               <code>$arg2</code>. The result is the <code>xs:dayTimeDuration</code> whose length in
            seconds is equal to the length in seconds of <code>$arg1</code> divided by the length in
            seconds of <code>$arg2</code>. The calculation is performed by applying
               <code>op:numeric-divide</code> to the two <code>xs:decimal</code> operands.</p>
         <p>For handling of overflow and underflow, see <specref ref="duration-limits"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>Either operand (and therefore the result) may be negative.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:round-half-to-even( op:divide-dayTimeDuration-by-dayTimeDuration(
                  xs:dayTimeDuration("P2DT53M11S"), xs:dayTimeDuration("P1DT10H")),
                  4)</fos:expression>
               <fos:result>1.4378</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p>This examples shows how to determine the number of seconds in a duration.</p>
            <fos:test>
               <fos:expression>op:divide-dayTimeDuration-by-dayTimeDuration(xs:dayTimeDuration("P2DT53M11S"),
                  xs:dayTimeDuration("PT1S"))</fos:expression>
               <fos:result>175991.0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="dateTime" prefix="fn">
      <fos:signatures>
         <fos:proto name="dateTime" return-type="xs:dateTime?">
            <fos:arg name="arg1" type="xs:date?"/>
            <fos:arg name="arg2" type="xs:time?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns an <code>xs:dateTime</code> value created by combining an
               <code>xs:date</code> and an <code>xs:time</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If either <code>$arg1</code> or <code>$arg2</code> is the empty sequence the function
            returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:dateTime</code> whose date component is
            equal to <code>$arg1</code> and whose time component is equal to <code>$arg2</code>.</p>
         <p>The timezone of the result is computed as follows:</p>
         <ulist>
            <item>
               <p>If neither argument has a timezone, the result has no timezone.</p>
            </item>
            <item>
               <p>If exactly one of the arguments has a timezone, or if both arguments have the same
                  timezone, the result has this timezone.</p>
            </item>
         </ulist>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RG" code="0008"/> if the two arguments both have
            timezones and the timezones are different. </p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:dateTime(xs:date("1999-12-31"),
                  xs:time("12:00:00"))</fos:expression>
               <fos:result>xs:dateTime("1999-12-31T12:00:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:dateTime(xs:date("1999-12-31"),
                  xs:time("24:00:00"))</fos:expression>
               <fos:result>xs:dateTime("1999-12-31T00:00:00")</fos:result>
               <fos:postamble>This is because <code>"24:00:00"</code> is an alternate lexical form
                  for <code>"00:00:00"</code></fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="dateTime-equal" prefix="op">
      <fos:signatures>
         <fos:proto name="dateTime-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:dateTime"/>
            <fos:arg name="arg2" type="xs:dateTime"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:dateTime numeric" other-operators="ne le ge">Defines the
         semantics of the "eq" operator on <code>xs:dateTime</code> values. Also used in the
         definition of the "ne", "le" and "ge" operators.</fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns true if the two supplied <code>xs:dateTime</code> values refer to the
            same instant in time.</p>
      </fos:summary>
      <fos:rules>
         <p>If either <code>$arg1</code> or <code>$arg2</code> has no timezone component, the
            effective value of the argument is obtained by substituting the implicit timezone from
            the dynamic evaluation context.</p>
         <p>The function then returns <code>true</code> if and only if the effective value of
               <code>$arg1</code> is equal to the effective value of <code>$arg2</code> according to
            the algorithm defined in section 3.2.7.4 of <bibref ref="xmlschema-2"/>
            <quote>Order relation on dateTime</quote> for <code>xs:dateTime</code> values with
            timezones. Otherwise the function returns <code>false</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Assume that the dynamic context provides an implicit timezone value of
                  <code>-05:00</code></p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:dateTime-equal(xs:dateTime("2002-04-02T12:00:00-01:00"),
                  xs:dateTime("2002-04-02T17:00:00+04:00"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>op:dateTime-equal(xs:dateTime("2002-04-02T12:00:00"),
                  xs:dateTime("2002-04-02T23:00:00+06:00"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:dateTime-equal(xs:dateTime("2002-04-02T12:00:00"),
                  xs:dateTime("2002-04-02T17:00:00"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:dateTime-equal(xs:dateTime("2002-04-02T12:00:00"),
                  xs:dateTime("2002-04-02T12:00:00"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:dateTime-equal(xs:dateTime("2002-04-02T23:00:00-04:00"),
                  xs:dateTime("2002-04-03T02:00:00-01:00"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:dateTime-equal(xs:dateTime("1999-12-31T24:00:00"),
                  xs:dateTime("2000-01-01T00:00:00"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:dateTime-equal(xs:dateTime("2005-04-04T24:00:00"),
                  xs:dateTime("2005-04-04T00:00:00"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="dateTime-less-than" prefix="op">
      <fos:signatures>
         <fos:proto name="dateTime-less-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:dateTime"/>
            <fos:arg name="arg2" type="xs:dateTime"/>
         </fos:proto>
      </fos:signatures>
      
      <fos:opermap operator="lt" types="xs:dateTime numeric" other-operators="ge">Defines the
         semantics of the "lt" operator on <code>xs:dateTime</code> values. Also used in the
         definition of the <phrase diff="chg" at="L">"ge"</phrase> operator.</fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns <code>true</code> if the first argument represents an earlier instant
            in time than the second argument.</p>
      </fos:summary>
      <fos:rules>
         <p>If either <code>$arg1</code> or <code>$arg2</code> has no timezone component, the
            effective value of the argument is obtained by substituting the implicit timezone from
            the dynamic evaluation context.</p>
         <p>The function then returns <code>true</code> if and only if the effective value of
               <code>$arg1</code> is less than the effective value of <code>$arg2</code> according
            to the algorithm defined in section 3.2.7.4 of <bibref ref="xmlschema-2"/>
            <quote>Order relation on dateTime</quote> for <code>xs:dateTime</code> values with
            timezones. Otherwise the function returns <code>false</code>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="dateTime-greater-than" prefix="op">
      <fos:signatures>
         <fos:proto name="dateTime-greater-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:dateTime"/>
            <fos:arg name="arg2" type="xs:dateTime"/>
         </fos:proto>
      </fos:signatures>
      
      <fos:opermap operator="gt" types="xs:dateTime numeric" other-operators="le">Defines the
         semantics of the "gt" operator on <code>xs:dateTime</code> values. Also used in the
         definition of the <phrase diff="chg" at="L">"le"</phrase> operator.</fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns <code>true</code> if the first argument represents a later instant in
            time than the second argument.</p>
      </fos:summary>
      <fos:rules>
         <p>The function call <code>op:dateTime-greater-than($A, $B)</code> is defined to return the
            same result as <code>op:dateTime-less-than($B, $A)</code></p>
      </fos:rules>
   </fos:function>
   <fos:function name="date-equal" prefix="op">
      <fos:signatures>
         <fos:proto name="date-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:date"/>
            <fos:arg name="arg2" type="xs:date"/>
         </fos:proto>
      </fos:signatures>
      
      <fos:opermap operator="eq" types="xs:date numeric" other-operators="ne le ge">Defines the
         semantics of the "eq" operator on <code>xs:date</code> values. Also used in the definition
         of the "ne", "le" and "ge" operators.</fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns <code>true</code> if and only if the starting instants of the two
            supplied <code>xs:date</code> values are the same.</p>
      </fos:summary>
      <fos:rules>
         <p>The starting instant of an <code>xs:date</code> is the <code>xs:dateTime</code> at time
               <code>00:00:00</code> on that date.</p>
         <p>The function returns the result of the expression:</p>
         <eg xml:space="preserve">op:dateTime-equal(xs:dateTime($arg1), xs:dateTime($arg2))</eg>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:date-equal(xs:date("2004-12-25Z"),
                  xs:date("2004-12-25+07:00"))</fos:expression>
               <fos:result>false()</fos:result>
               <fos:postamble>The starting instants are
                     <code>xs:dateTime("2004-12-25T00:00:00Z")</code> and
                     <code>xs:dateTime("2004-12-25T00:00:00+07:00")</code>. These are normalized to
                     <code>xs:dateTime("2004-12-25T00:00:00Z")</code> and
                     <code>xs:dateTime("2004-12-24T17:00:00Z")</code>. </fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:date-equal(xs:date("2004-12-25-12:00"),
                  xs:date("2004-12-26+12:00"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="date-less-than" prefix="op">
      <fos:signatures>
         <fos:proto name="date-less-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:date"/>
            <fos:arg name="arg2" type="xs:date"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="lt" types="xs:date numeric" other-operators="ge">Defines the semantics
         of the "lt" operator on <code>xs:date</code> values. Also used in the definition of the
         <phrase diff="chg" at="L">"ge"</phrase> operator.</fos:opermap>
      <fos:summary>
         <p>Returns <code>true</code> if and only if the starting instant of
               <code>$arg1</code> is less than the starting instant of <code>$arg2</code>. Returns
               <code>false</code> otherwise.</p>
      </fos:summary>
      <fos:rules>
         <p>The starting instant of an <code>xs:date</code> is the <code>xs:dateTime</code> at time
               <code>00:00:00</code> on that date.</p>
         <p>The function returns the result of the expression:</p>
         <eg xml:space="preserve">op:dateTime-less-than(xs:dateTime($arg1), xs:dateTime($arg2))</eg>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:date-less-than(xs:date("2004-12-25Z"),
                  xs:date("2004-12-25-05:00"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:date-less-than(xs:date("2004-12-25-12:00"),
                  xs:date("2004-12-26+12:00"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="date-greater-than" prefix="op">
      <fos:signatures>
         <fos:proto name="date-greater-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:date"/>
            <fos:arg name="arg2" type="xs:date"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="gt" types="xs:date numeric" other-operators="le">Defines the semantics
         of the "gt" operator on <code>xs:date</code> values. Also used in the definition of the
         <phrase diff="chg" at="L">"le"</phrase> operator.</fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns <code>true</code> if and only if the starting instant of
               <code>$arg1</code> is greater than the starting instant of <code>$arg2</code>.
            Returns <code>false</code> otherwise.</p>
      </fos:summary>
      <fos:rules>
         <p>The function call <code>op:date-greater-than($A, $B)</code> is defined to return the
            same result as <code>op:date-less-than($B, $A)</code></p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:date-greater-than(xs:date("2004-12-25Z"),
                  xs:date("2004-12-25+07:00"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:date-greater-than(xs:date("2004-12-25-12:00"),
                  xs:date("2004-12-26+12:00"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="time-equal" prefix="op">
      <fos:signatures>
         <fos:proto name="time-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:time"/>
            <fos:arg name="arg2" type="xs:time"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:time numeric" other-operators="ne le ge">Defines the
         semantics of the "eq" operator on <code>xs:time</code> values. Also used in the definition
         of the "ne", "le" and "ge" operators.</fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns <code>true</code> if the two <code>xs:time</code> values represent the
            same instant in time, when treated as being times on the same date, before adjusting the
            timezone.</p>
      </fos:summary>
      <fos:rules>
         <p>Each of the supplied <code>xs:time</code> values is expanded to an
               <code>xs:dateTime</code> value by associating the time with an arbitrary date. The
            function returns the result of comparing these two <code>xs:dateTime</code> values using
               <code>op:dateTime-equal</code>.</p>
         <p>The result of the function is thus the same as the value of the expression:</p>
         <eg xml:space="preserve">op:dateTime-equal(
        fn:dateTime(xs:date('1972-12-31'), $arg1), 
        fn:dateTime(xs:date('1972-12-31'), $arg2))</eg>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Assume that the date components from the reference <code>xs:dateTime</code>
               correspond to <code>1972-12-31</code>.</p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:time-equal(xs:time("08:00:00+09:00"),
                  xs:time("17:00:00-06:00"))</fos:expression>
               <fos:result>false()</fos:result>
               <fos:postamble>The <code>xs:dateTime</code>s calculated using the reference date
                  components are <code>1972-12-31T08:00:00+09:00</code> and
                     <code>1972-12-31T17:00:00-06:00</code>. These normalize to
                     <code>1972-12-30T23:00:00Z</code> and <code diff="chg" at="L">1972-12-31T23:00:00Z</code>.
               </fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:time-equal(xs:time("21:30:00+10:30"),
                  xs:time("06:00:00-05:00"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:time-equal(xs:time("24:00:00+01:00"),
                  xs:time("00:00:00+01:00"))</fos:expression>
               <fos:result>true()</fos:result>
               <fos:postamble>This not the result one might expect. For <code>xs:dateTime</code>
                  values, a time of <code>24:00:00</code> is equivalent to <code>00:00:00</code> on
                  the following day. For <code>xs:time</code>, the normalization from
                     <code>24:00:00</code> to <code>00:00:00</code> happens before the
                     <code>xs:time</code> is converted into an <code>xs:dateTime</code> for the
                  purpose of the equality comparison. For <code>xs:time</code>, any operation on
                     <code>24:00:00</code> produces the same result as the same operation on
                     <code>00:00:00</code> because these are two different lexical representations
                  of the same value. </fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="time-less-than" prefix="op">
      <fos:signatures>
         <fos:proto name="time-less-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:time"/>
            <fos:arg name="arg2" type="xs:time"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="lt" types="xs:time numeric" other-operators="ge">Defines the semantics
         of the "lt" operator on <code>xs:time</code> values. Also used in the definition of the
         <phrase diff="chg" at="L">"ge"</phrase> operator.</fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns <code>true</code> if the first <code>xs:time</code> value represents an
            earlier instant in time than the second, when both are treated as being times on the
            same date, before adjusting the timezone.</p>
      </fos:summary>
      <fos:rules>
         <p>Each of the supplied <code>xs:time</code> values is expanded to an
               <code>xs:dateTime</code> value by associating the time with an arbitrary date. The
            function returns the result of comparing these two <code>xs:dateTime</code> values using
               <code>op:dateTime-less-than</code>.</p>
         <p>The result of the function is thus the same as the value of the expression:</p>
         <eg xml:space="preserve">op:dateTime-less-than(
        fn:dateTime(xs:date('1972-12-31'), $arg1), 
        fn:dateTime(xs:date('1972-12-31'), $arg2))</eg>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Assume that the dynamic context provides an implicit timezone value of
                  <code>-05:00</code>.</p>
         </fos:example>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>op:time-less-than(xs:time("12:00:00"),
                  xs:time("23:00:00+06:00"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:time-less-than(xs:time("11:00:00"),
                  xs:time("17:00:00Z"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:time-less-than(xs:time("23:59:59"),
                  xs:time("24:00:00"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="time-greater-than" prefix="op">
      <fos:signatures>
         <fos:proto name="time-greater-than" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:time"/>
            <fos:arg name="arg2" type="xs:time"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="gt" types="xs:time numeric" other-operators="le">Defines the semantics
         of the "gt" operator on <code>xs:time</code> values. Also used in the definition of the
         <phrase diff="chg" at="L">"le"</phrase> operator.</fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns <code>true</code> if the first <code>xs:time</code> value represents a
            later instant in time than the second, when both are treated as being times on the same
            date, before adjusting the timezone.</p>
      </fos:summary>
      <fos:rules>
         <p>The function call <code>op:time-greater-than($A, $B)</code> is defined to return the
            same result as <code>op:time-less-than($B, $A)</code></p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:time-greater-than(xs:time("08:00:00+09:00"),
                  xs:time("17:00:00-06:00"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="gYearMonth-equal" prefix="op">
      <fos:signatures>
         <fos:proto name="gYearMonth-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:gYearMonth"/>
            <fos:arg name="arg2" type="xs:gYearMonth"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:gYearMonth numeric" other-operators="ne">Defines the
         semantics of the "eq" operator on <code>xs:gYearMonth</code> values. Also used in the
         definition of the "ne" operator.</fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns true if the two <code>xs:gYearMonth</code> values have the same
            starting instant.</p>
      </fos:summary>
      <fos:rules>
         <p>The starting instants of <code>$arg1</code> and <code>$arg2</code> are calculated by
            supplying the missing components of <code>$arg1</code> and <code>$arg2</code> from the
               <code>xs:dateTime</code> template <code>xxxx-xx-01T00:00:00</code>. The function
            returns the result of comparing these two starting instants using
               <code>op:dateTime-equal</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Assume that the dynamic context provides an implicit timezone value of
                  <code>-05:00</code>.</p>
         </fos:example>
         <fos:example>
            <p><code>op:gYearMonth-equal(xs:gYearMonth("1986-02"), xs:gYearMonth("1986-03"))</code>
               returns <code>false()</code>. The starting instants are
                  <code>1986-02-01T00:00:00-05:00</code> and <code>1986-03-01T00:00:00</code>,
               respectively.</p>
         </fos:example>
         <fos:example>
            <p><code>op:gYearMonth-equal(xs:gYearMonth("1978-03"), xs:gYearMonth("1986-03Z"))</code>
               returns <code>false()</code>. The starting instants are
                  <code>1978-03-01T00:00:00-05:00</code> and <code>1986-03-01T00:00:00Z</code>,
               respectively.</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="gYear-equal" prefix="op">
      <fos:signatures>
         <fos:proto name="gYear-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:gYear"/>
            <fos:arg name="arg2" type="xs:gYear"/>
         </fos:proto>
      </fos:signatures>
      
      <fos:opermap operator="eq" types="xs:gYear numeric" other-operators="ne">Defines the semantics
         of the "eq" operator on <code>xs:gYear</code> values. Also used in the definition of the
         "ne" operator.</fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns true if the two <code>xs:gYear</code> values have the same starting
            instant.</p>
      </fos:summary>
      <fos:rules>
         <p>The starting instants of <code>$arg1</code> and <code>$arg2</code> are calculated by
            supplying the missing components of <code>$arg1</code> and <code>$arg2</code> from the
               <code>xs:dateTime</code> template <code>xxxx-01-01T00:00:00</code>. The function
            returns the result of comparing these two starting instants using
               <code>op:dateTime-equal</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Assume that the dynamic context provides an implicit timezone value of
                  <code>-05:00</code>. Assume, also, that the <code>xs:dateTime</code> template is
                  <code>xxxx-01-01T00:00:00</code>. </p>
         </fos:example>
         <fos:example>
            <p><code>op:gYear-equal(xs:gYear("2005-12:00"), xs:gYear("2005+12:00"))</code> returns
                  <code>false()</code>. The starting instants are
                  <code>2005-01-01T00:00:00-12:00</code> and <code>2005-01-01T00:00:00+12:00</code>,
               respectively, and normalize to <code>2005-01-01T12:00:00Z</code> and
                  <code>2004-12-31T12:00:00Z</code>.</p>
         </fos:example>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>op:gYear-equal(xs:gYear("1976-05:00"),
                  xs:gYear("1976"))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="gMonthDay-equal" prefix="op">
      <fos:signatures>
         <fos:proto name="gMonthDay-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:gMonthDay"/>
            <fos:arg name="arg2" type="xs:gMonthDay"/>
         </fos:proto>
      </fos:signatures>
      
      <fos:opermap operator="eq" types="xs:gMonthDay numeric" other-operators="ne">Defines the
         semantics of the "eq" operator on <code>xs:gMonthDay</code> values. Also used in the
         definition of the "ne" operator.</fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns true if the two <code>xs:gMonthDay</code> values have the same starting
            instant, when considered as days in the same year.</p>
      </fos:summary>
      <fos:rules>
         <p>The starting instants of <code>$arg1</code> and <code>$arg2</code> are calculated by
            supplying the missing components of <code>$arg1</code> and <code>$arg2</code> from the
               <code>xs:dateTime</code> template <code>1972-xx-xxT00:00:00</code> or an equivalent.
            The function returns the result of comparing these two starting instants using
               <code>op:dateTime-equal</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Assume that the dynamic context provides an implicit timezone value of
                  <code>-05:00</code>. Assume for the purposes of illustration that the
                  <code>xs:dateTime</code> template used is <code>1972-xx-xxT00:00:00</code> (this
               does not affect the result). </p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:gMonthDay-equal(xs:gMonthDay("--12-25-14:00"),
                  xs:gMonthDay("--12-26+10:00"))</fos:expression>
               <fos:result>true()</fos:result>
               <fos:postamble> The starting instants are <code>1972-12-25T00:00:00-14:00</code> and
                     <code>1972-12-26T00:00:00+10:00</code>, respectively, and normalize to
                     <code>1972-12-25T14:00:00Z</code> and <code>1972-12-25T14:00:00Z</code>.
               </fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:gMonthDay-equal(xs:gMonthDay("--12-25"),
                  xs:gMonthDay("--12-26Z"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="gMonth-equal" prefix="op">
      <fos:signatures>
         <fos:proto name="gMonth-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:gMonth"/>
            <fos:arg name="arg2" type="xs:gMonth"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:gMonth numeric" other-operators="ne">Defines the
         semantics of the "eq" operator on <code>xs:gMonth</code> values. Also used in the
         definition of the "ne" operator.</fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns true if the two <code>xs:gMonth</code> values have the same starting
            instant, when considered as months in the same year.</p>
      </fos:summary>
      <fos:rules>
         <p>The starting instants of <code>$arg1</code> and <code>$arg2</code> are calculated by
            supplying the missing components of <code>$arg1</code> and <code>$arg2</code> from the
               <code>xs:dateTime</code> template <code>1972-xx-01T00:00:00</code> or an equivalent.
            The function returns the result of comparing these two starting instants using
               <code>op:dateTime-equal</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Assume that the dynamic context provides an implicit timezone value of
                  <code>-05:00</code>. Assume, also, that the <code>xs:dateTime</code> template
               chosen is <code>1972-xx-01T00:00:00</code>. </p>
         </fos:example>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>op:gMonth-equal(xs:gMonth("--12-14:00"),
                  xs:gMonth("--12+10:00"))</fos:expression>
               <fos:result>false()</fos:result>
               <fos:postamble> The starting instants are <code>1972-12-01T00:00:00-14:00</code> and
                     <code>1972-12-01T00:00:00+10:00</code>, respectively, and normalize to
                     <code>1972-11-30T14:00:00Z</code> and <code>1972-12-01T14:00:00Z</code>.
               </fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>op:gMonth-equal(xs:gMonth("--12"),
                  xs:gMonth("--12Z"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="gDay-equal" prefix="op">
      <fos:signatures>
         <fos:proto name="gDay-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:gDay"/>
            <fos:arg name="arg2" type="xs:gDay"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:gDay numeric" other-operators="ne">Defines the semantics
         of the "eq" operator on <code>xs:gDay</code> values. Also used in the definition of the
         "ne" operator.</fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns true if the two <code>xs:gDay</code> values have the same starting
            instant, when considered as days in the same month of the same year.</p>
      </fos:summary>
      <fos:rules>
         <p>The starting instants of <code>$arg1</code> and <code>$arg2</code> are calculated by
            supplying the missing components of <code>$arg1</code> and <code>$arg2</code> from the
               <code>xs:dateTime</code> template <code>1972-12-xxT00:00:00</code> or an equivalent.
            The function returns the result of comparing these two starting instants using
               <code>op:dateTime-equal</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Assume that the dynamic context provides an implicit timezone value of
                  <code>-05:00</code>. Assume, also, that the <code>xs:dateTime</code> template is
                  <code>1972-12-xxT00:00:00</code>. </p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:gDay-equal(xs:gDay("---25-14:00"),
                  xs:gDay("---25+10:00"))</fos:expression>
               <fos:result>false()</fos:result>
               <fos:postamble> The starting instants are <code>1972-12-25T00:00:00-14:00</code> and
                     <code>1972-12-25T00:00:00+10:00</code>, respectively, and normalize to
                     <code>1972-12-25T14:00:00Z</code> and <code>1972-12-24T14:00:00Z</code>.
               </fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>op:gDay-equal(xs:gDay("---12"), xs:gDay("---12Z"))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="year-from-dateTime" prefix="fn">
      <fos:signatures>
         <fos:proto name="year-from-dateTime" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:dateTime?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the year component of an <code>xs:dateTime</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> representing the year
            component in the local value of <code>$arg</code>. The result may be negative.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:year-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</fos:expression>
               <fos:result>1999</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:year-from-dateTime(xs:dateTime("1999-05-31T21:30:00-05:00"))</fos:expression>
               <fos:result>1999</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:year-from-dateTime(xs:dateTime("1999-12-31T19:20:00"))</fos:expression>
               <fos:result>1999</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:year-from-dateTime(xs:dateTime("1999-12-31T24:00:00"))</fos:expression>
               <fos:result>2000</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="month-from-dateTime" prefix="fn">
      <fos:signatures>
         <fos:proto name="month-from-dateTime" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:dateTime?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the month component of an <code>xs:dateTime</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> between 1 and 12, both
            inclusive, representing the month component in the local value of <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:month-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</fos:expression>
               <fos:result>5</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:month-from-dateTime(xs:dateTime("1999-12-31T19:20:00-05:00"))</fos:expression>
               <fos:result>12</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:month-from-dateTime(fn:adjust-dateTime-to-timezone(xs:dateTime("1999-12-31T19:20:00-05:00"),
                  xs:dayTimeDuration("PT0S")))</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="day-from-dateTime" prefix="fn">
      <fos:signatures>
         <fos:proto name="day-from-dateTime" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:dateTime?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the day component of an <code>xs:dateTime</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> between 1 and 31, both
            inclusive, representing the day component in the local value of <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:day-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</fos:expression>
               <fos:result>31</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:day-from-dateTime(xs:dateTime("1999-12-31T20:00:00-05:00"))</fos:expression>
               <fos:result>31</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:day-from-dateTime(fn:adjust-dateTime-to-timezone(xs:dateTime("1999-12-31T19:20:00-05:00"),
                  xs:dayTimeDuration("PT0S")))</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="hours-from-dateTime" prefix="fn">
      <fos:signatures>
         <fos:proto name="hours-from-dateTime" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:dateTime?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the hours component of an <code>xs:dateTime</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> between 0 and 23, both
            inclusive, representing the hours component in the local value of <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-dateTime(xs:dateTime("1999-05-31T08:20:00-05:00"))</fos:expression>
               <fos:result>8</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-dateTime(xs:dateTime("1999-12-31T21:20:00-05:00"))</fos:expression>
               <fos:result>21</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-dateTime(fn:adjust-dateTime-to-timezone(xs:dateTime("1999-12-31T21:20:00-05:00"),
                  xs:dayTimeDuration("PT0S")))</fos:expression>
               <fos:result>2</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-dateTime(xs:dateTime("1999-12-31T12:00:00"))</fos:expression>
               <fos:result>12</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-dateTime(xs:dateTime("1999-12-31T24:00:00"))</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="minutes-from-dateTime" prefix="fn">
      <fos:signatures>
         <fos:proto name="minutes-from-dateTime" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:dateTime?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the minute component of an <code>xs:dateTime</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> value between 0 and 59, both
            inclusive, representing the minute component in the local value of
            <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:minutes-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</fos:expression>
               <fos:result>20</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:minutes-from-dateTime(xs:dateTime("1999-05-31T13:30:00+05:30"))</fos:expression>
               <fos:result>30</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="seconds-from-dateTime" prefix="fn">
      <fos:signatures>
         <fos:proto name="seconds-from-dateTime" return-type="xs:decimal?">
            <fos:arg name="arg" type="xs:dateTime?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the seconds component of an <code>xs:dateTime</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:decimal</code> value greater than or equal
            to zero and less than 60, representing the seconds and fractional seconds in the local
            value of <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:seconds-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="timezone-from-dateTime" prefix="fn">
      <fos:signatures>
         <fos:proto name="timezone-from-dateTime" return-type="xs:dayTimeDuration?">
            <fos:arg name="arg" type="xs:dateTime?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the timezone component of an <code>xs:dateTime</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns the timezone component of <code>$arg</code>, if any. If
               <code>$arg</code> has a timezone component, then the result is an
               <code>xs:dayTimeDuration</code> that indicates deviation from UTC; its value may
            range from +14:00 to -14:00 hours, both inclusive. If <code>$arg</code> has no timezone
            component, the result is the empty sequence.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:timezone-from-dateTime(xs:dateTime("1999-05-31T13:20:00-05:00"))</fos:expression>
               <fos:result>xs:dayTimeDuration("-PT5H")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:timezone-from-dateTime(xs:dateTime("2000-06-12T13:20:00Z"))</fos:expression>
               <fos:result>xs:dayTimeDuration("PT0S")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:timezone-from-dateTime(xs:dateTime("2004-08-27T00:00:00"))</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="year-from-date" prefix="fn">
      <fos:signatures>
         <fos:proto name="year-from-date" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:date?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the year component of an <code>xs:date</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> representing the year in the
            local value of <code>$arg</code>. The value may be negative. </p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:year-from-date(xs:date("1999-05-31"))</fos:expression>
               <fos:result>1999</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:year-from-date(xs:date("2000-01-01+05:00"))</fos:expression>
               <fos:result>2000</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="month-from-date" prefix="fn">
      <fos:signatures>
         <fos:proto name="month-from-date" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:date?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the month component of an <code>xs:date</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> between 1 and 12, both
            inclusive, representing the month component in the local value of <code>$arg</code>.
         </p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:month-from-date(xs:date("1999-05-31-05:00"))</fos:expression>
               <fos:result>5</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:month-from-date(xs:date("2000-01-01+05:00"))</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="day-from-date" prefix="fn">
      <fos:signatures>
         <fos:proto name="day-from-date" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:date?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the day component of an <code>xs:date</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> between 1 and 31, both
            inclusive, representing the day component in the localized value of
            <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:day-from-date(xs:date("1999-05-31-05:00"))</fos:expression>
               <fos:result>31</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:day-from-date(xs:date("2000-01-01+05:00"))</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="timezone-from-date" prefix="fn">
      <fos:signatures>
         <fos:proto name="timezone-from-date" return-type="xs:dayTimeDuration?">
            <fos:arg name="arg" type="xs:date?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the timezone component of an <code>xs:date</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns the timezone component of <code>$arg</code>, if any. If
               <code>$arg</code> has a timezone component, then the result is an
               <code>xs:dayTimeDuration</code> that indicates deviation from UTC; its value may
            range from +14:00 to -14:00 hours, both inclusive. If <code>$arg</code> has no timezone
            component, the result is the empty sequence.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:timezone-from-date(xs:date("1999-05-31-05:00"))</fos:expression>
               <fos:result>xs:dayTimeDuration("-PT5H")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:timezone-from-date(xs:date("2000-06-12Z"))</fos:expression>
               <fos:result>xs:dayTimeDuration("PT0S")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="hours-from-time" prefix="fn">
      <fos:signatures>
         <fos:proto name="hours-from-time" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:time?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the hours component of an <code>xs:time</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> between 0 and 23, both
            inclusive, representing the value of the hours component in the local value of
               <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Assume that the dynamic context provides an implicit timezone value of
                  <code>-05:00</code>. </p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-time(xs:time("11:23:00"))</fos:expression>
               <fos:result>11</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-time(xs:time("21:23:00"))</fos:expression>
               <fos:result>21</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-time(xs:time("01:23:00+05:00"))</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-time(fn:adjust-time-to-timezone(xs:time("01:23:00+05:00"),
                  xs:dayTimeDuration("PT0S")))</fos:expression>
               <fos:result>20</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:hours-from-time(xs:time("24:00:00"))</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="minutes-from-time" prefix="fn">
      <fos:signatures>
         <fos:proto name="minutes-from-time" return-type="xs:integer?">
            <fos:arg name="arg" type="xs:time?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the minutes component of an <code>xs:time</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:integer</code> value between 0 and 59, both
            inclusive, representing the value of the minutes component in the local value of
               <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:minutes-from-time(xs:time("13:00:00Z"))</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="seconds-from-time" prefix="fn">
      <fos:signatures>
         <fos:proto name="seconds-from-time" return-type="xs:decimal?">
            <fos:arg name="arg" type="xs:time?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the seconds component of an <code>xs:time</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:decimal</code> value greater than or equal
            to zero and less than 60, representing the seconds and fractional seconds in the local
            value of <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:seconds-from-time(xs:time("13:20:10.5"))</fos:expression>
               <fos:result>10.5</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="timezone-from-time" prefix="fn">
      <fos:signatures>
         <fos:proto name="timezone-from-time" return-type="xs:dayTimeDuration?">
            <fos:arg name="arg" type="xs:time?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the timezone component of an <code>xs:time</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>Otherwise, the function returns the timezone component of <code>$arg</code>, if any. If
               <code>$arg</code> has a timezone component, then the result is an
               <code>xs:dayTimeDuration</code> that indicates deviation from UTC; its value may
            range from +14:00 to -14:00 hours, both inclusive. If <code>$arg</code> has no timezone
            component, the result is the empty sequence.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:timezone-from-time(xs:time("13:20:00-05:00"))</fos:expression>
               <fos:result>xs:dayTimeDuration("-PT5H")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:timezone-from-time(xs:time("13:20:00"))</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="adjust-dateTime-to-timezone" prefix="fn">
      <fos:signatures>
         <fos:proto name="adjust-dateTime-to-timezone" return-type="xs:dateTime">
            <fos:arg name="arg" type="xs:dateTime?"/>
         </fos:proto>
         <fos:proto name="adjust-dateTime-to-timezone" return-type="xs:dateTime">
            <fos:arg name="arg" type="xs:dateTime?"/>
            <fos:arg name="timezone" type="xs:dayTimeDuration?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Adjusts an <code>xs:dateTime</code> value to a specific timezone, or to no
            timezone at all.</p>
      </fos:summary>
      <fos:rules>
         <p> If <code>$timezone</code> is not specified, then the effective value of
               <code>$timezone</code> is the value of the implicit timezone in the dynamic
            context.</p>
         <p> If <code>$arg</code> is the empty sequence, then the function returns the empty
            sequence.</p>
         <p> If <code>$arg</code> does not have a timezone component and <code>$timezone</code> is
            the empty sequence, then the result is <code>$arg</code>.</p>
         <p> If <code>$arg</code> does not have a timezone component and <code>$timezone</code> is
            not the empty sequence, then the result is <code>$arg</code> with <code>$timezone</code>
            as the timezone component.</p>
         <p> If <code>$arg</code> has a timezone component and <code>$timezone</code> is the empty
            sequence, then the result is the local value of <code>$arg</code> without its timezone
            component.</p>
         <p> If <code>$arg</code> has a timezone component and <code>$timezone</code> is not the
            empty sequence, then the result is the <code>xs:dateTime</code> value that is equal to
               <code>$arg</code> and that has a timezone component equal to
            <code>$timezone</code>.</p>
      </fos:rules>
      <fos:errors>
         <p> A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DT" code="0003"/> if <code>$timezone</code> is less
            than <code>-PT14H</code> or greater than <code>PT14H</code> or is not an integral number
            of minutes.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <p> Assume the dynamic context provides an implicit timezone of <code>-05:00
                  (-PT5H0M)</code>.</p>
         </fos:example>
         <fos:variable name="tz-10" select="xs:dayTimeDuration(&quot;-PT10H&quot;)"/>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00'))</fos:expression>
               <fos:result>xs:dateTime('2002-03-07T10:00:00-05:00')</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00-07:00'))</fos:expression>
               <fos:result>xs:dateTime('2002-03-07T12:00:00-05:00')</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00'),
                  $tz-10)</fos:expression>
               <fos:result>xs:dateTime('2002-03-07T10:00:00-10:00')</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00-07:00'),
                  $tz-10)</fos:expression>
               <fos:result>xs:dateTime('2002-03-07T07:00:00-10:00')</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00-07:00'),
                  xs:dayTimeDuration("PT10H"))</fos:expression>
               <fos:result>xs:dateTime('2002-03-08T03:00:00+10:00')</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T00:00:00+01:00'),
                  xs:dayTimeDuration("-PT8H"))</fos:expression>
               <fos:result>xs:dateTime('2002-03-06T15:00:00-08:00')</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00'),
                  ())</fos:expression>
               <fos:result>xs:dateTime('2002-03-07T10:00:00')</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-dateTime-to-timezone(xs:dateTime('2002-03-07T10:00:00-07:00'),
                  ())</fos:expression>
               <fos:result>xs:dateTime('2002-03-07T10:00:00')</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="adjust-date-to-timezone" prefix="fn">
      <fos:signatures>
         <fos:proto name="adjust-date-to-timezone" return-type="xs:date?">
            <fos:arg name="arg" type="xs:date?"/>
         </fos:proto>
         <fos:proto name="adjust-date-to-timezone" return-type="xs:date?">
            <fos:arg name="arg" type="xs:date?"/>
            <fos:arg name="timezone" type="xs:dayTimeDuration?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Adjusts an <code>xs:date</code> value to a specific timezone, or to no timezone
            at all; the result is the date in the target timezone that contains the starting instant
            of the supplied date.</p>
      </fos:summary>
      <fos:rules>
         <p> If <code>$timezone</code> is not specified, then the effective value of
               <code>$timezone</code> is the value of the implicit timezone in the dynamic
            context.</p>
         <p> If <code>$arg</code> is the empty sequence, then the function returns the empty
            sequence.</p>
         <p> If <code>$arg</code> does not have a timezone component and <code>$timezone</code> is
            the empty sequence, then the result is the value of <code>$arg</code>.</p>
         <p> If <code>$arg</code> does not have a timezone component and <code>$timezone</code> is
            not the empty sequence, then the result is <code>$arg</code> with <code>$timezone</code>
            as the timezone component.</p>
         <p> If <code>$arg</code> has a timezone component and <code>$timezone</code> is the empty
            sequence, then the result is the local value of <code>$arg</code> without its timezone
            component.</p>
         <p> If <code>$arg</code> has a timezone component and <code>$timezone</code> is not the
            empty sequence, then the function returns the value of the expression:</p>
         <ulist>
            <item>
               <p>Let <code>$dt</code> be the value of <code>fn:dateTime($arg,
                     xs:time('00:00:00'))</code>.</p>
            </item>
            <item>
               <p>Let <code>$adt</code> be the value of <code>fn:adjust-dateTime-to-timezone($dt,
                     $timezone)</code></p>
            </item>
            <item>
               <p>The function returns the value of <code>xs:date($adt)</code></p>
            </item>
         </ulist>
         <!--<ednote>
            <edtext>I suspect this procedure actually gives the right result in all cases, so the
               whole description can be simplified.</edtext>
         </ednote>-->
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DT" code="0003"/> if <code>$timezone</code> is less
            than <code>-PT14H</code> or greater than <code>PT14H</code> or is not an integral number
            of minutes.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <p>Assume the dynamic context provides an implicit timezone of <code>-05:00
                  (-PT5H0M)</code>.</p>
         </fos:example>
         <fos:variable name="tz-10" select="xs:dayTimeDuration(&quot;-PT10H&quot;)"/>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>fn:adjust-date-to-timezone(xs:date("2002-03-07"))</fos:expression>
               <fos:result>xs:date("2002-03-07-05:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-date-to-timezone(xs:date("2002-03-07-07:00"))</fos:expression>
               <fos:result>xs:date("2002-03-07-05:00")</fos:result>
               <fos:postamble><code>$arg</code> is converted to
                     <code>xs:dateTime("2002-03-07T00:00:00-07:00")</code>. This is adjusted to the
                  implicit timezone, giving <code>"2002-03-07T02:00:00-05:00"</code>.
               </fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-date-to-timezone(xs:date("2002-03-07"),
                  $tz-10)</fos:expression>
               <fos:result>xs:date("2002-03-07-10:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-date-to-timezone(xs:date("2002-03-07-07:00"),
                  $tz-10)</fos:expression>
               <fos:result>xs:date("2002-03-06-10:00")</fos:result>
               <fos:postamble><code>$arg</code> is converted to the <code>xs:dateTime
                     "2002-03-07T00:00:00-07:00"</code>. This is adjusted to the given timezone,
                  giving <code>"2002-03-06T21:00:00-10:00"</code>. </fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-date-to-timezone(xs:date("2002-03-07"),
                  ())</fos:expression>
               <fos:result>xs:date("2002-03-07")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-date-to-timezone(xs:date("2002-03-07-07:00"),
                  ())</fos:expression>
               <fos:result>xs:date("2002-03-07")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="adjust-time-to-timezone" prefix="fn">
      <fos:signatures>
         <fos:proto name="adjust-time-to-timezone" return-type="xs:time?">
            <fos:arg name="arg" type="xs:time?"/>
         </fos:proto>
         <fos:proto name="adjust-time-to-timezone" return-type="xs:time?">
            <fos:arg name="arg" type="xs:time?"/>
            <fos:arg name="timezone" type="xs:dayTimeDuration?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Adjusts an <code>xs:time</code> value to a specific timezone, or to no timezone
            at all.</p>
      </fos:summary>
      <fos:rules>
         <p> If <code>$timezone</code> is not specified, then the effective value of
               <code>$timezone</code> is the value of the implicit timezone in the dynamic
            context.</p>
         <p> If <code>$arg</code> is the empty sequence, then the function returns the empty
            sequence.</p>
         <p> If <code>$arg</code> does not have a timezone component and <code>$timezone</code> is
            the empty sequence, then the result is <code>$arg</code>.</p>
         <p> If <code>$arg</code> does not have a timezone component and <code>$timezone</code> is
            not the empty sequence, then the result is <code>$arg</code> with <code>$timezone</code>
            as the timezone component.</p>
         <p> If <code>$arg</code> has a timezone component and <code>$timezone</code> is the empty
            sequence, then the result is the localized value of <code>$arg</code> without its
            timezone component.</p>
         <p> If <code>$arg</code> has a timezone component and <code>$timezone</code> is not the
            empty sequence, then:</p>
         <ulist>
            <item>
               <p>Let <code>$dt</code> be the <code>xs:dateTime</code> value
                     <code>fn:dateTime(xs:date('1972-12-31'), $arg)</code>.</p>
            </item>
            <item>
               <p>Let <code>$adt</code> be the value of <code>fn:adjust-dateTime-to-timezone($dt,
                     $timezone)</code>
               </p>
            </item>
            <item>
               <p>The function returns the <code>xs:time</code> value
                  <code>xs:time($adt)</code>.</p>
            </item>
         </ulist>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DT" code="0003"/> if <code>$timezone</code> is less
            than <code>-PT14H</code> or greater than <code>PT14H</code> or if does not contain an
            integral number of minutes.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <p>Assume the dynamic context provides an implicit timezone of <code>-05:00
                  (-PT5H0M)</code>.</p>
         </fos:example>
         <fos:variable name="tz-10" select="xs:dayTimeDuration(&quot;-PT10H&quot;)"/>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>fn:adjust-time-to-timezone(xs:time("10:00:00"))</fos:expression>
               <fos:result>xs:time("10:00:00-05:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"))</fos:expression>
               <fos:result>xs:time("12:00:00-05:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-time-to-timezone(xs:time("10:00:00"),
                  $tz-10)</fos:expression>
               <fos:result>xs:time("10:00:00-10:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"),
                  $tz-10)</fos:expression>
               <fos:result>xs:time("07:00:00-10:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-time-to-timezone(xs:time("10:00:00"), ())</fos:expression>
               <fos:result>xs:time("10:00:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"),
                  ())</fos:expression>
               <fos:result>xs:time("10:00:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:adjust-time-to-timezone(xs:time("10:00:00-07:00"),
                  xs:dayTimeDuration("PT10H"))</fos:expression>
               <fos:result>xs:time("03:00:00+10:00")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-dateTimes" prefix="op">
      <fos:signatures>
         <fos:proto name="subtract-dateTimes" return-type="xs:dayTimeDuration">
            <fos:arg name="arg1" type="xs:dateTime"/>
            <fos:arg name="arg2" type="xs:dateTime"/>
         </fos:proto>
      </fos:signatures>
      
      <fos:opermap operator="-" types="xs:dateTime numeric">Defines the semantics of the "-"
         operator on <code>xs:dateTime</code> values.</fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns an <code>xs:dayTimeDuration</code> representing the amount of elapsed
            time between the instants <code>arg2</code> and <code>arg1</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If either <code>$arg1</code> or <code>$arg2</code> do not contain an explicit timezone
            then, for the purpose of the operation, the implicit timezone provided by the dynamic
            context (See <xspecref spec="XP30" ref="id-xp-evaluation-context-components"/>.) is
            assumed to be present as part of the value.</p>
         <p>The function returns the elapsed time between the date/time instant <code>arg2</code>
            and the date/time instant <code>arg1</code>, computed according to the algorithm given
            in Appendix E of <bibref ref="xmlschema-2"/>, and expressed as a
               <code>xs:dayTimeDuration</code>.</p>
         <p>If the normalized value of <code>$arg1</code> precedes in time the normalized value of
               <code>$arg2</code>, then the returned value is a negative duration.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Assume that the dynamic context provides an implicit timezone value of
                  <code>-05:00</code>.</p>
         </fos:example>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>op:subtract-dateTimes(xs:dateTime("2000-10-30T06:12:00"),
                  xs:dateTime("1999-11-28T09:00:00Z"))</fos:expression>
               <fos:result>xs:dayTimeDuration("P337DT2H12M")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-dates" prefix="op">
      <fos:signatures>
         <fos:proto name="subtract-dates" return-type="xs:dayTimeDuration">
            <fos:arg name="arg1" type="xs:date"/>
            <fos:arg name="arg2" type="xs:date"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:date numeric">Defines the semantics of the "-" operator on
            <code>xs:date</code> values.</fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the <code>xs:dayTimeDuration</code> that corresponds to the elapsed
            time between the starting instant of <code>$arg2</code> and the starting instant of
               <code>$arg2</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If either <code>$arg1</code> or <code>$arg2</code> do not contain an explicit timezone
            then, for the purpose of the operation, the implicit timezone provided by the dynamic
            context (See <xspecref spec="XP30" ref="id-xp-evaluation-context-components"/>.) is
            assumed to be present as part of the value.</p>
         <p>The starting instant of an <code>xs:date</code> is the <code>xs:dateTime</code> at
               <code>00:00:00</code> on that date. </p>
         <p>The function returns the result of subtracting the two starting instants using
               <code>op:subtract-dateTimes</code>.</p>
         <p>If the starting instant of <code>$arg1</code> precedes in time the starting instant of
               <code>$arg2</code>, then the returned value is a negative duration.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>Assume that the dynamic context provides an implicit timezone value of
               <code>Z</code>. </p>
         </fos:example>
         <fos:example>
            <fos:test implicit-timezone="PT0S">
               <fos:expression>op:subtract-dates(xs:date("2000-10-30"),
                  xs:date("1999-11-28"))</fos:expression>
               <fos:result>xs:dayTimeDuration("P337D")</fos:result>
               <fos:postamble>The normalized values of the two starting instants are <code>{2000,
                     10, 30, 0, 0, 0, PT0S}</code> and <code>{1999, 11, 28, 0, 0, 0,
                  PT0S}</code>.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <p>Now assume that the dynamic context provides an implicit timezone value of
                  <code>+05:00</code>.</p>
         </fos:example>
         <fos:example>
            <fos:test implicit-timezone="PT5H">
               <fos:expression>op:subtract-dates(xs:date("2000-10-30"),
                  xs:date("1999-11-28Z"))</fos:expression>
               <fos:result>xs:dayTimeDuration("P336DT19H")</fos:result>
               <fos:postamble> The normalized values of the two starting instants are <code>{2000,
                     10, 29, 19, 0, 0, PT0S}</code> and <code>{1999, 11, 28, 0, 0, 0,
                  PT0S}</code>.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-dates(xs:date("2000-10-15-05:00"),
                  xs:date("2000-10-10+02:00"))</fos:expression>
               <fos:result>xs:dayTimeDuration("P5DT7H")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-times" prefix="op">
      <fos:signatures>
         <fos:proto name="subtract-times" return-type="xs:dayTimeDuration">
            <fos:arg name="arg1" type="xs:time"/>
            <fos:arg name="arg2" type="xs:time"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:time numeric">Defines the semantics of the "-" operator on
            <code>xs:time</code> values.</fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the <code>xs:dayTimeDuration</code> that corresponds to the elapsed
            time between the values of <code>$arg2</code> and <code>$arg1</code> treated as times on
            the same date.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of the expression:</p>
         <eg xml:space="preserve">op-subtract-dateTimes(
        fn:dateTime(xs:date('1972-12-31'), $arg1),
        fn:dateTime(xs:date('1972-12-31'), $arg2))</eg>
      </fos:rules>
      <fos:notes>
         <p>Any other reference date would work equally well.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p>Assume that the dynamic context provides an implicit timezone value of
                  <code>-05:00</code>. Assume, also, that the date components of the reference
                  <code>xs:dateTime</code> correspond to <code>"1972-12-31"</code>.</p>
         </fos:example>
         <fos:example>
            <fos:test implicit-timezone="-PT5H">
               <fos:expression>op:subtract-times(xs:time("11:12:00Z"),
                  xs:time("04:00:00"))</fos:expression>
               <fos:result>xs:dayTimeDuration("PT2H12M")</fos:result>
               <fos:postamble>This is obtained by subtracting from the <code>xs:dateTime</code>
                  value <code>{1972, 12, 31, 11, 12, 0, PT0S}</code> the <code>xs:dateTime</code>
                  value <code>{1972, 12, 31, 9, 0, 0, PT0S}</code>.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-times(xs:time("11:00:00-05:00"),
                  xs:time("21:30:00+05:30"))</fos:expression>
               <fos:result>xs:dayTimeDuration("PT0S")</fos:result>
               <fos:postamble>The two <code>xs:dateTime</code> values are <code>{1972, 12, 31, 11,
                     0, 0, -PT5H}</code> and <code>{1972, 12, 31, 21, 30, 0, PT5H30M}</code>. These
                  normalize to <code>{1972, 12, 31, 16, 0, 0, PT0S}</code> and <code>{1972, 12, 31,
                     16, 0, 0, PT0S}</code>. </fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-times(xs:time("17:00:00-06:00"),
                  xs:time("08:00:00+09:00"))</fos:expression>
               <fos:result>xs:dayTimeDuration("P1D")</fos:result>
               <fos:postamble>The two normalized <code>xs:dateTime</code> values are <code>{1972,
                     12, 31, 23, 0, 0, PT0S}</code> and <code>{1972, 12, 30, 23, 0, 0,
                  PT0S}</code>.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-times(xs:time("24:00:00"),
                  xs:time("23:59:59"))</fos:expression>
               <fos:result>xs:dayTimeDuration("-PT23H59M59S")</fos:result>
               <fos:postamble>The two normalized <code>xs:dateTime</code> values are <code>{1972,
                     12, 31, 0, 0, 0, ()}</code> and <code>{1972, 12, 31, 23, 59, 59.0,
                  ()}</code>.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="add-yearMonthDuration-to-dateTime" prefix="op">
      <fos:signatures>
         <fos:proto name="add-yearMonthDuration-to-dateTime" return-type="xs:dateTime">
            <fos:arg name="arg1" type="xs:dateTime"/>
            <fos:arg name="arg2" type="xs:yearMonthDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="+" types="xs:dateTime xs:yearMonthDuration numeric">Defines the
         semantics of the "+" operator on <code>xs:dateTime</code> and
            <code>xs:yearMonthDuration</code> values. </fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the <code>xs:dateTime</code> that is a given duration after a specified
               <code>xs:dateTime</code> (or before, if the duration is negative).</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of adding <code>$arg2</code> to the value of
               <code>$arg1</code> using the algorithm described in Appendix E of <bibref
               ref="xmlschema-2"/>, disregarding the rule about leap seconds. If <code>$arg2</code>
            is negative, then the result <code>xs:dateTime</code> precedes <code>$arg1</code>.</p>
         <p>The result has the same timezone as <code>$arg1</code>. If <code>$arg1</code> has no
            timezone, the result has no timezone. </p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:add-yearMonthDuration-to-dateTime(xs:dateTime("2000-10-30T11:12:00"),
                  xs:yearMonthDuration("P1Y2M"))</fos:expression>
               <fos:result>xs:dateTime("2001-12-30T11:12:00")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="add-dayTimeDuration-to-dateTime" prefix="op">
      <fos:signatures>
         <fos:proto name="add-dayTimeDuration-to-dateTime" return-type="xs:dateTime">
            <fos:arg name="arg1" type="xs:dateTime"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="+" types="xs:dateTime xs:dayTimeDuration numeric">Defines the semantics
         of the "+" operator on <code>xs:dateTime</code> and <code>xs:dayTimeDuration</code> values. </fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the <code>xs:dateTime</code> that is a given duration after a specified
               <code>xs:dateTime</code> (or before, if the duration is negative).</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of adding <code>$arg2</code> to the value of
               <code>$arg1</code> using the algorithm described in Appendix E of <bibref
               ref="xmlschema-2"/>, disregarding the rule about leap seconds. If <code>$arg2</code>
            is negative, then the result <code>xs:dateTime</code> precedes <code>$arg1</code>.</p>
         <p>The result has the same timezone as <code>$arg1</code>. If <code>$arg1</code> has no
            timezone, the result has no timezone. </p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:add-dayTimeDuration-to-dateTime(xs:dateTime("2000-10-30T11:12:00"),
                  xs:dayTimeDuration("P3DT1H15M"))</fos:expression>
               <fos:result>xs:dateTime("2000-11-02T12:27:00")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-yearMonthDuration-from-dateTime" prefix="op">
      <fos:signatures>
         <fos:proto name="subtract-yearMonthDuration-from-dateTime" return-type="xs:dateTime">
            <fos:arg name="arg1" type="xs:dateTime"/>
            <fos:arg name="arg2" type="xs:yearMonthDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:dateTime xs:yearMonthDuration numeric">Defines the
         semantics of the "-" operator on <code>xs:dateTime</code> and
            <code>xs:yearMonthDuration</code> values. </fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the <code>xs:dateTime</code> that is a given duration before a
            specified <code>xs:dateTime</code> (or after, if the duration is negative).</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the <code>xs:dateTime</code> computed by negating
               <code>$arg2</code> and adding the result to the value of <code>$arg1</code> using the
            function <code>op:add-yearMonthDuration-to-dateTime</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-yearMonthDuration-from-dateTime(xs:dateTime("2000-10-30T11:12:00"),
                  xs:yearMonthDuration("P1Y2M"))</fos:expression>
               <fos:result>xs:dateTime("1999-08-30T11:12:00")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-dayTimeDuration-from-dateTime" prefix="op">
      <fos:signatures>
         <fos:proto name="subtract-dayTimeDuration-from-dateTime" return-type="xs:dateTime">
            <fos:arg name="arg1" type="xs:dateTime"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:dateTime xs:dayTimeDuration numeric">Defines the semantics
         of the "-" operator on <code>xs:dateTime</code> and <code>xs:dayTimeDuration</code>
         values.</fos:opermap>
      <fos:summary>
         <p>Returns the <code>xs:dateTime</code> that is a given duration before a
            specified <code>xs:dateTime</code> (or after, if the duration is negative).</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the <code>xs:dateTime</code> computed by negating
               <code>$arg2</code> and adding the result to the value of <code>$arg1</code> using the
            function <code>op:add-dayTimeDuration-to-dateTime</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-dayTimeDuration-from-dateTime(xs:dateTime("2000-10-30T11:12:00"),
                  xs:dayTimeDuration("P3DT1H15M"))</fos:expression>
               <fos:result>xs:dateTime("2000-10-27T09:57:00")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="add-yearMonthDuration-to-date" prefix="op">
      <fos:signatures>
         <fos:proto name="add-yearMonthDuration-to-date" return-type="xs:date">
            <fos:arg name="arg1" type="xs:date"/>
            <fos:arg name="arg2" type="xs:yearMonthDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="+" types="xs:date xs:yearMonthDuration numeric">Defines the semantics
         of the "+" operator on <code>xs:date</code> and <code>xs:yearMonthDuration</code> values. </fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the <code>xs:date</code> that is a given duration after a specified
               <code>xs:date</code> (or before, if the duration is negative).</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of casting <code>$arg1</code> to an
               <code>xs:dateTime</code>, adding <code>$arg2</code> using the function
               <code>op:add-yearMonthDuration-to-dateTime</code>, and casting the result back to an
               <code>xs:date</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:add-yearMonthDuration-to-date(xs:date("2000-10-30"),
                  xs:yearMonthDuration("P1Y2M"))</fos:expression>
               <fos:result>xs:date("2001-12-30")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="add-dayTimeDuration-to-date" prefix="op">
      <fos:signatures>
         <fos:proto name="add-dayTimeDuration-to-date" return-type="xs:date">
            <fos:arg name="arg1" type="xs:date"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="+" types="xs:date xs:dayTimeDuration numeric">Defines the semantics of
         the "+" operator on <code>xs:date</code> and <code>xs:dayTimeDuration</code> values. </fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the <code>xs:date</code> that is a given duration after a specified
               <code>xs:date</code> (or before, if the duration is negative).</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of casting <code>$arg1</code> to an
               <code>xs:dateTime</code>, adding <code>$arg2</code> using the function
               <code>op:add-dayTimeDuration-to-dateTime</code>, and casting the result back to an
               <code>xs:date</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:add-dayTimeDuration-to-date(xs:date("2004-10-30Z"),
                  xs:dayTimeDuration("P2DT2H30M0S"))</fos:expression>
               <fos:result>xs:date("2004-11-01Z")</fos:result>
               <fos:postamble> The starting instant of the first argument is the
                     <code>xs:dateTime</code> value <code>{2004, 10, 30, 0, 0, 0, PT0S}</code>.
                  Adding the second argument to this gives the <code>xs:dateTime</code> value
                     <code>{2004, 11, 1, 2, 30, 0, PT0S}</code>. The time components are then
                  discarded. </fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-yearMonthDuration-from-date" prefix="op">
      <fos:signatures>
         <fos:proto name="subtract-yearMonthDuration-from-date" return-type="xs:date">
            <fos:arg name="arg1" type="xs:date"/>
            <fos:arg name="arg2" type="xs:yearMonthDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:date xs:yearMonthDuration numeric">Defines the semantics
         of the "-" operator on <code>xs:date</code> and <code>xs:yearMonthDuration</code> values. </fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the <code>xs:date</code> that is a given duration before a specified
               <code>xs:date</code> (or after, if the duration is negative).</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the <code>xs:date</code> computed by negating <code>$arg2</code> and adding the
            result to <code>$arg1</code> using the function
               <code>op:add-yearMonthDuration-to-date</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-yearMonthDuration-from-date(xs:date("2000-10-30"),
                  xs:yearMonthDuration("P1Y2M"))</fos:expression>
               <fos:result>xs:date("1999-08-30")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-yearMonthDuration-from-date(xs:date("2000-02-29Z"),
                  xs:yearMonthDuration("P1Y"))</fos:expression>
               <fos:result>xs:date("1999-02-28Z")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-yearMonthDuration-from-date(xs:date("2000-10-31-05:00"),
                  xs:yearMonthDuration("P1Y1M"))</fos:expression>
               <fos:result>xs:date("1999-09-30-05:00")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-dayTimeDuration-from-date" prefix="op">
      <fos:signatures>
         <fos:proto name="subtract-dayTimeDuration-from-date" return-type="xs:date">
            <fos:arg name="arg1" type="xs:date"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:date xs:dayTimeDuration numeric">Defines the semantics of
         the "-" operator on <code>xs:date</code> and <code>xs:dayTimeDuration</code> values. </fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the <code>xs:date</code> that is a given duration before a specified
               <code>xs:date</code> (or after, if the duration is negative).</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the <code>xs:date</code> computed by negating <code>$arg2</code> and adding the
            result to <code>$arg1</code> using the function
               <code>op:add-dayTimeDuration-to-date</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-dayTimeDuration-from-date(xs:date("2000-10-30"),
                  xs:dayTimeDuration("P3DT1H15M"))</fos:expression>
               <fos:result>xs:date("2000-10-26")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="add-dayTimeDuration-to-time" prefix="op">
      <fos:signatures>
         <fos:proto name="add-dayTimeDuration-to-time" return-type="xs:time">
            <fos:arg name="arg1" type="xs:time"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="+" types="xs:time xs:dayTimeDuration numeric">Defines the semantics of
         the "+" operator on <code>xs:time</code> and <code>xs:dayTimeDuration</code>
         values.</fos:opermap>
      <fos:summary>
         <p>Returns the <code>xs:time</code> value that is a given duration after a
            specified <code>xs:time</code> (or before, if the duration is negative or causes
            wrap-around past midnight)</p>
      </fos:summary>
      <fos:rules>
         <p>First, the days component in the canonical lexical representation of <code>$arg2</code>
            is set to zero (0) and the value of the resulting <code>xs:dayTimeDuration</code> is
            calculated. Alternatively, the value of <code>$arg2</code> modulus 86,400 is used as the
            second argument. This value is added to the value of <code>$arg1</code> converted to an
               <code>xs:dateTime</code> using a reference date such as <code>1972-12-31</code>, and
            the time component of the result is returned. Note that the <code>xs:time</code>
            returned may occur in a following or preceding day and may be less than
               <code>$arg1</code>.</p>
         <p>The result has the same timezone as <code>$arg1</code>. If <code>$arg1</code> has no
            timezone, the result has no timezone.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:add-dayTimeDuration-to-time(xs:time("11:12:00"),
                  xs:dayTimeDuration("P3DT1H15M"))</fos:expression>
               <fos:result>xs:time("12:27:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:add-dayTimeDuration-to-time(xs:time("23:12:00+03:00"),
                  xs:dayTimeDuration("P1DT3H15M"))</fos:expression>
               <fos:result>xs:time("02:27:00+03:00")</fos:result>
               <fos:postamble>That is, <code>{0, 0, 0, 2, 27, 0, PT3H}</code></fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subtract-dayTimeDuration-from-time" prefix="op">
      <fos:signatures>
         <fos:proto name="subtract-dayTimeDuration-from-time" return-type="xs:time">
            <fos:arg name="arg1" type="xs:time"/>
            <fos:arg name="arg2" type="xs:dayTimeDuration"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="-" types="xs:time xs:dayTimeDuration numeric">Defines the semantics of
         the "-" operator on <code>xs:time</code> and <code>xs:dayTimeDuration</code> values. </fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the <code>xs:time</code> value that is a given duration before a
            specified <code>xs:time</code> (or after, if the duration is negative or causes
            wrap-around past midnight)</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the result of negating <code>$arg2</code> and adding the result to
               <code>$arg1</code> using the function <code>add-dayTimeDuration-to-time</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-dayTimeDuration-from-time(xs:time("11:12:00"),
                  xs:dayTimeDuration("P3DT1H15M"))</fos:expression>
               <fos:result>xs:time("09:57:00")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:subtract-dayTimeDuration-from-time(xs:time("08:20:00-05:00"),
                  xs:dayTimeDuration("P23DT10H10M"))</fos:expression>
               <fos:result>xs:time("22:10:00-05:00")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="format-dateTime">
      <fos:signatures>
         <fos:proto name="format-dateTime" return-type="xs:string?">
            <fos:arg name="value" type="xs:dateTime?"/>
            <fos:arg name="picture" type="xs:string"/>
         </fos:proto>
         <fos:proto name="format-dateTime" return-type="xs:string?">
            <fos:arg name="value" type="xs:dateTime?"/>
            <fos:arg name="picture" type="xs:string"/>
            <fos:arg name="language" type="xs:string?"/>
            <fos:arg name="calendar" type="xs:string?"/>
            <fos:arg name="place" type="xs:string?"/>
         </fos:proto>        
      </fos:signatures>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="default-calendar default-language default-place implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="5">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a string containing an <code>xs:dateTime</code> value formatted for display.</p>
      </fos:summary>
      <fos:rules>
         <p>See <specref ref="rules-for-datetime-formatting"/>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="format-date">
      <fos:signatures>
         <fos:proto name="format-date" return-type="xs:string?">
            <fos:arg name="value" type="xs:date?"/>
            <fos:arg name="picture" type="xs:string"/>
         </fos:proto>
         <fos:proto name="format-date" return-type="xs:string?">
            <fos:arg name="value" type="xs:date?"/>
            <fos:arg name="picture" type="xs:string"/>
            <fos:arg name="language" type="xs:string?"/>
            <fos:arg name="calendar" type="xs:string?"/>
            <fos:arg name="place" type="xs:string?"/>
         </fos:proto>        
      </fos:signatures>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="default-calendar default-language default-place implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="5">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a string containing an <code>xs:date</code> value formatted for display.</p>
      </fos:summary>
      <fos:rules>
         <p>See <specref ref="rules-for-datetime-formatting"/>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="format-time">
      <fos:signatures>
         <fos:proto name="format-time" return-type="xs:string?">
            <fos:arg name="value" type="xs:time?"/>
            <fos:arg name="picture" type="xs:string"/>
         </fos:proto>
         <fos:proto name="format-time" return-type="xs:string?">
            <fos:arg name="value" type="xs:time?"/>
            <fos:arg name="picture" type="xs:string"/>
            <fos:arg name="language" type="xs:string?"/>
            <fos:arg name="calendar" type="xs:string?"/>
            <fos:arg name="place" type="xs:string?"/>
         </fos:proto>        
      </fos:signatures>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="default-calendar default-language default-place implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="5">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a string containing an <code>xs:time</code> value formatted for display.</p>
      </fos:summary>
      <fos:rules>
         <p>See <specref ref="rules-for-datetime-formatting"/>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="resolve-QName">
      <fos:signatures>
         <fos:proto name="resolve-QName" return-type="xs:QName?">
            <fos:arg name="qname" type="xs:string?"/>
            <fos:arg name="element" type="element()"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns an <code>xs:QName</code> value (that is, an expanded-QName) by taking
            an <code>xs:string</code> that has the lexical form of an <code>xs:QName</code> (a
            string in the form "prefix:local-name" or "local-name") and resolving it using the
            in-scope namespaces for a given element.</p>
      </fos:summary>
      <fos:rules>

         <p>If <code>$qname</code> is the empty sequence, returns the empty sequence.</p>
         <p>More specifically, the function searches the namespace bindings of <code>$element</code>
            for a binding whose name matches the prefix of <code>$qname</code>, or the zero-length
            string if it has no prefix, and constructs an expanded-QName whose local name is taken
            from the supplied <code>$qname</code>, and whose namespace URI is taken from the string
            value of the namespace binding.</p>

         <p>If the <code>$qname</code> has no prefix, and there is no namespace binding for
               <code>$element</code> corresponding to the default (unnamed) namespace, then the
            resulting expanded-QName has no namespace part.</p>
         <p>The prefix (or absence of a prefix) in the supplied <code>$qname</code> argument is
            retained in the returned expanded-QName, as discussed in <xspecref spec="DM30"
               ref="terminology"/>.</p>

      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="CA" code="0002"/> if <code>$qname</code> does not
            have the correct lexical form for an instance of <code>xs:QName</code>.</p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="NS" code="0004"/> if <code>$qname</code> has a
            prefix and there is no namespace binding for <code>$element</code> that matches this
            prefix.</p>
      </fos:errors>
      <fos:notes>
         <p>Sometimes the requirement is to construct an <code>xs:QName</code> without using the
            default namespace. This can be achieved by writing:</p>
         <eg xml:space="preserve"> if (contains($qname, ":")) then fn:resolve-QName($qname, $element) else
            fn:QName("", $qname)</eg>
         <p>If the requirement is to construct an <code>xs:QName</code> using the namespaces in the
            static context, then the <code>xs:QName</code> constructor should be used.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p>Assume that the element bound to <code>$element</code> has a single namespace binding
               bound to the prefix <code>eg</code>.</p>
         </fos:example>

         <fos:example>
            <p>
               <code>fn:resolve-QName("hello", $element)</code> returns a QName with local name
               "hello" that is in no namespace.</p>
         </fos:example>
         <fos:example>
            <p>
               <code>fn:resolve-QName("eg:myFunc", $element)</code> returns an <code>xs:QName</code>
               whose namespace URI is specified by the namespace binding corresponding to the prefix
               "eg" and whose local name is "myFunc".</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="QName">
      <fos:signatures>
         <fos:proto name="QName" return-type="xs:QName">
            <fos:arg name="paramURI" type="xs:string?"/>
            <fos:arg name="paramQName" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Constructs an <code>xs:QName</code> value given a namespace URI and a lexical
            QName.</p>
      </fos:summary>
      <fos:rules>
         <p>The namespace URI in the returned QName is taken from <code>$paramURI</code>. If
               <code>$paramURI</code> is the zero-length string or the empty sequence, it represents
            "no namespace".</p>
         <p>The prefix (or absence of a prefix) in <code>$paramQName</code> is retained in the
            returned <code>xs:QName</code> value.</p>
         <p>The local name in the result is taken from the local part of
            <code>$paramQName</code>.</p>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="CA" code="0002"/> if <code>$paramQName</code> does
            not have the correct lexical form for an instance of <code>xs:QName</code>.</p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="CA" code="0002"/> if <code>$paramURI</code> is the
            zero-length string or the empty sequence, and the value of <code>$paramQName</code>
            contains a colon (<code>:</code>).</p>
         <p diff="add" at="G">A <phrase diff="add" at="L">dynamic</phrase> error <rfc2119>may</rfc2119> be raised <errorref class="CA"
               code="0002"/> if <code>$paramURI</code> is not a valid URI (XML Namespaces 1.0) or
            IRI (XML Namespaces 1.1). </p>
      </fos:errors>
      <fos:notes>
         <p diff="del" at="F">Note that unlike the <code>xs:QName</code> constructor, this function
            does not require a string literal as the argument.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p>
               <code>fn:QName("http://www.example.com/example", "person")</code> returns an
                  <code>xs:QName</code> with namespace URI = "http://www.example.com/example", local
               name = "person" and prefix = "".</p>
         </fos:example>
         <fos:example>
            <p>
               <code>fn:QName("http://www.example.com/example", "ht:person")</code> returns an
                  <code>xs:QName</code> with namespace URI = "http://www.example.com/example", local
               name = "person" and prefix = "ht".</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="QName-equal" prefix="op">
      <fos:signatures>
         <fos:proto name="QName-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:QName"/>
            <fos:arg name="arg2" type="xs:QName"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:QName numeric" other-operators="ne">Defines the semantics
         of the "eq" and "ne" operators on values of type <code>xs:QName</code>. </fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns <code>true</code> if two supplied QNames have the same namespace URI
            and the same local part.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns <code>true</code> if the namespace URIs of <code>$arg1</code> and
               <code>$arg2</code> are equal and the local names of <code>$arg1</code> and
               <code>$arg2</code> are equal.</p>
         <p>Otherwise, the function returns <code>false</code>.</p>
         <p>The namespace URI parts are considered equal if they are both <xtermref ref="dt-absent"
               spec="DM30">absent</xtermref>, or if they are both present and equal under the rules
            of the <code>fn:codepoint-equal</code> function.</p>
         <p>The local parts are also compared under the rules of the <code>fn:codepoint-equal</code>
            function.</p>
      </fos:rules>
      <fos:notes>
         <p>The prefix parts of <code>$arg1</code> and <code>$arg2</code>, if any, are ignored.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="prefix-from-QName">
      <fos:signatures>
         <fos:proto name="prefix-from-QName" return-type="xs:NCName?">
            <fos:arg name="arg" type="xs:QName?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the prefix component of the supplied QName.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence the function returns the empty sequence.</p>
         <p>If <code>$arg</code> has no prefix component the function returns the empty
            sequence.</p>
         <p>Otherwise, the function returns an <code>xs:NCName</code> representing the prefix
            component of <code>$arg</code>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="local-name-from-QName">
      <fos:signatures>
         <fos:proto name="local-name-from-QName" return-type="xs:NCName?">
            <fos:arg name="arg" type="xs:QName?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the local part of the supplied QName.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:NCName</code> representing the local part of
               <code>$arg</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:local-name-from-QName(fn:QName("http://www.example.com/example",
                  "person"))</fos:expression>
               <fos:result>"person"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="namespace-uri-from-QName">
      <fos:signatures>
         <fos:proto name="namespace-uri-from-QName" return-type="xs:anyURI?">
            <fos:arg name="arg" type="xs:QName?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the namespace URI part of the supplied QName.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence the function returns the empty sequence.</p>
         <p>Otherwise, the function returns an <code>xs:anyURI</code> representing the namespace URI
            part of <code>$arg</code>.</p>
         <p>If <code>$arg</code> is in no namespace, the function returns the zero-length
               <code>xs:anyURI</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:namespace-uri-from-QName(fn:QName("http://www.example.com/example",
                  "person"))</fos:expression>
               <fos:result>xs:anyURI("http://www.example.com/example")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="namespace-uri-for-prefix">
      <fos:signatures>
         <fos:proto name="namespace-uri-for-prefix" return-type="xs:anyURI?">
            <fos:arg name="prefix" type="xs:string?"/>
            <fos:arg name="element" type="element()"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the namespace URI of one of the in-scope namespaces for
               <code>$element</code>, identified by its namespace prefix.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$element</code> has an in-scope namespace whose namespace prefix is equal to
               <code>$prefix</code>, the function returns the namespace URI of that namespace.</p>
         <p>If <code>$element</code> has no in-scope namespace whose namespace prefix is equal to
            <code>$prefix</code>, the function returns the empty sequence.</p>
         <p diff="chg" at="I">If <code>$prefix</code> is the zero-length string or the empty
            sequence, then if <code>$element</code> has a default namespace (that is, a namespace
            node with no name), the function returns the namespace URI of the default namespace. If
               <code>$element</code> has no default namespace, the function returns the empty
            sequence.</p>
         <p>Prefixes are equal only if their Unicode codepoints match exactly.</p>
      </fos:rules>
      <fos:examples>
         <fos:variable name="e"><![CDATA[
<z:a xmlns="http://example.org/one" xmlns:z="http://example.org/two">
  <b xmlns=""/>
</z:a>]]></fos:variable>
         <fos:example>
            <fos:test>
               <fos:expression>fn:namespace-uri-for-prefix("z", $e)</fos:expression>
               <fos:result>"http://example.org/two"</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:namespace-uri-for-prefix("", $e)</fos:expression>
               <fos:result>"http://example.org/one"</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:namespace-uri-for-prefix((), $e)</fos:expression>
               <fos:result>"http://example.org/one"</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:namespace-uri-for-prefix("xml", $e)</fos:expression>
               <fos:result>"http://www.w3.org/XML/1998/namespace"</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:namespace-uri-for-prefix("xml", $e)</fos:expression>
               <fos:result>"http://www.w3.org/XML/1998/namespace"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="in-scope-prefixes">
      <fos:signatures>
         <fos:proto name="in-scope-prefixes" return-type="xs:string*">
            <fos:arg name="element" type="element()"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the prefixes of the in-scope namespaces for an element node.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence of strings representing the prefixes of the in-scope
            namespaces for <code>$element</code>.</p>

         <p>For namespace bindings that have a prefix, the function returns the prefix as an
               <code>xs:NCName</code>. For the default namespace, which has no prefix, it returns
            the zero-length string. </p>

         <p>The result sequence contains no duplicates.</p>

         <p>The ordering of the result sequence is <termref def="implementation-dependent"
               >implementation-dependent</termref>.</p>

      </fos:rules>
   </fos:function>
   <fos:function name="hexBinary-equal" prefix="op">
      <fos:signatures>
         <fos:proto name="hexBinary-equal" return-type="xs:boolean">
            <fos:arg name="value1" type="xs:hexBinary"/>
            <fos:arg name="value2" type="xs:hexBinary"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:hexBinary numeric" other-operators="ne">Defines the
         semantics of the "eq" and "ne" operators on <code>xs:hexBinary</code> values.</fos:opermap>
      <fos:summary>
         <p>Returns true if two <code>xs:hexBinary</code> values contain the same octet
            sequence.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns <code>true</code> if <code>$value1</code> and <code>$value2</code>
            are of the same length, measured in binary octets, and contain the same octets in the
            same order. Otherwise, it returns <code>false</code>. </p>
      </fos:rules>
   </fos:function>
   <fos:function name="base64Binary-equal" prefix="op">
      <fos:signatures>
         <fos:proto name="base64Binary-equal" return-type="xs:boolean">
            <fos:arg name="value1" type="xs:base64Binary"/>
            <fos:arg name="value2" type="xs:base64Binary"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:base64Binary numeric" other-operators="ne">Defines the
         semantics of the "eq" and "ne" operators on <code>xs:base64Binary</code>
         values.</fos:opermap>
      <fos:summary>
         <p>Returns true if two <code>xs:base64Binary</code> values contain the same octet
            sequence.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns <code>true</code> if <code>$value1</code> and <code>$value2</code>
            are of the same length, measured in binary octets, and contain the same octets in the
            same order. Otherwise, it returns <code>false</code>. </p>
      </fos:rules>
   </fos:function>
   <fos:function name="NOTATION-equal" prefix="op">
      <fos:signatures>
         <fos:proto name="NOTATION-equal" return-type="xs:boolean">
            <fos:arg name="arg1" type="xs:NOTATION"/>
            <fos:arg name="arg2" type="xs:NOTATION"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="eq" types="xs:NOTATION numeric" other-operators="ne">Defines the
         semantics of the "eq" and "ne" operators on values of type <code>xs:NOTATION</code>. </fos:opermap>
      <fos:summary>
         <p>Returns <code>true</code> if the two <code>xs:NOTATION</code> values have the
            same namespace URI and the same local part.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns <code>true</code> if the namespace URIs of <code>$arg1</code> and
               <code>$arg2</code> are equal and the local names of <code>$arg1</code> and
               <code>$arg2</code> are equal.</p>
         <p>Otherwise, the function returns <code>false</code>.</p>
         <p>The namespace URI parts are considered equal if they are both <xtermref ref="dt-absent"
               spec="DM30">absent</xtermref>, or if they are both present and equal under the rules
            of the <code>fn:codepoint-equal</code> function.</p>
         <p>The local parts are also compared under the rules of the <code>fn:codepoint-equal</code>
            function.</p>
      </fos:rules>
      <fos:notes>
         <p>The prefix parts of <code>$arg1</code> and <code>$arg2</code>, if any, are ignored.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="name">
      <fos:signatures>
         <fos:proto name="name" return-type="xs:string"/>
         <fos:proto name="name" return-type="xs:string">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the name of a node, as an <code>xs:string</code> that is either the
            zero-length string, or has the lexical form of an <code>xs:QName</code>. </p>
      </fos:summary>
      <fos:rules>
         <p>If the argument is omitted, it defaults to the context item (<code>.</code>). The
            behavior of the function if the argument is omitted is exactly the same as if the
            context item had been passed as the argument.</p>
         <p>If the argument is supplied and is the empty sequence, the function returns the
            zero-length string.</p>
         <p>If the node identified by <code>$arg</code> has no name (that is, if it is a document
            node, a comment, a text node, or a namespace node having no name), the function returns
            the zero-length string.</p>
         <p>Otherwise, the function returns the value of the expression
               <code>fn:string(fn:node-name($arg))</code>.</p>
      </fos:rules>
      <fos:errors>
         <p>The following errors may be raised when <code>$arg</code> is omitted: if the context
            item is <xtermref ref="dt-absent" spec="DM30">absent</xtermref>
            <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a
            node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>

      </fos:errors>
   </fos:function>
   <fos:function name="local-name">
      <fos:signatures>
         <fos:proto name="local-name" return-type="xs:string"/>
         <fos:proto name="local-name" return-type="xs:string">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the local part of the name of <code>$arg</code> as an
               <code>xs:string</code> that is either the zero-length string, or has the lexical form
            of an <code>xs:NCName</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>If the argument is omitted, it defaults to the context item (<code>.</code>). The
            behavior of the function if the argument is omitted is exactly the same as if the
            context item had been passed as the argument.</p>
         <p>If the argument is supplied and is the empty sequence, the function returns the
            zero-length string.</p>
         <p>If the node identified by <code>$arg</code> has no name (that is, if it is a document
            node, a comment, a text node, or a namespace node having no name), the function returns
            the zero-length string.</p>
         <p>Otherwise, the function returns the local part of the expanded-QName of the node
            identified by <code>$arg</code>, as determined by the <code>dm:node-name</code> accessor
            defined in <xspecref spec="DM30" ref="dm-node-name"/>). This will be an
               <code>xs:string</code> whose lexical form is an <code>xs:NCName</code>.</p>
      </fos:rules>
      <fos:errors>
         <p>The following errors may be raised when <code>$arg</code> is omitted: if the context
            item is absent <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context
            item is not a node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>

      </fos:errors>
   </fos:function>
   <fos:function name="namespace-uri">
      <fos:signatures>
         <fos:proto name="namespace-uri" return-type="xs:anyURI"/>
         <fos:proto name="namespace-uri" return-type="xs:anyURI">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p diff="chg" at="A-E15">Returns the namespace URI part of the name of
               <code>$arg</code>, as an <code>xs:anyURI</code> value.</p>
      </fos:summary>
      <fos:rules>
         <p>If the argument is omitted, it defaults to the context node (<code>.</code>). The
            behavior of the function if the argument is omitted is exactly the same as if the
            context item had been passed as the argument.</p>
         <p>If the node identified by <code>$arg</code> is neither an element nor an attribute node,
            or if it is an element or attribute node whose expanded-QName (as determined by the
               <code>dm:node-name</code> accessor in the <xspecref spec="DM30" ref="dm-node-name"/>)
            is in no namespace, then the function returns the zero-length <code>xs:anyURI</code>
            value.</p>
         <p>Otherwise, the result will be the namespace URI part of the expanded-QName of the node
            identified by <code>$arg</code>, as determined by the <code>dm:node-name</code> accessor
            defined in <xspecref spec="DM30" ref="dm-node-name"/>), returned as an
               <code>xs:anyURI</code> value.</p>
      </fos:rules>
      <fos:errors>
         <p>The following errors may be raised when <code>$arg</code> is omitted: if the context
            item is absent <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context
            item is not a node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
      </fos:errors>
   </fos:function>
   <fos:function name="number">
      <fos:signatures>
         <fos:proto name="number" return-type="xs:double"/>
         <fos:proto name="number" return-type="xs:double">
            <fos:arg name="arg" type="xs:anyAtomicType?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the value indicated by <code>$arg</code> or, if <code>$arg</code> is
            not specified, the context item after atomization, converted to an
               <code>xs:double</code>. </p>
      </fos:summary>
      <fos:rules>
         <p>Calling the zero-argument version of the function is defined to give the same result as
            calling the single-argument version with the context item (<code>.</code>). That is,
               <code>fn:number()</code> is equivalent to <code>fn:number(.)</code>, as
         defined by the rules that follow.</p>
         <p>If <code>$arg</code> is the empty sequence or if <code>$arg</code> <phrase diff="del" at="L">or the context item</phrase>
            cannot be converted to an <code>xs:double</code>, the <code>xs:double</code> value
               <code>NaN</code> is returned. </p>
         <p>Otherwise, <code>$arg</code> <phrase diff="del" at="L">, or the context item after atomization,</phrase> is converted to an
               <code>xs:double</code> following the rules of <specref ref="casting-to-double"/>. If
            the conversion to <code>xs:double</code> fails, the <code>xs:double</code> value
               <code>NaN</code> is returned.</p>
      </fos:rules>
      <fos:errors>
         <p>An error is raised <xerrorref spec="XP" class="DY" code="0002" type="type"/> if
               <code>$arg</code> is omitted and the context item is <xtermref ref="dt-absent"
               spec="DM30">absent</xtermref>.</p>
         <p diff="add" at="L">As a consequence of the rules given above, a type error also occurs if the context
         item cannot be atomized, or if the result of atomizing the context item is a sequence containing
         more than one atomic value.</p><!-- bug 16745 -->
      </fos:errors>
      <fos:notes>
         <p diff="add" at="J">XSD 1.1 allows the string <code>+INF</code> as a representation of positive infinity;
         XSD 1.0 does not. It is <termref def="implementation-defined"/> whether XSD 1.1 is supported.</p>
         <p diff="add" at="L">Generally <code>fn:number</code> returns <code>NaN</code> rather than raising a dynamic
         error if the argument cannot be converted to <code>xs:double</code>. 
            However, a type error is raised in the usual way if the supplied argument cannot be
         atomized or if the result of atomization does not match the required argument type.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:number($item1/quantity)</fos:expression>
               <fos:result>5.0e0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:number($item2/description)</fos:expression>
               <fos:result>xs:double('NaN')</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p>Assume that the context item is the <code>xs:string</code> value "<code>15</code>".
               Then <code>fn:number()</code> returns <code>1.5e1</code>.</p>
         </fos:example>
      </fos:examples>

   </fos:function>
   <fos:function name="lang">
      <fos:signatures>
         <fos:proto name="lang" return-type="xs:boolean">
            <fos:arg name="testlang" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="lang" return-type="xs:boolean">
            <fos:arg name="testlang" type="xs:string?"/>
            <fos:arg name="node" type="node()"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>This function tests whether the language of <code>$node</code>, or the context
            item if the second argument is omitted, as specified by <code>xml:lang</code> attributes
            is the same as, or is a sublanguage of, the language specified by
            <code>$testlang</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The behavior of the function if the second argument is omitted is exactly the same as if
            the context item (<code>.</code>) had been passed as the second argument.</p>
         <p>The language of the argument <code>$node</code>, or the context item if the second
            argument is omitted, is determined by the value of the <code>xml:lang</code> attribute
            on the node, or, if the node has no such attribute, by the value of the
               <code>xml:lang</code> attribute on the nearest ancestor of the node that has an
               <code>xml:lang</code> attribute. If there is no such ancestor, then the function
            returns <code>false</code>. </p>

         <p>If <code>$testlang</code> is the empty sequence it is interpreted as the zero-length
            string.</p>
         <p>The relevant <code>xml:lang</code> attribute is determined by the value of the XPath
            expression:</p>
         <eg xml:space="preserve">(ancestor-or-self::*/@xml:lang)[last()]</eg>
         <p>If this expression returns an empty sequence, the function returns <code>false</code>. </p>
         <p>Otherwise, the function returns <code>true</code> if and only if, based on a caseless
            default match as specified in section 3.13 of <bibref ref="Unicode"/>, either:</p>
         <olist>
            <item>
               <p diff="chg" at="A-E16">
                  <code>$testlang</code> is equal to the string-value of the relevant
                     <code>xml:lang</code> attribute, or</p>
            </item>
            <item>
               <p diff="chg" at="A-E16">
                  <code>$testlang</code> is equal to some substring of the string-value of the
                  relevant <code>xml:lang</code> attribute that starts at the start of the
                  string-value and ends immediately before a hyphen, "-" (the character "-" is
                  HYPHEN-MINUS, #x002D).</p>
            </item>
         </olist>
      </fos:rules>
      <fos:errors>
         <p>When <code>$arg</code> is omitted the following errors may be raised: if the context
            item is absent <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context
            item is not a node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <p>The expression <code>fn:lang("en")</code> would return <code>true</code> if the
               context node were any of the following four elements:</p>
            <ulist>
               <item>
                  <p>
                     <code>&lt;para xml:lang="en"/&gt;</code>
                  </p>
               </item>
               <item>
                  <p>
                     <code>&lt;div xml:lang="en"&gt;&lt;para&gt;And now, and
                        forever!&lt;/para&gt;&lt;/div&gt;</code>
                  </p>
               </item>
               <item>
                  <p>
                     <code>&lt;para xml:lang="EN"/&gt;</code>
                  </p>
               </item>
               <item>
                  <p>
                     <code>&lt;para xml:lang="en-us"/&gt;</code>
                  </p>
               </item>
            </ulist>
         </fos:example>
         <fos:example>
            <p>The expression <code>fn:lang("fr")</code> would return <code>false</code> if the
               context node were <code>&lt;para xml:lang="EN"/&gt;</code>
            </p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="path" diff="add" at="J">
      <fos:signatures>
         <fos:proto name="path" return-type="xs:string?"/>
         <fos:proto name="path" return-type="xs:string?">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary><p>Returns a path expression that can be used to select the supplied node
         relative to the root of its containing document.</p></fos:summary>
      <fos:rules>
         <p>The behavior of the function if the argument is omitted is exactly the same as if
            the context item (<code>.</code>) had been passed as the argument.</p>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>If <code>$arg</code> is a document node, the function returns the string <code>"/"</code>.</p>
         <p>Otherwise, the function constructs a string that consists of a sequence of
            steps, one for each ancestor-or-self of <code>$arg</code> other than the <phrase diff="chg" at="L">root</phrase> node.
            <phrase diff="add" at="L">This string is prefixed by <code>"Q{http://www.w3.org/2005/xpath-functions}root()"</code> if the root node
            is not a document node.</phrase>
            Each step consists of the character <code>"/"</code> followed by a string whose form depends
            on the kind of node selected by that step, as follows:</p>
         
         <olist>
            <item><p diff="chg" at="L">For an element node, <code>Q{<emph>uri</emph>}<emph>local</emph>[<emph>position</emph>]</code>, where 
               <code><emph>uri</emph></code> is the
               namespace URI of the node name or the empty string if the node is in no
               namespace, <code><emph>local</emph></code> is the local part of the node name, and <code><emph>position</emph></code> is an
               integer representing the position of the selected node among its like-named
               siblings.</p></item>
            <item><p diff="chg" at="L">For an attribute node:</p>
               <olist>
                  <item><p>if the node is in no namespace, <code>@<emph>local</emph></code>, 
                     where <code><emph>local</emph></code> is the local part
                     of the node name</p></item>
                  <item><p>otherwise, <code>@Q{<emph>uri</emph>}<emph>local</emph></code>, where <code><emph>uri</emph></code> is the namespace URI of the
                     node name, and <code><emph>local</emph></code> is the local part of the node name</p></item>
               </olist>
            </item>
            <item><p>For a text node: <code>text()[<emph>position</emph>]</code> where <code><emph>position</emph></code> is an integer
               representing the position of the selected node among its text node siblings</p></item>
            <item><p>For a comment node: <code>comment()[<emph>position</emph>]</code> where <code><emph>position</emph></code> is an integer
               representing the position of the selected node among its comment node siblings</p></item>
            <item><p>For a processing-instruction node:
               <code>processing-instruction(<emph>local</emph>)[<emph>position</emph>]</code> where 
               <code><emph>local</emph></code> is the name of the
               processing instruction node and <code><emph>position</emph></code> is an integer representing the
               position of the selected node among its like-named processing-instruction node
               siblings</p></item>
            <item><p>For a namespace node:</p>
               <olist>
               <item><p>If the namespace node has a name: 
               <code>namespace::<emph>prefix</emph></code>, where <code><emph>prefix</emph></code> is the local part
               of the name of the namespace node (which represents the namespace prefix).</p></item>
                  <item><p diff="chg" at="L">If the namespace node has no name (that is, it represents
                     the default namespace): 
                     <code>namespace::*[Q{http://www.w3.org/2005/xpath-functions}local-name()=""]</code></p></item>
               </olist>
               </item>
         </olist>
         
      </fos:rules>
      <fos:examples>
         <fos:variable name="e"><![CDATA[
fn:parse-xml('<?xml version="1.0"?>
<p xmlns="http://example.com/one" xml:lang="de" author="Friedrich von Schiller">
Freude, schöner Götterfunken,<br/>
Tochter aus Elysium,<br/>
Wir betreten feuertrunken,<br/>
Himmlische, dein Heiligtum.</p>')]]>
         </fos:variable> 
         <fos:example>
            <fos:test>
               <fos:expression>fn:path($e)</fos:expression>
               <fos:result>'/'</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:path($e/*:p)</fos:expression>
               <fos:result>'/Q{http://example.com/one}p[1]'</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:path($e/*:p/@xml:lang)</fos:expression>
               <fos:result>'/Q{http://example.com/one}p[1]/@Q{http://www.w3.org/XML/1998/namespace}lang'</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:path($e/*:p/@author)</fos:expression>
               <fos:result>'/Q{http://example.com/one}p[1]/@author'</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:path($e/*:p/*:br[2])</fos:expression>
               <fos:result>'/Q{http://example.com/one}p[1]/Q{http://example.com/one}br[2]'</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:path($e//text()[starts-with(normalize-space(), 'Tochter')])</fos:expression>
               <fos:result>'/Q{http://example.com/one}p[1]/text()[2]'</fos:result>
            </fos:test>            
         </fos:example>
         <fos:variable name="emp" as="element()"><![CDATA[
            <employee xml:id="ID21256">
               <empnr>E21256</empnr>
               <first>John</first>
               <last>Brown</last>
            </employee>]]>
         </fos:variable>
         <fos:example>
            <fos:test>
               <fos:expression>fn:path($emp)</fos:expression>
               <fos:result>'Q{http://www.w3.org/2005/xpath-functions}root()'</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:path($emp/@xml:id)</fos:expression>
               <fos:result>'Q{http://www.w3.org/2005/xpath-functions}root()/@Q{http://www.w3.org/XML/1998/namespace}id'</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:path($emp/empnr)</fos:expression>
               <fos:result>'Q{http://www.w3.org/2005/xpath-functions}root()/Q{}empnr[1]'</fos:result>
            </fos:test>
         </fos:example>  
       </fos:examples>  
   </fos:function>
   
   <fos:function name="is-same-node" prefix="op">
      <fos:signatures>
         <fos:proto name="is-same-node" return-type="xs:boolean">
            <fos:arg name="arg1" type="node()"/>
            <fos:arg name="arg2" type="node()"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="is" types="numeric">Defines the semantics of the "is" operator on
         nodes.</fos:opermap>
      <fos:summary>
         <p>Returns true if the two arguments refer to the same node.</p>
      </fos:summary>
      <fos:rules>
         <p>If the node identified by the value of <code>$arg1</code> is the same node as the node
            identified by the value of <code>$arg2</code> (that is, the two nodes have the same
            identity), then the function returns <code>true</code>; otherwise, the function returns
               <code>false</code>. </p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:is-same-node($item1, $item1)</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:is-same-node($item1, $item2)</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="node-before" prefix="op">
      <fos:signatures>
         <fos:proto name="node-before" return-type="xs:boolean">
            <fos:arg name="arg1" type="node()"/>
            <fos:arg name="arg2" type="node()"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="&lt;&lt;" types="numeric">Defines the semantics of the "&lt;&lt;"
         operator.</fos:opermap>
      <fos:summary>
         <p>Returns true if the node identified by the first argument precedes the node
            identified by the second argument in document order.</p>
      </fos:summary>
      <fos:rules>
         <p>If the node identified by the value of <code>$arg1</code> occurs in document order
            before the node identified by the value of <code>$arg2</code>, then the function returns
               <code>true</code>; otherwise, it returns <code>false</code>.</p>
         <p>The rules determining the order of nodes within a single document and in different
            documents can be found in <xspecref spec="DM30" ref="document-order"/>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:node-before($item1, $item2)</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:node-before($item1, $item1)</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="node-after" prefix="op">
      <fos:signatures>
         <fos:proto name="node-after" return-type="xs:boolean">
            <fos:arg name="arg1" type="node()"/>
            <fos:arg name="arg2" type="node()"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator=">>" types="numeric">Defines the semantics of the "&gt;&gt;"
         operator.</fos:opermap>
      <fos:summary>
         <p>Returns true if the node identified by the first argument follows the node
            identified by the second argument in document order.</p>
      </fos:summary>
      <fos:rules>
         <p>If the node identified by the value of <code>$arg1</code> occurs in document order after
            the node identified by the value of <code>$arg2</code>, the function returns
               <code>true</code>; otherwise, it returns <code>false</code>.</p>
         <p>The rules determining the order of nodes within a single document and in different
            documents can be found in <xspecref spec="DM30" ref="document-order"/>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:node-after($item1, $item2)</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:node-after($item1, $item1)</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:node-after($item2, $item1)</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="root">
      <fos:signatures>
         <fos:proto name="root" return-type="node()"/>
         <fos:proto name="root" return-type="node()?">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the root of the tree to which <code>$arg</code> belongs. This will
            usually, but not necessarily, be a document node.</p>
      </fos:summary>
      <fos:rules>
         <p>If the function is called without an argument, the context item (<code>.</code>) is used
            as the default argument. The behavior of the function if the argument is omitted is
            exactly the same as if the context item had been passed as the argument.</p>

         <p>The function returns the value of the expression
               <code>($arg/ancestor-or-self::node())[1]</code>.</p>
      </fos:rules>
      <fos:errors>
         <p>When <code>$arg</code> is omitted the following errors may be raised : if the context
            item is absent <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context
            item is not a node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <p>These examples use some variables which could be defined in <bibref ref="xquery"/>
               as:</p>
         </fos:example>
         <fos:example>
            <eg xml:space="preserve">let $i := &lt;tool&gt;wrench&lt;/tool&gt;
let $o := &lt;order&gt; {$i} &lt;quantity&gt;5&lt;/quantity&gt; &lt;/order&gt;
let $odoc := document {$o}
let $newi := $o/tool</eg>
         </fos:example>
         <fos:example>
            <p>Or they could be defined in <bibref ref="xslt20"/> as:</p>
         </fos:example>
         <fos:example>
            <eg xml:space="preserve">&lt;xsl:variable name="i" as="element()"&gt;
  &lt;tool&gt;wrench&lt;/tool&gt;
&lt;/xsl:variable&gt;

&lt;xsl:variable name="o" as="element()"&gt;
  &lt;order&gt;
    &lt;xsl:copy-of select="$i"/&gt;
    &lt;quantity&gt;5&lt;/quantity&gt;
  &lt;/order&gt;
&lt;/xsl:variable&gt;

&lt;xsl:variable name="odoc"&gt;
  &lt;xsl:copy-of select="$o"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:variable name="newi" select="$o/tool"/&gt;</eg>
         </fos:example>
         <fos:example>
            <p><code>fn:root($i)</code> returns the element node <code>$i</code>
            </p>
         </fos:example>
         <fos:example>
            <p><code>fn:root($o/quantity)</code> returns the element node <code>$o</code>
            </p>
         </fos:example>
         <fos:example>
            <p><code>fn:root($odoc//quantity)</code> returns the document node <code>$odoc</code>
            </p>
         </fos:example>
         <fos:example>
            <p><code>fn:root($newi)</code> returns the element node <code>$o</code>
            </p>
         </fos:example>
         <fos:example>
            <p>The final three examples could be made type-safe by wrapping their operands with
                  <code>fn:exactly-one()</code>.</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="has-children" diff="add" at="G">
      <fos:signatures>
         <fos:proto  diff="add" at="J" name="has-children" return-type="xs:boolean"/>
         <fos:proto name="has-children" return-type="xs:boolean">
            <fos:arg name="node" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
 
         
      <fos:summary>
         <p>Returns true if the supplied node has one or more child nodes (of any kind).</p>
      </fos:summary>
      <fos:rules>
         <p>If the argument is omitted, it defaults to the context item (<code>.</code>). The
            behavior of the function if the argument is omitted is exactly the same as if the
            context item had been passed as the argument.</p>
         <p><phrase diff="add" at="L">Provided that the supplied argument <code>$node</code> matches the expected 
         type <code>node()?</code>, </phrase>the result of the function call <code>fn:has-children($node)</code> is defined to be
            the same as the result of the expression
            <code>fn:exists($node/child::node())</code>.</p>
      </fos:rules>
      <fos:errors>
         <p>The following errors may be raised when <code>$node</code> is omitted: if the context
            item is <xtermref ref="dt-absent" spec="DM30">absent</xtermref>
            <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a
            node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
         
      </fos:errors>
      <fos:notes>
         <p>If <code>$node</code> is an empty sequence the result is false.</p>
         <p>The motivation for this function is to support streamed evaluation. According to the
            streaming rules in <bibref ref="xslt-30"/>, the following construct is not
            streamable:</p>
         <eg><![CDATA[
<xsl:if test="exists(row)">
  <ul>
    <xsl:for-each select="row">
       <li><xsl:value-of select="."/></li>
    </xsl:for-each>
  </ul>
</xsl:if>  
]]></eg>
         <p>This is because it makes two downward selections to read the child <code>row</code>
            elements. The use of <code>fn:has-children</code> in the <code>xsl:if</code> conditional
            is intended to circumvent this restriction.</p>
         <p>Although the function was introduced to support streaming use cases, it has general
            utility as a convenience function.</p>
      </fos:notes>

   </fos:function>
   <fos:function name="innermost" diff="add" at="G">
      <fos:signatures>
         <fos:proto name="innermost" return-type="node()*">
            <fos:arg name="nodes" type="node()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns every node within the input sequence that is not an ancestor of another member
            of the input sequence; the nodes are returned in document order with duplicates
            eliminated.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of the function call <code>fn:innermost($nodes)</code> is defined to be
            equivalent to the result of the expression <code>$nodes except
               $nodes/ancestor::node()</code>.</p>
         <p>That is, the function takes as input a sequence of nodes, and returns every node within
            the sequence that is not an ancestor of another node within the sequence; the nodes are
            returned in document order with duplicates eliminated.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <p>If the source document contains nested sections represented by <code>div</code>
               elements, the expression <code>innermost(//div)</code> returns those <code>div</code>
               elements that do not contain further <code>div</code> elements.</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="outermost" diff="add" at="G">
      <fos:signatures>
         <fos:proto name="outermost" return-type="node()*">
            <fos:arg name="nodes" type="node()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns every node within the input sequence that has no ancestor that is itself a
            member of the input sequence; the nodes are returned in document order with duplicates
            eliminated.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of the function call <code>fn:outermost($nodes)</code> is defined to be
            equivalent to the result of the expression <code diff="chg" at="L">$nodes[not(ancestor::node() intersect
               $nodes)]/.</code>.</p><!--bug 17029-->
         <p>That is, the function takes as input a sequence of nodes, and returns every node within
            the sequence that <phrase diff="chg" at="J">does not have another node within the sequence as an ancestor</phrase>; the nodes are
            returned in document order with duplicates eliminated.</p>
      </fos:rules>
      <fos:notes>
         <p>The formulation <code>$nodes except $nodes/descendant::node()</code> might appear to be
            simpler, but does not correctly account for attribute nodes, as these are not
            descendants of their parent element.</p>
         <p>The motivation for the function was based on XSLT streaming use cases. There are cases
            where the <bibref ref="xslt-30"/> streaming rules allow the construct
               <code>outermost(//section)</code> but do not allow <code>//section</code>; the
            function can therefore be useful in cases where it is known that sections will not be
            nested, as well as cases where the application actually wishes to process all sections
            except those that are nested within another.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p>If the source document contains nested sections represented by <code>div</code>
               elements, the expression <code>outermost(//div)</code> returns those <code>div</code>
               elements that <phrase diff="chg" at="J">are not contained within</phrase> further <code>div</code> elements.</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="concatenate" prefix="op">
      <fos:signatures>
         <fos:proto name="concatenate" return-type="item()*">
            <fos:arg name="seq1" type="item()*"/>
            <fos:arg name="seq2" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="," types="numeric">Defines the semantics of the infix operator ",". </fos:opermap>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the concatenation of two sequences.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence consisting of all the items in <code>$seq1</code>
            followed by all the items in <code>$seq2</code>. </p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>If either sequence is the empty sequence, the other operand is returned.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>op:concatenate((1, 2, 3), (4, 5))</fos:expression>
               <fos:result>(1, 2, 3, 4, 5)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:concatenate((1, 2, 3), ())</fos:expression>
               <fos:result>(1, 2, 3)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:concatenate((), ())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="index-of">
      <fos:signatures>
         <fos:proto name="index-of" return-type="xs:integer*">
            <fos:arg name="seq" type="xs:anyAtomicType*"/>
            <fos:arg name="search" type="xs:anyAtomicType"/>
         </fos:proto>
         <fos:proto name="index-of" return-type="xs:integer*">
            <fos:arg name="seq" type="xs:anyAtomicType*"/>
            <fos:arg name="search" type="xs:anyAtomicType"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="3">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations static-base-uri implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a sequence of positive integers giving the positions within the
            sequence <code>$seq</code> of items that are equal to <code>$search</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence of positive integers giving the positions within the
            sequence <code>$seq</code> of items that are equal to <code>$search</code>.</p>
         <p>The collation used by this function is determined according to the rules in <specref
               ref="choosing-a-collation"/>. This collation is used when string comparison is
            required.</p>
         <p>The items in the sequence <code>$seq</code> are compared with <code>$search</code> under
            the rules for the <code>eq</code> operator. Values of type <code>xs:untypedAtomic</code>
            are compared as if they were of type <code>xs:string</code>. Values that cannot be
            compared, because the <code>eq</code> operator is not defined for their types, are
            considered to be distinct. If an item compares equal, then the position of that item in
            the sequence <code>$seq</code> is included in the result.</p>
         <p>The first item in a sequence is at position 1, not position 0.</p>
         <p>The result sequence is in ascending numeric order.</p>
      </fos:rules>
      <fos:notes>
         <p>If the value of <code>$seq</code> is the empty sequence, or if no item in
               <code>$seq</code> matches <code>$search</code>, then the function returns the empty
            sequence.</p>
         <p diff="add" at="D">No error occurs if non-comparable values are encountered. So when
            comparing two atomic values, the effective boolean value of <code>fn:index-of($a,
               $b)</code> is true if <code>$a</code> and <code>$b</code> are equal, false if they
            are not equal or not comparable.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:index-of((10, 20, 30, 40), 35)</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:index-of((10, 20, 30, 30, 20, 10), 20)</fos:expression>
               <fos:result>(2, 5)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:index-of(("a", "sport", "and", "a", "pastime"),
                  "a")</fos:expression>
               <fos:result>(1, 4)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:index-of(current-date(), 23)</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p diff="chg" at="A-E41">If <code>@a</code> is an attribute of type
                  <code>xs:NMTOKENS</code> whose string value is <code>"red green blue"</code>, and
               whose typed value is therefore <code>("red", "green", "blue")</code>, then
                  <code>fn:index-of(@a, "blue")</code> returns <code>3</code>. This is because the
               function calling mechanism atomizes the attribute node to produce a sequence of three
                  <code>xs:NMTOKEN</code> values.</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="empty">
      <fos:signatures>
         <fos:proto name="empty" return-type="xs:boolean">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns true if the argument is the empty sequence.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg</code> is the empty sequence, the function returns
               <code>true</code>; otherwise, the function returns <code>false</code>. </p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:empty((1,2,3)[10])</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:empty(fn:remove(("hello", "world"), 1))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="exists">
      <fos:signatures>
         <fos:proto name="exists" return-type="xs:boolean">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns true if the argument is a non-empty sequence.</p>
      </fos:summary>
      <fos:rules>
         <p>If the value of <code>$arg</code> is a non-empty sequence, the function returns
               <code>true</code>; otherwise, the function returns <code>false</code>. </p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:exists(fn:remove(("hello"), 1))</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:exists(fn:remove(("hello", "world"), 1))</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="distinct-values">
      <fos:signatures>
         <fos:proto name="distinct-values" return-type="xs:anyAtomicType*">
            <fos:arg name="arg" type="xs:anyAtomicType*"/>
         </fos:proto>
         <fos:proto name="distinct-values" return-type="xs:anyAtomicType*">
            <fos:arg name="arg" type="xs:anyAtomicType*"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations static-base-uri implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the values that appear in a sequence, with duplicates eliminated.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the sequence that results from removing from <code>$arg</code> all
            but one of a set of values that are equal to one another. Values are compared using the
               <code>eq</code> operator, subject to the caveats defined below.</p>
         <p>Values of type <code>xs:untypedAtomic</code> are compared as if they were of type
               <code>xs:string</code>.</p>
         <p>Values that cannot be compared, because the <code>eq</code> operator is not defined for
            their types, are considered to be distinct.</p>

         <p>The collation used by this function is determined according to the rules in <specref
               ref="choosing-a-collation"/>. This collation is used when string comparison is
            required.</p>

         <p>For <code>xs:float</code> and <code>xs:double</code> values, positive zero is equal to
            negative zero and, although <code>NaN</code> does not equal itself, if <code>$arg</code>
            contains multiple <code>NaN</code> values a single <code>NaN</code> is returned.</p>
         <p> If <code>xs:dateTime</code>, <code>xs:date</code> or <code>xs:time</code> values do not
            have a timezone, they are considered to have the implicit timezone provided by the
            dynamic context for the purpose of comparison. Note that <code>xs:dateTime</code>,
               <code>xs:date</code> or <code>xs:time</code> values can compare equal even if their
            timezones are different.</p>
         <p>The order in which the sequence of values is returned is <termref
               def="implementation-dependent"/>.</p>

         <p>Which value of a set of values that compare equal is returned is <termref
               def="implementation-dependent"/>. </p>
         <p diff="del" at="F">The static type of the result is a sequence of prime types as defined
            in [Formal Semantics].</p>
         <change diff="add" at="A-E44">
            <p>If the input sequence contains values of different numeric types that differ from
               each other by small amounts, then the eq operator is not transitive, because of
               rounding effects occurring during type promotion. In the situation where the input
               contains three values <code>A</code>, <code>B</code>, and <code>C</code> such that
                  <code>A eq B</code>, <code>B eq C</code>, but <code>A ne C</code>, then the number
               of items in the result of the function (as well as the choice of which items are
               returned) is <termref def="implementation-dependent"/>, subject only to the
               constraints that (a) no two items in the result sequence compare equal to each other,
               and (b) every input item that does not appear in the result sequence compares equal
               to some item that does appear in the result sequence.</p>

            <p>For example, this arises when computing:</p>

            <eg><![CDATA[    distinct-values(
            (xs:float('1.0'),
            xs:decimal('1.0000000000100000000001',
            xs:double( '1.00000000001'))]]></eg>

            <p>because the values of type <code>xs:float</code> and <code>xs:double</code> both
               compare equal to the value of type <code>xs:decimal</code> but not equal to each
               other. </p>
         </change>
      </fos:rules>
      <fos:notes>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:distinct-values((1, 2.0, 3, 2))</fos:expression>
               <fos:result allow-permutation="true">(1, 3, 2.0)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:distinct-values((xs:untypedAtomic("cherry"),
                  xs:untypedAtomic("plum"), xs:untypedAtomic("plum")))</fos:expression>
               <fos:result allow-permutation="true">(xs:untypedAtomic("cherry"),
                  xs:untypedAtomic("plum"))</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="insert-before">
      <fos:signatures>
         <fos:proto name="insert-before" return-type="item()*">
            <fos:arg name="target" type="item()*"/>
            <fos:arg name="position" type="xs:integer"/>
            <fos:arg name="inserts" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a sequence constructed by inserting an item or a sequence of items at a
            given position within an existing sequence.</p>
      </fos:summary>
      <fos:rules>
         <p>The value returned by the function consists of all items of <code>$target</code> whose
            index is less than <code>$position</code>, followed by all items of
               <code>$inserts</code>, followed by the remaining elements of <code>$target</code>, in
            that order. </p>

         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>If <code>$target</code> is the empty sequence, <code>$inserts</code> is returned. If
               <code>$inserts</code> is the empty sequence, <code>$target</code> is returned.</p>
         <p>If <code>$position</code> is less than one (1), the first position, the effective value
            of <code>$position</code> is one (1). If <code>$position</code> is greater than the
            number of items in <code>$target</code>, then the effective value of
               <code>$position</code> is equal to the number of items in <code>$target</code> plus
            1. </p>
         <p>The value of <code>$target</code> is not affected by the sequence construction.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="abc" select="(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)"/>
         <fos:example>
            <fos:test>
               <fos:expression>fn:insert-before($abc, 0, "z")</fos:expression>
               <fos:result>("z", "a", "b", "c")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:insert-before($abc, 1, "z")</fos:expression>
               <fos:result>("z", "a", "b", "c")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:insert-before($abc, 2, "z")</fos:expression>
               <fos:result>("a", "z", "b", "c")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:insert-before($abc, 3, "z")</fos:expression>
               <fos:result>("a", "b", "z", "c")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:insert-before($abc, 4, "z")</fos:expression>
               <fos:result>("a", "b", "c", "z")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="remove">
      <fos:signatures>
         <fos:proto name="remove" return-type="item()*">
            <fos:arg name="target" type="item()*"/>
            <fos:arg name="position" type="xs:integer"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a new sequence containing all the items of <code>$target</code> except
            the item at position <code>$position</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence consisting of all items of <code>$target</code> whose
            index is less than <code>$position</code>, followed by all items of <code>$target</code>
            whose index is greater than <code>$position</code>. </p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>If <code>$position</code> is less than 1 or greater than the number of items in
               <code>$target</code>, <code>$target</code> is returned.</p>
         <p>If <code>$target</code> is the empty sequence, the empty sequence is returned.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="abc" select="(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)"/>
         <fos:example>
            <fos:test>
               <fos:expression>fn:remove($abc, 0)</fos:expression>
               <fos:result>("a", "b", "c")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:remove($abc, 1)</fos:expression>
               <fos:result>("b", "c")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:remove($abc, 6)</fos:expression>
               <fos:result>("a", "b", "c")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:remove((), 3)</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="head" diff="add" at="E">
      <fos:signatures>
         <fos:proto name="head" return-type="item()?">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the first item in a sequence. </p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the value of the expression <code>$arg[1]</code></p>
      </fos:rules>
      <fos:notes>
         <p>If <code>$arg</code> is the empty sequence, the empty sequence is returned. Otherwise
            the first item in the sequence is returned.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:head(1 to 5)</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:head(("a", "b", "c"))</fos:expression>
               <fos:result>"a"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:head(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="tail" diff="add" at="E">
      <fos:signatures>
         <fos:proto name="tail" return-type="item()*">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns all but the first item in a sequence. </p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the value of the expression <code>subsequence($arg, 2)</code></p>
      </fos:rules>
      <fos:notes>
         <p>If <code>$arg</code> is the empty sequence, or a sequence containing a single item, then
            the empty sequence is returned. </p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:tail(1 to 5)</fos:expression>
               <fos:result>(2, 3, 4, 5)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:tail(("a", "b", "c"))</fos:expression>
               <fos:result>("b", "c")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:tail("a")</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:tail(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="reverse">
      <fos:signatures>
         <fos:proto name="reverse" return-type="item()*">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Reverses the order of items in a sequence. </p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence containing the items in <code>$arg</code> in reverse
            order.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>If <code>$arg</code> is the empty sequence, the empty sequence is returned. </p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="abc" select="(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)"/>
         <fos:example>
            <fos:test>
               <fos:expression>fn:reverse($abc)</fos:expression>
               <fos:result>("c", "b", "a")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:reverse(("hello"))</fos:expression>
               <fos:result>("hello")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:reverse(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="subsequence">
      <fos:signatures>
         <fos:proto name="subsequence" return-type="item()*">
            <fos:arg name="sourceSeq" type="item()*"/>
            <fos:arg name="startingLoc" type="xs:double"/>
         </fos:proto>
         <fos:proto name="subsequence" return-type="item()*">
            <fos:arg name="sourceSeq" type="item()*"/>
            <fos:arg name="startingLoc" type="xs:double"/>
            <fos:arg name="length" type="xs:double"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the contiguous sequence of items in the value of
               <code>$sourceSeq</code> beginning at the position indicated by the value of
               <code>$startingLoc</code> and continuing for the number of items indicated by the
            value of <code>$length</code>. </p>
      </fos:summary>
      <fos:rules>
         <p>In the two-argument case, returns:</p>
         <eg diff="chg" at="A-E2" xml:space="preserve">$sourceSeq[fn:round($startingLoc) le position()]</eg>
         <p>In the three-argument case, returns:</p>
         <eg diff="chg" at="A-E2" xml:space="preserve">$sourceSeq[fn:round($startingLoc) le position() 
         and position() lt fn:round($startingLoc) + fn:round($length)]</eg>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>The first item of a sequence is located at position 1, not position 0.</p>
         <p>If <code>$sourceSeq</code> is the empty sequence, the empty sequence is returned.</p>
         <p> If <code>$startingLoc</code> is zero or negative, the subsequence includes items from
            the beginning of the <code>$sourceSeq</code>.</p>
         <p> If <code>$length</code> is not specified, the subsequence includes items to the end of
               <code>$sourceSeq</code>.</p>
         <p> If <code>$length</code> is greater than the number of items in the value of
               <code>$sourceSeq</code> following <code>$startingLoc</code>, the subsequence includes
            items to the end of <code>$sourceSeq</code>.</p>
         <p diff="add" at="F">As an exception to the previous two notes, if
               <code>$startingLoc</code> is <code>-INF</code> and <code>$length</code> is
               <code>+INF</code>, then <code>fn:round($startingLoc) + fn:round($length)</code> is
               <code>NaN</code>; since <code>position() lt NaN</code> is always false, the result is
            an empty sequence.</p>
         <p>The reason the function accepts arguments of type <code>xs:double</code> is that many
            computations on untyped data return an <code>xs:double</code> result; and the reason for
            the rounding rules is to compensate for any imprecision in these floating-point
            computations.</p>
      </fos:notes>

      <fos:examples>
         <fos:variable name="seq"
            select="(&quot;item1&quot;, &quot;item2&quot;, &quot;item3&quot;, &quot;item4&quot;, &quot;item5&quot;)"/>
         <fos:example>
            <fos:test>
               <fos:expression>fn:subsequence($seq, 4)</fos:expression>
               <fos:result>("item4", "item5")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:subsequence($seq, 3, 2)</fos:expression>
               <fos:result>("item3", "item4")</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="unordered">
      <fos:signatures>
         <fos:proto name="unordered" return-type="item()*">
            <fos:arg name="sourceSeq" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the items of <code>$sourceSeq</code> in an <termref
               def="implementation-dependent"/> order.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the items of <code>$sourceSeq</code> in an <termref
               def="implementation-dependent"/> order.</p>
      </fos:rules>
      <fos:notes>
         <p>Query optimizers may be able to do a better job if the order of the output sequence is
            not specified. For example, when retrieving prices from a purchase order, if an index
            exists on prices, it may be more efficient to return the prices in index order rather
            than in document order.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:unordered((1, 2, 3, 4, 5))</fos:expression>
               <fos:result allow-permutation="true">(1, 2, 3, 4, 5)</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="zero-or-one">
      <fos:signatures>
         <fos:proto name="zero-or-one" return-type="item()?">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns <code>$arg</code> if it contains zero or one items. Otherwise, raises
            an error.</p>
      </fos:summary>
      <fos:rules>
         <p>Except in error cases, the function returns <code>$arg</code> unchanged.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RG" code="0003"/> if <code>$arg</code> contains more
            than one item.</p>
      </fos:errors>
   </fos:function>
   <fos:function name="one-or-more">
      <fos:signatures>
         <fos:proto name="one-or-more" return-type="item()+">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns <code>$arg</code> if it contains one or more items. Otherwise, raises
            an error. </p>
      </fos:summary>
      <fos:rules>
         <p>Except in error cases, the function returns <code>$arg</code> unchanged.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RG" code="0004"/> if <code>$arg</code> is an empty
            sequence.</p>
      </fos:errors>
   </fos:function>
   <fos:function name="exactly-one">
      <fos:signatures>
         <fos:proto name="exactly-one" return-type="item()">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns <code>$arg</code> if it contains exactly one item. Otherwise, raises an
            error. </p>
      </fos:summary>
      <fos:rules>
         <p>Except in error cases, the function returns <code>$arg</code> unchanged.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="RG" code="0005"/> if <code>$arg</code> is an empty
            sequence or a sequence containing more than one item.</p>
      </fos:errors>
   </fos:function>
   <fos:function name="deep-equal">
      <fos:signatures>
         <fos:proto name="deep-equal" return-type="xs:boolean">
            <fos:arg name="parameter1" type="item()*"/>
            <fos:arg name="parameter2" type="item()*"/>
         </fos:proto>
         <fos:proto name="deep-equal" return-type="xs:boolean">
            <fos:arg name="parameter1" type="item()*"/>
            <fos:arg name="parameter2" type="item()*"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="3">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations static-base-uri implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p> This function assesses whether two sequences are deep-equal to each other. To
            be deep-equal, they must contain items that are pairwise deep-equal; and for two items
            to be deep-equal, they must either be atomic values that compare equal, or nodes of the
            same kind, with the same name, whose children are deep-equal.</p>
      </fos:summary>
      <fos:rules>
         <p>The <code>$collation</code> argument identifies a collation which is used at all levels
            of recursion when strings are compared (but not when names are compared), according to
            the rules in <specref ref="choosing-a-collation"/>.</p>
         <p>If the two sequences are both empty, the function returns <code>true</code>.</p>
         <p>If the two sequences are of different lengths, the function returns
            <code>false</code>.</p>
         <p>If the two sequences are of the same length, the function returns <code>true</code> if
            and only if every item in the sequence <code>$parameter1</code> is deep-equal to the
            item at the same position in the sequence <code>$parameter2</code>. The rules for
            deciding whether two items are deep-equal follow.</p>

         <p>Call the two items <code>$i1</code> and <code>$i2</code> respectively.</p>
         <p>If <code>$i1</code> and <code>$i2</code> are both atomic values, they are deep-equal if
            and only if <code>($i1 eq $i2)</code> is <code>true</code>, or if both values are
               <code>NaN</code>. If the <code>eq</code> operator is not defined for <code>$i1</code>
            and <code>$i2</code>, the function returns <code>false</code>.</p>
         <p> If one of the pair <code>$i1</code> or <code>$i2</code> is an atomic value and the
            other is not,
            <!--<phrase diff="add" at="MAP">or if one is a node and the other is not, </phrase>-->
            the function returns <code>false</code>.</p>
         <!--<p diff="add" at="MAP">If <code>$i1</code> and <code>$i2</code> are both <termref def="dt-map">maps</termref>,
         the result is <code>true</code> if and only if all the following conditions apply:</p>
         <olist diff="add" at="MAP">
            <item><p>Both maps have the same number of entries.</p></item>
            <item><p>Both maps have the same collation.</p></item>
            <item><p>For every entry in the first map, there is an entry in the second map that:</p>
               <olist>
                  <item><p>has the same key (compared using the <code>eq</code> 
                  operator under the maps' collation), and </p></item>
                  <item><p>has the same associated value (compared using the <code>fn:deep-equal</code>
                  function, under the collation supplied in the original call to <code>fn:deep-equal</code>).</p></item>
               </olist>
            </item>
         </olist>-->
         <p>If <code>$i1</code> and <code>$i2</code> are both nodes, they are compared as described
            below:</p>
         <olist>
            <item>
               <p>If the two nodes are of different kinds, the result is <code>false</code>.</p>
            </item>
            <item>
               <p>If the two nodes are both document nodes then they are deep-equal if and only if
                  the sequence <code>$i1/(*|text())</code> is deep-equal to the sequence
                     <code>$i2/(*|text())</code>.</p>
            </item>
            <item>
               <p> If the two nodes are both element nodes then they are deep-equal if and only if
                  all of the following conditions are satisfied:</p>
               <olist>
                  <item>
                     <p>The two nodes have the same name, that is <code>(node-name($i1) eq
                           node-name($i2))</code>.</p>
                  </item>
                  <item>
                     <!-- bug 17252 -->
                     <p diff="chg" at="L">Either both nodes are both annotated as having simple content or both nodes are
                        annotated as having complex content. For this purpose "simple content" means either a simple
                     type or a complex type with simple content; "complex content" means a complex type whose variety
                     is mixed, element-only, or empty.</p>
                     <note diff="add" at="L"><p>It is a consequence of this rule that validating a document
                     <var>D</var> against a schema will usually (but not necessarily) result in a document that is not deep-equal
                        to <var>D</var>. The exception is when the schema allows all elements to have mixed content.</p></note>
                  </item>
                  <item>
                     <p>The two nodes have the same number of attributes, and for every attribute
                           <code>$a1</code> in <code>$i1/@*</code> there exists an attribute
                           <code>$a2</code> in <code>$i2/@*</code> such that <code>$a1</code> and
                           <code>$a2</code> are deep-equal.</p>
                  </item>
                  <item>
                     <p> One of the following conditions holds:</p>
                     <ulist>
                        <item>
                           <p>Both element nodes are annotated as having simple content 
                              <phrase diff="add" at="L">(as defined in 3(b) above)</phrase>, and
                              the typed value of <code>$i1</code> is deep-equal to the typed value
                              of <code>$i2</code>.</p>
                        </item>
                        <item>
                           <p>Both element nodes have a type annotation that is <phrase diff="chg" at="L">a complex type with
                              variety element-only, and the sequence <code>$i1/*</code> is
                              deep-equal to the sequence <code>$i2/*</code>.</phrase></p>
                        </item>
                        <item>
                           <p>Both element nodes have a type annotation that is <phrase diff="chg" at="L">a complex type with
                              variety mixed</phrase>, and the sequence <code>$i1/(*|text())</code> is
                              deep-equal to the sequence <code>$i2/(*|text())</code>.</p>
                        </item>
                        <item>
                           <p>Both element nodes have a type annotation that is <phrase diff="chg" at="L">a complex type with
                              variety empty</phrase>.</p>
                        </item>
                     </ulist>
                  </item>
               </olist>
            </item>
            <item>
               <p>If the two nodes are both attribute nodes then they are deep-equal if and only if
                  both the following conditions are satisfied:</p>
               <olist>
                  <item>
                     <p>The two nodes have the same name, that is <code>(node-name($i1) eq
                           node-name($i2))</code>.</p>
                  </item>
                  <item>
                     <p>The typed value of <code>$i1</code> is deep-equal to the typed value of
                           <code>$i2</code>.</p>
                  </item>
               </olist>
            </item>
            <item>
               <p> If the two nodes are both processing instruction nodes<phrase diff="del"
                     at="A-E42"> or namespace bindings</phrase>, then they are deep-equal if and
                  only if both the following conditions are satisfied:</p>
               <olist>
                  <item>
                     <p>The two nodes have the same name, that is <code>(node-name($i1) eq
                           node-name($i2))</code>.</p>
                  </item>
                  <item>
                     <p>The string value of <code>$i1</code> is equal to the string value of
                           <code>$i2</code>.</p>
                  </item>
               </olist>
            </item>
            <item>
               <p diff="add" at="A-E42"> If the two nodes are both namespace nodes, then they are deep-equal if and only
                  if both the following conditions are satisfied:</p>
               <olist>
                  <item>
                     <p diff="add" at="A-E42">The two nodes either have the same name or are both nameless, that is
                           <code>fn:deep-equal(node-name($i1), node-name($i2))</code>.</p>
                  </item>
                  <item>
                     <p diff="add" at="A-E42">The string value of <code>$i1</code> is equal to the string value of
                           <code>$i2</code> when compared using the Unicode codepoint collation.</p>
                  </item>
               </olist>
            </item>
            <item>
               <p>If the two nodes are both text nodes or comment nodes, then they are deep-equal if
                  and only if their string-values are equal.</p>
            </item>
         </olist>
      </fos:rules>
      <fos:errors>
         <p diff="add" at="B">A <phrase diff="add" at="L">type</phrase> error is raised <errorref class="TY" code="0015" type="type"/> 
            if either input sequence contains a function item.
            <!--<phrase diff="add" at="MAP">that is not a map</phrase>,-->
         </p>
      </fos:errors>
      <fos:notes>
         <p> The two nodes are not required to have the same type annotation, and they are not
            required to have the same in-scope namespaces. They may also differ in their parent,
            their base URI, and the values returned by the <code>is-id</code> and
               <code>is-idrefs</code> accessors (see <xspecref spec="DM30" ref="dm-is-id"/> and
               <xspecref spec="DM30" ref="dm-is-idrefs"/>). The order of children is significant,
            but the order of attributes is insignificant. </p>
         <p> The contents of comments and processing instructions are significant only if these
            nodes appear directly as items in the two sequences being compared. The content of a
            comment or processing instruction that appears as a descendant of an item in one of the
            sequences being compared does not affect the result. However, the presence of a comment
            or processing instruction, if it causes a text node to be split into two text nodes, may
            affect the result.</p>
         <p> The result of <code>fn:deep-equal(1, current-dateTime())</code> is <code>false</code>;
            it does not raise an error.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="at" as="element()">&lt;attendees&gt; &lt;name last='Parker'
            first='Peter'/&gt; &lt;name last='Barker' first='Bob'/&gt; &lt;name last='Parker'
            first='Peter'/&gt; &lt;/attendees&gt;</fos:variable>
         <fos:example>
            <fos:test>
               <fos:expression>fn:deep-equal($at, $at/*)</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:deep-equal($at/name[1], $at/name[2])</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:deep-equal($at/name[1], $at/name[3])</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:deep-equal($at/name[1], 'Peter Parker')</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="union" prefix="op">
      <fos:signatures>
         <fos:proto name="union" return-type="node()*">
            <fos:arg name="arg1" type="node()*"/>
            <fos:arg name="arg2" type="node()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="union" types="numeric" other-operators="|">Defines the semantics of the
         "union" or "|" operator.</fos:opermap>
      <fos:summary>
         <p>Constructs a sequence containing every node that occurs in the values of either
               <code>$arg1</code> or <code>$arg2</code>, eliminating duplicates and sorting the
            result in document order.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence containing every node that occurs in the values of
            either <code>$arg1</code> or <code>$arg2</code>, eliminating duplicate nodes. Nodes are
            returned in document order.</p>
         <p>Two nodes <code>$n1</code> and <code>$n2</code> are duplicates if they satisfy
               <code>op:is-same-node($n1, $n2)</code>.</p>

         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>If either operand is the empty sequence, the result is a sequence containing the nodes
            in the other operand in document order after eliminating duplicates.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="seq1" select="($item1, $item2)"/>
         <fos:variable name="seq2" select="($item2, $item2, $item1)"/>
         <fos:variable name="seq3" select="($item2, $item3)"/>
         <fos:example>
            <fos:test>
               <fos:expression>op:union($seq1, $seq1)</fos:expression>
               <fos:result>($item1, $item2)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:union($seq2, $seq3)</fos:expression>
               <fos:result>($item1, $item2, $item3)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:union($seq2, ())</fos:expression>
               <fos:result>($item1, $item2)</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="intersect" prefix="op">
      <fos:signatures>
         <fos:proto name="intersect" return-type="node()*">
            <fos:arg name="arg1" type="node()*"/>
            <fos:arg name="arg2" type="node()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="intersect" types="numeric">Defines the semantics of the "intersect"
         operator.</fos:opermap>
      <fos:summary>
         <p>Constructs a sequence containing every node that occurs in the values of both
               <code>$arg1</code> and <code>$arg2</code>, eliminating duplicates and sorting the
            result in document order.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence containing every node that occurs in the values of both
               <code>$arg1</code> and <code>$arg2</code>, eliminating duplicate nodes. Nodes are
            returned in document order.</p>
         <p>Two nodes <code>$n1</code> and <code>$n2</code> are duplicates if they satisfy
               <code>op:is-same-node($n1, $n2)</code>.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>If either operand is the empty sequence, the function returns the empty sequence.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="seq1" select="($item1, $item2)"/>
         <fos:variable name="seq2" select="($item2, $item2, $item1)"/>
         <fos:variable name="seq3" select="($item2, $item3)"/>
         <fos:example>
            <fos:test>
               <fos:expression>op:intersect($seq1, $seq1)</fos:expression>
               <fos:result>($item1, $item2)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:intersect($seq2, $seq3)</fos:expression>
               <fos:result>($item2)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:intersect($seq2, ())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:intersect($item1, $item3)</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="except" prefix="op">
      <fos:signatures>
         <fos:proto name="except" return-type="node()*">
            <fos:arg name="arg1" type="node()*"/>
            <fos:arg name="arg2" type="node()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="except" types="numeric">Defines the semantics of the "except"
         operator.</fos:opermap>
      <fos:summary>
         <p>Constructs a sequence containing every node that occurs in the value of
               <code>$arg1</code> but not in the value of <code>$arg2</code>, eliminating duplicates
            and sorting the result in document order.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence containing every node that occurs in the value of
               <code>$arg1</code> provided that it does not occur in the value of
            <code>$arg2</code>. Duplicate nodes are eliminated, and nodes are returned in document
            order.</p>
         <p>Two nodes <code>$n1</code> and <code>$n2</code> are duplicates if they satisfy
               <code>op:is-same-node($n1, $n2)</code>.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:notes>
         <p>If <code>$arg1</code> is the empty sequence, the empty sequence is returned.</p>
         <p>If <code>$arg2</code> is the empty sequence, a sequence is returned containing the nodes
            in <code>$arg1</code> in document order after eliminating duplicates.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="seq1" select="($item1, $item2)"/>
         <fos:variable name="seq2" select="($item2, $item2, $item1)"/>
         <fos:variable name="seq3" select="($item2, $item3)"/>
         <fos:example>
            <fos:test>
               <fos:expression>op:except($seq1, $seq1)</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:except($seq2, $seq1)</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:except($seq2, $seq3)</fos:expression>
               <fos:result>($item1)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:except($seq2, ())</fos:expression>
               <fos:result>($item1, $item2)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>op:except($seq3, $seq2)</fos:expression>
               <fos:result>($item3)</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="count">
      <fos:signatures>
         <fos:proto name="count" return-type="xs:integer">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the number of items in a sequence.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the number of items in the value of <code>$arg</code>.</p>
      </fos:rules>
      <fos:notes>
         <p>Returns 0 if <code>$arg</code> is the empty sequence.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="seq1" select="($item1, $item2)"/>
         <fos:variable name="seq2" select="(98.5, 98.3, 98.9)"/>
         <fos:variable name="seq3" select="()"/>
         <fos:example>
            <fos:test>
               <fos:expression>fn:count($seq1)</fos:expression>
               <fos:result>2</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:count($seq3)</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:count($seq2)</fos:expression>
               <fos:result>3</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:count($seq2[. &gt; 100])</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="avg">
      <fos:signatures>
         <fos:proto name="avg" return-type="xs:anyAtomicType?">
            <fos:arg name="arg" type="xs:anyAtomicType*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the average of the values in the input sequence <code>$arg</code>, that
            is, the sum of the values divided by the number of values.</p>
      </fos:summary>
      <fos:rules>

         <p>If <code>$arg</code> is the empty sequence, the empty sequence is returned.</p>
         <p>If <code>$arg</code> contains values of type <code>xs:untypedAtomic</code> they are cast
            to <code>xs:double</code>. </p>
         <p>Duration values must either all be <code>xs:yearMonthDuration</code> values or must all
            be <code>xs:dayTimeDuration</code> values. For numeric values, the numeric promotion
            rules defined in <specref ref="op.numeric"/> are used to promote all values to a single
            common type. After these operations, <code>$arg</code> must contain items of a single
            type, which must be one of the four numeric types, <code>xs:yearMonthDuration</code> or
               <code>xs:dayTimeDuration</code> or one if its subtypes.</p>

         <p>The function returns the average of the values as <code>sum($arg) div
            count($arg)</code>; but the implementation may use an otherwise equivalent algorithm
            that avoids arithmetic overflow.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:errors>
         <p>A type error is raised <errorref class="RG" code="0006"/> if the input sequence contains
            items of incompatible types, as described above.</p>
      </fos:errors>
      <fos:examples>
         <fos:variable name="d1" select="xs:yearMonthDuration(&quot;P20Y&quot;)"/>
         <fos:variable name="d2" select="xs:yearMonthDuration(&quot;P10M&quot;)"/>
         <fos:variable name="seq3" select="(3, 4, 5)"/>
         <fos:example>
            <fos:test>
               <fos:expression>fn:avg($seq3)</fos:expression>
               <fos:result>4.0</fos:result>
               <fos:postamble>The result is of type <code>xs:decimal</code>.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:avg(($d1, $d2))</fos:expression>
               <fos:result>xs:yearMonthDuration("P10Y5M")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p><code>fn:avg(($d1, $seq3))</code> raises a type error <errorref class="RG"
                  code="0006"/>. </p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:avg(())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:avg((xs:float('INF'), xs:float('-INF')))</fos:expression>
               <fos:result>xs:float('NaN')</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:avg(($seq3, xs:float('NaN')))</fos:expression>
               <fos:result>xs:float('NaN')</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="max">
      <fos:signatures>
         <fos:proto name="max" return-type="xs:anyAtomicType?">
            <fos:arg name="arg" type="xs:anyAtomicType*"/>
         </fos:proto>
         <fos:proto name="max" return-type="xs:anyAtomicType?">
            <fos:arg name="arg" type="xs:anyAtomicType*"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations static-base-uri implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a value that is equal to the highest value appearing in the input
            sequence.</p>
      </fos:summary>
      <fos:rules>
         <p>The following rules are applied to the input sequence <code>$arg</code>:</p>
         <ulist>
            <item>
               <p>Values of type <code>xs:untypedAtomic</code> in <code>$arg</code> are cast to
                     <code>xs:double</code>.</p>
            </item>
            <item>
               <!--Text replaced by erratum E27 change 1"-->
               <p diff="chg" at="A-E27">Numeric and <code>xs:anyURI</code> values are converted to
                  the least common type reachable by a combination of type promotion and subtype
                  substitution. See <xspecref spec="XP30" ref="promotion"/> and <xspecref
                     spec="XP30" ref="mapping"/>.</p>
               <!--End of text replaced by erratum E27-->
            </item>
         </ulist>
         <p>The items in the resulting sequence may be reordered in an arbitrary order. The
            resulting sequence is referred to below as the converted sequence. The function returns
            an item from the converted sequence rather than the input sequence. </p>
         <p>If the converted sequence is empty, the function returns the empty sequence.</p>
         <p>All items in the <phrase diff="chg" at="A-E47">converted sequence must be
               derived</phrase> from a single base type for which the <code>le</code> operator is
            defined. In addition, the values in the sequence must have a total order. If date/time
            values do not have a timezone, they are considered to have the implicit timezone
            provided by the dynamic context for the purpose of comparison. Duration values must
            either all be <code>xs:yearMonthDuration</code> values or must all be
               <code>xs:dayTimeDuration</code> values.</p>
         <p>If the converted sequence contains the value <code>NaN</code>, the value
               <code>NaN</code> is returned.</p>
         <p>If the items in the <phrase diff="chg" at="A-E47">converted sequence</phrase> are of
            type <code>xs:string</code> or types derived by restriction from <code>xs:string</code>,
            then the determination of the item with the smallest value is made according to the
            collation that is used. If the type of the items in the <phrase diff="chg" at="A-E47"
               >converted sequence</phrase> is not <code>xs:string</code> and
               <code>$collation</code> is specified, the collation is ignored.</p>
         <p>The collation used by this function is determined according to the rules in <specref
               ref="choosing-a-collation"/>.</p>
         <p>The function returns the result of the expression:</p>
         <eg xml:space="preserve">
   if (every $v in $c satisfies $c[1] ge $v)
   then $c[1] 
   else fn:max(fn:subsequence($c, 2))</eg>
         <p>evaluated with <code>$collation</code> as the default collation if specified, and with
               <code>$c</code> as the converted sequence.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:errors>
         <p>A type error is raised <errorref class="RG" code="0006"/> if the input sequence contains
            items of incompatible types, as described above.</p>
      </fos:errors>
      <fos:notes>
         <p>Because the rules allow the sequence to be reordered, if there are two or items that are
            "equal highest", the specific item whose value is returned is <termref
               def="implementation-dependent"/>. This can arise for example if two different strings
            compare equal under the selected collation, or if two different <code>xs:dateTime</code>
            values compare equal despite being in different timezones.</p>
         <p>If the converted sequence contains exactly one value then that value is returned.</p>
         <p>The default type when the <code>fn:max</code> function is applied to
               <code>xs:untypedAtomic</code> values is <code>xs:double</code>. This differs from the
            default type for operators such as <code>gt</code>, and for sorting in XQuery and XSLT,
            which is <code>xs:string</code>.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:max((3,4,5))</fos:expression>
               <fos:result>5</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:max((xs:integer(5), xs:float(5.0), xs:double(0)))</fos:expression>
               <fos:result>xs:double(5.0e0)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p><code>fn:max((3,4,"Zero"))</code> raises a type error <errorref class="RG"
                  code="0006"/>. </p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:max((fn:current-date(), xs:date("2100-01-01")))</fos:expression>
               <fos:result>xs:date("2100-01-01")</fos:result>
               <fos:postamble>Assuming that the current date is during the 21st
                  century.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:max(("a", "b", "c"))</fos:expression>
               <fos:result>"c"</fos:result>
               <fos:postamble>Assuming a typical default collation.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="min">
      <fos:signatures>
         <fos:proto name="min" return-type="xs:anyAtomicType?">
            <fos:arg name="arg" type="xs:anyAtomicType*"/>
         </fos:proto>
         <fos:proto name="min" return-type="xs:anyAtomicType?">
            <fos:arg name="arg" type="xs:anyAtomicType*"/>
            <fos:arg name="collation" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations static-base-uri implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a value that is equal to the lowest value appearing in the input
            sequence.</p>
      </fos:summary>
      <fos:rules>
         <p>The following rules are applied to the input sequence:</p>
         <ulist>
            <item>
               <p>Values of type <code>xs:untypedAtomic</code> in <code>$arg</code> are cast to
                     <code>xs:double</code>.</p>
            </item>
            <item>
               <!--Text replaced by erratum E27 change 2"-->
               <p diff="chg" at="A-E27">Numeric and <code>xs:anyURI</code> values are converted to
                  the least common type reachable by a combination of type promotion and subtype
                  substitution. See <xspecref spec="XP30" ref="promotion"/> and <xspecref
                     spec="XP30" ref="mapping"/>.</p>
               <!--End of text replaced by erratum E27-->
            </item>
         </ulist>
         <p>The items in the resulting sequence may be reordered in an arbitrary order. The
            resulting sequence is referred to below as the converted sequence. The function returns
            an item from the converted sequence rather than the input sequence. </p>
         <p>If the converted sequence is empty, the empty sequence is returned.</p>
         <p>All items in the <phrase diff="chg" at="A-E47">converted sequence must be
               derived</phrase> from a single base type for which the <code>le</code> operator is
            defined. In addition, the values in the sequence must have a total order. If date/time
            values do not have a timezone, they are considered to have the implicit timezone
            provided by the dynamic context for the purpose of comparison. Duration values must
            either all be <code>xs:yearMonthDuration</code> values or must all be
               <code>xs:dayTimeDuration</code> values.</p>
         <p>If the converted sequence contains the value <code>NaN</code>, the value
               <code>NaN</code> is returned.</p>
         <p>If the items in the <phrase diff="chg" at="A-E47">converted sequence</phrase> are of
            type <code>xs:string</code> or types derived by restriction from <code>xs:string</code>,
            then the determination of the item with the smallest value is made according to the
            collation that is used. If the type of the items in the <phrase diff="chg" at="A-E47"
               >converted sequence</phrase> is not <code>xs:string</code> and
               <code>$collation</code> is specified, the collation is ignored.</p>
         <p>The collation used by this function is determined according to the rules in <specref
               ref="choosing-a-collation"/>.</p>
         <p>The function returns the result of the expression:</p>
         <eg xml:space="preserve">
   if (every $v in $c satisfies $c[1] le $v) 
   then $c[1] 
   else fn:min(fn:subsequence($c, 2))</eg>
         <p>evaluated with <code>$collation</code> as the default collation if specified, and with
               <code>$c</code> as the converted sequence.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:errors>
         <p>A type error is raised <errorref class="RG" code="0006"/> if the input sequence contains
            items of incompatible types, as described above.</p>
      </fos:errors>
      <fos:notes>
         <p>Because the rules allow the sequence to be reordered, if there are two or items that are
            "equal lowest", the specific item whose value is returned is <termref
               def="implementation-dependent"/>. This can arise for example if two different strings
            compare equal under the selected collation, or if two different <code>xs:dateTime</code>
            values compare equal despite being in different timezones.</p>
         <p>If the converted sequence contains exactly one value then that value is returned.</p>
         <p>The default type when the <code>fn:min</code> function is applied to
               <code>xs:untypedAtomic</code> values is <code>xs:double</code>. This differs from the
            default type for operators such as <code>lt</code>, and for sorting in XQuery and XSLT,
            which is <code>xs:string</code>.</p>

      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:min((3,4,5))</fos:expression>
               <fos:result>3</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:min((xs:integer(5), xs:float(5), xs:double(10)))</fos:expression>
               <fos:result>xs:double(5.0e0)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p><code>fn:min((3,4,"Zero"))</code> raises a type error <errorref class="RG"
                  code="0006"/>. </p>
         </fos:example>
         <fos:example>
            <p><code>fn:min((xs:float(0.0E0), xs:float(-0.0E0)))</code> can return either positive
               or negative zero. <phrase diff="chg" at="F">The two items are equal, so it is
                     <termref def="implementation-dependent"/> which is returned.</phrase></p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:min((fn:current-date(), xs:date("1900-01-01")))</fos:expression>
               <fos:result>xs:date("1900-01-01")</fos:result>
               <fos:postamble>Assuming that the current date is set to a reasonable
                  value.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:min(("a", "b", "c"))</fos:expression>
               <fos:result>"a"</fos:result>
               <fos:postamble>Assuming a typical default collation.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="sum">
      <fos:signatures>
         <fos:proto name="sum" return-type="xs:anyAtomicType">
            <fos:arg name="arg" type="xs:anyAtomicType*"/>
         </fos:proto>
         <fos:proto name="sum" return-type="xs:anyAtomicType?">
            <fos:arg name="arg" type="xs:anyAtomicType*"/>
            <fos:arg name="zero" type="xs:anyAtomicType?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a value obtained by adding together the values in
            <code>$arg</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>Any values of type <code>xs:untypedAtomic</code> in <code>$arg</code> are cast to
               <code>xs:double</code>. The items in the resulting sequence may be reordered in an
            arbitrary order. The resulting sequence is referred to below as the converted
            sequence.</p>
         <p>If the converted sequence is empty, then the single-argument form of the function
            returns the <code>xs:integer</code> value <code>0</code>; the two-argument form returns
            the value of the argument <code>$zero</code>.</p>
         <p>If the converted sequence contains the value <code>NaN</code>, <code>NaN</code> is
            returned.</p>
         <p>All items in <code>$arg</code> must be numeric or derived from a single base type. In
            addition, the type must support addition. Duration values must either all be
               <code>xs:yearMonthDuration</code> values or must all be
               <code>xs:dayTimeDuration</code> values. For numeric values, the numeric promotion
            rules defined in <specref ref="op.numeric"/> are used to promote all values to a single
            common type. The sum of a sequence of integers will therefore be an integer, while the
            sum of a numeric sequence that includes at least one <code>xs:double</code> will be an
               <code>xs:double</code>. </p>
         <p>The result of the function, using the second signature, is the result of the
            expression:</p>
         <eg xml:space="preserve">
if (fn:count($c) eq 0) then
    $zero
else if (fn:count($c) eq 1) then
    $c[1]
else
    $c[1] + fn:sum(subsequence($c, 2))</eg>
         <p>where <code>$c</code> is the converted sequence.</p>
         <p>The result of the function, using the first signature, is the result of the expression:
               <code>fn:sum($arg, 0)</code>.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:errors>
         <p>A type error is raised <errorref class="RG" code="0006"/> if the input sequence contains
            items of incompatible types, as described above.</p>

      </fos:errors>
      <fos:notes>
         <p>The second argument allows an appropriate value to be defined to represent the sum of an
            empty sequence. For example, when summing a sequence of durations it would be
            appropriate to return a zero-length duration of the appropriate type. This argument is
            necessary because a system that does dynamic typing cannot distinguish "an empty
            sequence of integers", for example, from "an empty sequence of durations".</p>
         <p> If the converted sequence contains exactly one value then that value is returned.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="d1" select="xs:yearMonthDuration(&quot;P20Y&quot;)"/>
         <fos:variable name="d2" select="xs:yearMonthDuration(&quot;P10M&quot;)"/>
         <fos:variable name="seq1" select="($d1, $d2)"/>
         <fos:variable name="seq3" select="(3, 4, 5)"/>
         <fos:example>
            <fos:test>
               <fos:expression>fn:sum(($d1, $d2))</fos:expression>
               <fos:result>xs:yearMonthDuration("P20Y10M")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:sum($seq1[. lt xs:yearMonthDuration('P3M')],
                  xs:yearMonthDuration('P0M'))</fos:expression>
               <fos:result>xs:yearMonthDuration("P0M")</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:sum($seq3)</fos:expression>
               <fos:result>12</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:sum(())</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:sum((),())</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:sum((1 to 100)[. lt 0], 0) </fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <p><code>fn:sum(($d1, 9E1))</code> raises a <phrase diff="add" at="L">type</phrase> error <errorref class="RG" code="0006"/>.
            </p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:sum(($d1, $d2), "ein Augenblick")</fos:expression>
               <fos:result>xs:yearMonthDuration("P20Y10M")</fos:result>
               <fos:postamble>There is no requirement that the <code>$zero</code> value should be
                  the same type as the items in <code>$arg</code>, or even that it should belong to
                  a type that supports addition.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="to" prefix="op">
      <fos:signatures>
         <fos:proto name="to" return-type="xs:integer*">
            <fos:arg name="firstval" type="xs:integer"/>
            <fos:arg name="lastval" type="xs:integer"/>
         </fos:proto>
      </fos:signatures>
      <fos:opermap operator="to" types="numeric">Defines the semantics of the "to"
         operator.</fos:opermap>
      <fos:summary>
         <p>Returns a sequence of consecutive integers in a given range.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the sequence containing every <code>xs:integer</code> whose value
            is between the value of <code>$firstval</code> (inclusive) and the value of
               <code>$lastval</code> (inclusive), in monotonic increasing order.</p>
         <p>If the value of the first operand is greater than the value of the second, the function
            returns the empty sequence.</p>
         <p>If the values of the two operands are equal, the function returns a sequence containing
            a single <code>xs:integer</code> equal to that value.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>1 to 3</fos:expression>
               <fos:result>(1, 2, 3)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>3 to 1</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>5 to 5</fos:expression>
               <fos:result>5</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="id">
      <fos:signatures>
         <fos:proto name="id" return-type="element()*">
            <fos:arg name="arg" type="xs:string*"/>
         </fos:proto>
         <fos:proto name="id" return-type="element()*">
            <fos:arg name="arg" type="xs:string*"/>
            <fos:arg name="node" type="node()"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the sequence of element nodes that have an <code>ID</code> value
            matching the value of one or more of the <code>IDREF</code> values supplied in
               <code>$arg</code>.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence, in document order with duplicates eliminated,
            containing every element node <code>E</code> that satisfies all the following
            conditions:</p>
         <olist>
            <item>
               <p>
                  <code>E</code> is in the target document. The target document is the document
                  containing <code>$node</code>, or the document containing the context item
                     (<code>.</code>) if the second argument is omitted. The behavior of the
                  function if <code>$node</code> is omitted is exactly the same as if the context
                  item had been passed as <code>$node</code>.</p>
            </item>
            <item>
               <p><code>E</code> has an <code>ID</code> value equal to one of the candidate
                     <code>IDREF</code> values, where:</p>
               <ulist>
                  <item>
                     <p> An element has an <code>ID</code> value equal to <code>V</code> if either
                        or both of the following conditions are true:</p>
                     <ulist>
                        <item>
                           <p>The <code>is-id</code> property (See <xspecref spec="DM30"
                                 ref="dm-is-id"/>.) of the element node is true, and the typed value
                              of the element node is equal to V under the rules of the
                                 <code>eq</code> operator using the Unicode codepoint collation
                                 (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>).</p>
                        </item>
                        <item>
                           <p>The element has an attribute node whose <code>is-id</code> property
                              (See <xspecref spec="DM30" ref="dm-is-id"/>.) is true and whose typed
                              value is equal to <code>V</code> under the rules of the
                                 <code>eq</code> operator using the Unicode code point collation
                                 (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>).</p>
                        </item>
                     </ulist>
                  </item>
                  <item>
                     <p> Each <code>xs:string</code> in <code>$arg</code> is parsed as if it were of
                        type <code>IDREFS</code>, that is, each <code>xs:string</code> in
                           <code>$arg</code> is treated as a whitespace-separated sequence of
                        tokens, each acting as an <code>IDREF</code>. These tokens are then included
                        in the list of candidate <code>IDREF</code>s. If any of the tokens is not a
                        lexically valid <code>IDREF</code> (that is, if it is not lexically an
                           <code>xs:NCName</code>), it is ignored. Formally, the candidate
                           <code>IDREF</code> values are the strings in the sequence given by the
                        expression:</p>
                     <eg xml:space="preserve">for $s in $arg return 
    fn:tokenize(fn:normalize-space($s), ' ')[. castable as xs:IDREF]</eg>

                  </item>
               </ulist>
            </item>
            <item>
               <p>If several elements have the same <code>ID</code> value, then <code>E</code> is
                  the one that is first in document order.</p>
            </item>
         </olist>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DC" code="0001" type="dynamic"/> if
               <code>$node</code>, or the context item if the second argument is absent, is a node
            in a tree whose root is not a document node.</p>
         <p>If the second argument is the context item, or is omitted, the following <phrase diff="add" at="L">type</phrase> errors may be
            raised: if the context item is <xtermref ref="dt-absent" spec="DM30">absent</xtermref>,
               <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not
            a node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
      </fos:errors>
      <fos:notes>
         <p diff="chg" at="A-E31">The effect of this function is anomalous in respect of element
            nodes with the <code>is-id</code> property. For legacy reasons, this function returns
            the element that has the <code>is-id</code> property, whereas it would be more
            appropriate to return its parent, that being the element that is uniquely identified by
            the ID. A new function <function>element-with-id</function> is being introduced with the
            desired behavior.</p>

         <p> If the data model is constructed from an Infoset, an attribute will have the
               <code>is-id</code> property if the corresponding attribute in the Infoset had an
            attribute type of <code>ID</code>: typically this means the attribute was declared as an
               <code>ID</code> in a DTD.</p>
         <!--Text replaced by erratum E13 change 1"-->
         <p diff="chg" at="A-E13"> If the data model is constructed from a PSVI, an element or
            attribute will have the <code>is-id</code> property if its typed value is a single
            atomic value of type <code>xs:ID</code> or a type derived by restriction from
               <code>xs:ID</code>.</p>
         <!--End of text replaced by erratum E13-->
         <p> No error is raised in respect of a candidate <code>IDREF</code> value that does not
            match the <code>ID</code> of any element in the document. If no candidate
               <code>IDREF</code> value matches the <code>ID</code> value of any element, the
            function returns the empty sequence.</p>
         <p> It is not necessary that the supplied argument should have type <code>xs:IDREF</code>
            or <code>xs:IDREFS</code>, or that it should be derived from a node with the
               <code>is-idrefs</code> property.</p>
         <p> An element may have more than one <code>ID</code> value. This can occur with synthetic
            data models or with data models constructed from a PSVI where the element and one of its
            attributes are both typed as <code>xs:ID</code>.</p>
         <p> If the source document is well-formed but not valid, it is possible for two or more
            elements to have the same <code>ID</code> value. In this situation, the function will
            select the first such element.</p>
         <p> It is also possible in a well-formed but invalid document to have an element or
            attribute that has the <code>is-id</code> property but whose value does not conform to
            the lexical rules for the <code>xs:ID</code> type. Such a node will never be selected by
            this function.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="emp" as="element()"><![CDATA[
            <employee xml:id="ID21256">
               <empnr>E21256</empnr>
               <first>John</first>
               <last>Brown</last>
            </employee>]]>
         </fos:variable>
         <fos:example>
            <fos:test xslt-version="3.0">
               <fos:expression>id('ID21256')/name()</fos:expression>
               <fos:result>employee</fos:result>
               <fos:postamble>The <code>xml:id</code> attribute has the <code>is-id</code> property,
                  so the employee element is selected.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test xslt-version="3.0">
               <fos:expression>id('E21256')/name()</fos:expression>
               <fos:result>empnr</fos:result>
               <fos:postamble>Assuming the <code>empnr</code> element is given the type
                     <code>xs:ID</code> as a result of schema validation, the element will have the
                     <code>is-id</code> property and is therefore selected. Note the difference from
                  the behavior of <code>fn:element-with-id</code>.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="element-with-id">
      <fos:signatures>
         <fos:proto name="element-with-id" return-type="element()*">
            <fos:arg name="arg" type="xs:string*"/>
         </fos:proto>
         <fos:proto name="element-with-id" return-type="element()*">
            <fos:arg name="arg" type="xs:string*"/>
            <fos:arg name="node" type="node()"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p diff="add" at="A-E31"> Returns the sequence of element nodes that have an
               <code>ID</code> value matching the value of one or more of the <code>IDREF</code>
            values supplied in <code>$arg</code>.</p>
      </fos:summary>
      <fos:rules>
         <change diff="add" at="A-E31">

            <note>
               <p>The effect of this function is identical to <function>fn:id</function> in respect
                  of elements that have an attribute with the <code>is-id</code> property. However,
                  it behaves differently in respect of element nodes with the <code>is-id</code>
                  property. Whereas the <code>fn:id</code>, for legacy reasons, returns the element
                  that has the <code>is-id</code> property, this parent returns the element
                  identified by the ID, which is the parent of the element having the
                     <code>is-id</code> property.</p>
            </note>
            <p>The function returns a sequence, in document order with duplicates eliminated,
               containing every element node <code>E</code> that satisfies all the following
               conditions:</p>
            <olist>
               <item>
                  <p>
                     <code>E</code> is in the target document. The target document is the document
                     containing <code>$node</code>, or the document containing the context item
                        (<code>.</code>) if the second argument is omitted. The behavior of the
                     function if <code>$node</code> is omitted is exactly the same as if the context
                     item had been passed as <code>$node</code>.</p>
               </item>
               <item>
                  <p><code>E</code> has an <code>ID</code> value equal to one of the candidate
                        <code>IDREF</code> values, where:</p>
                  <ulist>
                     <item>
                        <p> An element has an <code>ID</code> value equal to <code>V</code> if
                           either or both of the following conditions are true:</p>
                        <ulist>
                           <item>
                              <p>The element has an child element node whose <code>is-id</code>
                                 property (See <xspecref spec="DM30" ref="dm-is-id"/>.) is true and
                                 whose typed value is equal to <code>V</code> under the rules of the
                                    <code>eq</code> operator using the Unicode code point collation
                                    (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>).</p>
                           </item>
                           <item>
                              <p>The element has an attribute node whose <code>is-id</code> property
                                 (See <xspecref spec="DM30" ref="dm-is-id"/>.) is true and whose
                                 typed value is equal to <code>V</code> under the rules of the
                                    <code>eq</code> operator using the Unicode code point collation
                                    (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>).</p>
                           </item>
                        </ulist>
                     </item>
                     <item>
                        <p>Each <code>xs:string</code> in <code>$arg</code> is parsed as if it were
                           of type <code>IDREFS</code>, that is, each <code>xs:string</code> in
                              <code>$arg</code> is treated as a whitespace-separated sequence of
                           tokens, each acting as an <code>IDREF</code>. These tokens are then
                           included in the list of candidate <code>IDREF</code>s. If any of the
                           tokens is not a lexically valid <code>IDREF</code> (that is, if it is not
                           lexically an <code>xs:NCName</code>), it is ignored. Formally, the
                           candidate <code>IDREF</code> values are the strings in the sequence given
                           by the expression:</p>
                        <eg xml:space="preserve">for $s in $arg return 
   fn:tokenize(fn:normalize-space($s), ' ')[. castable as xs:IDREF]</eg>
                     </item>
                  </ulist>
               </item>
               <item>
                  <p> If several elements have the same <code>ID</code> value, then <code>E</code>
                     is the one that is first in document order.</p>
               </item>
            </olist>
         </change>
      </fos:rules>
      <fos:errors>
         <change diff="add" at="A-E31">
            <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DC" code="0001" type="dynamic"/> if
                  <code>$node</code>, or the context item if the second argument is omitted, is a
               node in a tree whose root is not a document node.</p>
            <p>If the second argument is the context item, or is omitted, the following <phrase diff="add" at="L">type</phrase> errors may
               be raised: if the context item is <xtermref ref="dt-absent" spec="DM30"
                  >absent</xtermref>, <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if
               the context item is not a node <xerrorref spec="XP" class="TY" code="0004"
                  type="type"/>.</p>
         </change>
      </fos:errors>
      <fos:notes>
         <p>This function is equivalent to the <code>fn:id</code> function except when dealing with
            ID-valued element nodes. Whereas the <code>fn:id</code> function selects the element
            containing the identifier, this function selects its parent.</p>
         <p>If the data model is constructed from an Infoset, an attribute will have the
               <code>is-id</code> property if the corresponding attribute in the Infoset had an
            attribute type of <code>ID</code>: typically this means the attribute was declared as an
               <code>ID</code> in a DTD.</p>
         <!--Text replaced by erratum E13 change 1"-->
         <p diff="chg" at="A-E13"> If the data model is constructed from a PSVI, an element or
            attribute will have the <code>is-id</code> property if its typed value is a single
            atomic value of type <code>xs:ID</code> or a type derived by restriction from
               <code>xs:ID</code>.</p>
         <!--End of text replaced by erratum E13-->
         <p> No error is raised in respect of a candidate <code>IDREF</code> value that does not
            match the <code>ID</code> of any element in the document. If no candidate
               <code>IDREF</code> value matches the <code>ID</code> value of any element, the
            function returns the empty sequence.</p>
         <p> It is not necessary that the supplied argument should have type <code>xs:IDREF</code>
            or <code>xs:IDREFS</code>, or that it should be derived from a node with the
               <code>is-idrefs</code> property.</p>
         <p> An element may have more than one <code>ID</code> value. This can occur with synthetic
            data models or with data models constructed from a PSVI where the element and one of its
            attributes are both typed as <code>xs:ID</code>.</p>
         <p> If the source document is well-formed but not valid, it is possible for two or more
            elements to have the same <code>ID</code> value. In this situation, the function will
            select the first such element.</p>
         <p> It is also possible in a well-formed but invalid document to have an element or
            attribute that has the <code>is-id</code> property but whose value does not conform to
            the lexical rules for the <code>xs:ID</code> type. Such a node will never be selected by
            this function.</p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="emp" as="element()"><![CDATA[
            <employee xml:id="ID21256">
               <empnr>E21256</empnr>
               <first>John</first>
               <last>Brown</last>
            </employee>]]>
         </fos:variable>
         <fos:example>
            <fos:test xslt-version="3.0">
               <fos:expression>id('ID21256')/name()</fos:expression>
               <fos:result>"employee"</fos:result>
               <fos:postamble>The <code>xml:id</code> attribute has the <code>is-id</code> property,
                  so the employee element is selected.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test xslt-version="3.0">
               <fos:expression>id('E21256')/name()</fos:expression>
               <fos:result>"employee"</fos:result>
               <fos:postamble>Assuming the <code>empnr</code> element is given the type
                     <code>xs:ID</code> as a result of schema validation, the element will have the
                     <code>is-id</code> property and is therefore its parent is selected. Note the
                  difference from the behavior of <code>fn:id</code>.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="idref">
      <fos:signatures>
         <fos:proto name="idref" return-type="node()*">
            <fos:arg name="arg" type="xs:string*"/>
         </fos:proto>
         <fos:proto name="idref" return-type="node()*">
            <fos:arg name="arg" type="xs:string*"/>
            <fos:arg name="node" type="node()"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="2">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the sequence of element or attribute nodes with an <code>IDREF</code>
            value matching the value of one or more of the <code>ID</code> values supplied in
               <code>$arg</code>.</p>

      </fos:summary>
      <fos:rules>
         <p> The function returns a sequence, in document order with duplicates eliminated,
            containing every element or attribute node <code>$N</code> that satisfies all the
            following conditions:</p>
         <olist>
            <item>
               <p><code>$N</code> is in the target document. The target document is the document
                  containing <code>$node</code> or the document containing the context item
                     (<code>.</code>) if the second argument is omitted. The behavior of the
                  function if <code>$node</code> is omitted is exactly the same as if the context
                  item had been passed as <code>$node</code>.</p>
            </item>
            <item>
               <p><code>$N</code> has an <code>IDREF</code> value equal to one of the candidate
                     <code>ID</code> values, where:</p>
               <ulist>
                  <item>
                     <p>A node <code>$N</code> has an <code>IDREF</code> value equal to
                           <code>V</code> if both of the following conditions are true:</p>
                     <ulist>
                        <item>
                           <p>The <code>is-idrefs</code> property (see <xspecref spec="DM30"
                                 ref="dm-is-idrefs"/>) of <code>$N</code> is <code>true</code>.</p>
                        </item>
                        <item>
                           <p>The sequence <!--Text replaced by erratum E29 change 1"--><eg diff="chg" at="A-E29" xml:space="preserve">fn:tokenize(fn:normalize-space(fn:string($N)), ' ')</eg>
                              <!--End of text replaced by erratum E29--> contains a string that is
                              equal to <code>V</code> under the rules of the <code>eq</code>
                              operator using the Unicode code point collation
                                 (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>).</p>
                        </item>
                     </ulist>
                  </item>
                  <item>
                     <p>Each <code>xs:string</code> in <code>$arg</code> is parsed as if it were of
                        lexically of type <code>xs:ID</code>. These <code>xs:string</code>s are then
                        included in the list of candidate <code>xs:ID</code>s. If any of the strings
                        in <code>$arg</code> is not a lexically valid <code>xs:ID</code> (that is,
                        if it is not lexically an <code>xs:NCName</code>), it is ignored. More
                        formally, the candidate <code>ID</code> values are the strings in the
                        sequence:</p>
                     <eg xml:space="preserve">$arg[. castable as xs:NCName]</eg>
                  </item>
               </ulist>
            </item>
         </olist>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DC" code="0001" type="dynamic"/> if
               <code>$node</code>, or the context item if the second argument is omitted, is a node
            in a tree whose root is not a document node. </p>
         <p>If the second argument is the context item, or is omitted, the following errors may be
            raised: if the context item is <xtermref ref="dt-absent" spec="DM30">absent</xtermref>
            <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a
            node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
      </fos:errors>
      <fos:notes>
         <p> An element or attribute typically acquires the <code>is-idrefs</code> property by being
            validated against the schema type <code>xs:IDREF</code> or <code>xs:IDREFS</code>, or
            (for attributes only) by being described as of type <code>IDREF</code> or
               <code>IDREFS</code> in a DTD.</p>
         <p> No error is raised in respect of a candidate <code>ID</code> value that does not match
            the <code>IDREF</code> value of any element or attribute in the document. If no
            candidate <code>ID</code> value matches the <code>IDREF</code> value of any element or
            attribute, the function returns the empty sequence.</p>
         <p> It is possible for two or more nodes to have an <code>IDREF</code> value that matches a
            given candidate <code>ID</code> value. In this situation, the function will return all
            such nodes. However, each matching node will be returned at most once, regardless how
            many candidate <code>ID</code> values it matches.</p>
         <p> It is possible in a well-formed but invalid document to have a node whose
               <code>is-idrefs</code> property is true but that does not conform to the lexical
            rules for the <code>xs:IDREF</code> type. The effect of the above rules is that
            ill-formed candidate <code>ID</code> values and ill-formed <code>IDREF</code> values are
            ignored.</p>
         <!--Text inserted by erratum E13 change 2"-->
         <p diff="add" at="A-E13">If the data model is constructed from a PSVI, the typed value of a
            node that has the <code>is-idrefs</code> property will contain at least one atomic value
            of type <code>xs:IDREF</code> (or a type derived by restriction from
               <code>xs:IDREF</code>). It may also contain atomic values of other types. These
            atomic values are treated as candidate <code>ID</code> values if their lexical form is
            valid as an <code>xs:NCName</code>, and they are ignored otherwise.</p>
         <!--End of text inserted by erratum E13-->
      </fos:notes>
   </fos:function>
   <fos:function name="doc">
      <fos:signatures>
         <fos:proto name="doc" return-type="document-node()?">
            <fos:arg name="uri" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="available-documents static-base-uri">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      
      <fos:summary>
         <p diff="chg" at="A-E26">Retrieves a document using a URI supplied as an
               <code>xs:string</code>, and returns the corresponding document node.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$uri</code> is the empty sequence, the result is an empty sequence.</p>

         <p diff="add" at="A-E26">If <code>$uri</code> is a relative URI reference, it is resolved
            relative to the value of the <phrase diff="chg" at="L">Static Base URI property from the static context</phrase>. The resulting
            absolute URI is promoted to an <code>xs:string</code>.</p>
         <p diff="add" at="A-E26">If the <term>Available documents</term> described in <xspecref
               spec="XP30" ref="eval_context"/> provides a mapping from this string to a document
            node, the function returns that document node.</p>

         <p diff="add" at="A-E26">The URI may include a fragment identifier.</p>
         <p>By default, this function is <termref def="deterministic">deterministic</termref>. Two calls on this function
            return the same document node if the same URI Reference (after resolution to an absolute
            URI Reference) is supplied to both calls. Thus, the following expression (if it does not
            raise an error) will always be true:</p>
         <eg xml:space="preserve">doc("foo.xml") is doc("foo.xml")</eg>
         <p>However, for performance reasons, implementations may provide a user option to evaluate
            the function without a guarantee of determinism. The manner in which any such option is
            provided is implementation-defined. If the user has not selected such an option, a call
            of the function must either return a deterministic result or must raise a <phrase diff="add" at="L">dynamic</phrase> error
               <errorref class="DC" code="0003"/>.</p>
         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
         <note>
            <p>If <code>$uri</code> is read from a source document, it is generally appropriate to
               resolve it relative to the base URI property of the relevant node in the source
               document. This can be achieved by calling the <code>fn:resolve-uri</code> function,
               and passing the resulting absolute URI as an argument to the <code>fn:doc</code>
               function.</p>
         </note>
         <p>If two calls to this function supply different absolute URI References as arguments, the
            same document node may be returned if the implementation can determine that the two
            arguments refer to the same resource.</p>
         <p> By defining the semantics of this function in terms of a string-to-document-node
            mapping in the dynamic context, the specification is acknowledging that the results of
            this function are outside the purview of the language specification itself, and depend
            entirely on the run-time environment in which the expression is evaluated. This run-time
            environment includes not only an unpredictable collection of resources ("the web"), but
            configurable machinery for locating resources and turning their contents into document
            nodes within the XPath data model. Both the set of resources that are reachable, and the
            mechanisms by which those resources are parsed and validated, are <termref
               def="implementation-dependent"/>.</p>
         <p> One possible processing model for this function is as follows. The resource identified
            by the URI Reference is retrieved. If the resource cannot be retrieved, a <phrase diff="add" at="L">dynamic</phrase> error is
            raised <errorref class="DC" code="0002"/>. The data resulting from the retrieval action
            is then parsed as an XML document and a tree is constructed in accordance with the
               <bibref ref="xpath-datamodel-30"/>. If the top-level media type is known and is
            "text", the content is parsed in the same way as if the media type were text/xml;
            otherwise, it is parsed in the same way as if the media type were application/xml. If
            the contents cannot be parsed successfully, a <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DC"
               code="0002"/>. Otherwise, the result of the function is the document node at the root
            of the resulting tree. This tree is then optionally validated against a schema.</p>
         <p>Various aspects of this processing are <termref def="implementation-defined"/>.
            Implementations may provide external configuration options that allow any aspect of the
            processing to be controlled by the user. In particular:</p>
         <ulist>
            <item>
               <p>The set of URI schemes that the implementation recognizes is
                  implementation-defined. Implementations may allow the mapping of URIs to resources
                  to be configured by the user, using mechanisms such as catalogs or user-written
                  URI handlers.</p>
            </item>
            <item>
               <p>The handling of non-XML media types is implementation-defined. Implementations may
                  allow instances of the data model to be constructed from non-XML resources, under
                  user control.</p>
            </item>
            <item>
               <p>It is <termref def="implementation-defined"/> whether DTD validation and/or schema
                  validation is applied to the source document.</p>
            </item>
            <item>
               <p>Implementations may provide user-defined error handling options that allow
                  processing to continue following an error in retrieving a resource, or in parsing
                  and validating its content. When errors have been handled in this way, the
                  function may return either an empty sequence, or a fallback document provided by
                  the error handler.</p>
            </item>
            <item>
               <p>Implementations may provide user options that relax the requirement for the
                  function to return deterministic results.</p>
            </item>
         </ulist>
      </fos:rules>
      <fos:errors>
         <p diff="add" at="A-E26">A <phrase diff="add" at="L">dynamic</phrase> error <rfc2119>may</rfc2119> be raised <errorref class="DC"
               code="0005"/> if <code>$uri</code> is not a valid URI.</p>
         <p diff="chg" at="G">A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DC" code="0002"/> if the
               <term>available documents</term> provides no mapping for the absolutized URI.</p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DC" code="0002"/> if the resource cannot be
            retrieved or cannot be parsed successfully as XML.</p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DC" code="0003"/> if the implementation is not able
            to guarantee that the result of the function will be deterministic, and the user has not
            indicated that an unstable result is acceptable.</p>
      </fos:errors>
   </fos:function>
   <fos:function name="doc-available">
      <fos:signatures>
         <fos:proto name="doc-available" return-type="xs:boolean">
            <fos:arg name="uri" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="available-documents static-base-uri">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p diff="chg" at="A-E26">The function returns true if and only if the function
            call <code>fn:doc($uri)</code> would return a document node.</p>
      </fos:summary>
      <fos:rules>
         <p diff="chg" at="A-E26">If <code>$uri</code> is an empty sequence, this function returns
               <code>false</code>.</p>
         <p diff="chg" at="A-E26">If a call on <code>fn:doc($uri)</code> would return a document
            node, this function returns <code>true</code>.</p>
         <p diff="chg" at="A-E26">A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DC" code="0005"/> if
               <code>$uri</code> is not a valid URI according to the rules applied by the
            implementation of <code>fn:doc</code>.</p>
         <p diff="chg" at="A-E26">Otherwise, this function returns <code>false</code>.</p>
         <p>If this function returns <code>true</code>, then calling <code>fn:doc($uri)</code>
            within the same <termref def="execution-scope"/> must return a document node. However,
            if nondeterministic processing has been selected for the <code>fn:doc</code> function,
            this guarantee is lost.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="collection">
      <fos:signatures>
         <fos:proto name="collection" return-type="node()*"/>
         <fos:proto name="collection" return-type="node()*">
            <fos:arg name="arg" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="available-node-collections static-base-uri">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a sequence of nodes representing a collection of documents indentified
            by a collection URI; or a default collection if no URI is supplied.</p>
      </fos:summary>
      <fos:rules>

         <p>This function takes an <code>xs:string</code> as argument and returns a sequence of
            nodes obtained by interpreting <code>$arg</code> as an <code>xs:anyURI</code> and
            resolving it according to the mapping specified in <term>Available node collections</term>
            described in <xspecref spec="XP30" ref="id-xp-evaluation-context-components"/>.</p>
         <p>If <term>Available node collections</term> provides a mapping from this string to a sequence
            of nodes, the function returns that sequence. If <term>Available node collections</term> maps
            the string to an empty sequence, then the function returns an empty sequence.</p>
         <p>If <code>$arg</code> is not specified, the function returns the sequence of the nodes in
            the default node collection in the dynamic context. See <xspecref spec="XP30"
               ref="id-xp-evaluation-context-components"/>. </p>
         <p>If the value of <code>$arg</code> is a relative <code>xs:anyURI</code>, it is resolved
            against the value of the base-URI property from the static context. </p>
         <p>If <code>$arg</code> is the empty sequence, the function behaves as if it had been
            called without an argument. See above.</p>
         <p>By default, this function is <termref def="deterministic">deterministic</termref>. 
            This means that repeated
            calls on the function with the same argument will return the same result. However, for
            performance reasons, implementations may provide a user option to evaluate the function
            without a guarantee of determinism. The manner in which any such option is provided is
               <termref def="implementation-defined"/>. If the user has not selected such an option,
            a call to this function must either return a deterministic result or must raise a <phrase diff="add" at="L">dynamic</phrase> error
               <errorref class="DC" code="0003"/>.</p>
         <p diff="add" at="G">There is no requirement that the returned nodes should be in document
            order, nor is there a requirement that the result should contain no duplicates.</p>

         <p diff="del" at="F">For detailed type semantics, see [Formal Semantics].</p>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DC" code="0002"/> if no URI is supplied and the
            value of the default collection is <xtermref ref="dt-absent" spec="DM30"
               >absent</xtermref>.</p>
         <p diff="chg" at="J">An error is raised <errorref class="DC" code="0002"/> if <term>available
               node collections</term> provides no mapping for the absolutized URI.</p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DC" code="0004"/> if <code>$arg</code> is not a
            valid <code>xs:anyURI</code>.</p>
      </fos:errors>
      <fos:notes>
         <p> This function provides a facility for users to work with a collection of documents
            which may be contained in a directory, or in the rows of a relational table, or in some other
            implementation-specific construct. An implementation may also use external variables to
            identify external resources, but <code>fn:collection</code> provides functionality not
            provided by external variables. Specifying resources using URIs is useful because URIs
            are dynamic, can be parameterized, and do not rely on an external environment.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="uri-collection" diff="add" at="C">
      <fos:signatures>
         <fos:proto name="uri-collection" return-type="xs:anyURI*"/>
         <fos:proto name="uri-collection" return-type="xs:anyURI*">
            <fos:arg name="arg" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="available-resource-collections static-base-uri">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a sequence of <code>xs:anyURI</code> values representing the URIs in a resource collection.</p>
      </fos:summary>
      <fos:rules>
         <p>The zero-argument form of the function returns the URIs in the <term>Default resource collection</term>
            described in <xspecref spec="XP30" ref="id-xp-evaluation-context-components"/>.</p>
         <p>If the value of <code>$arg</code> is a relative <code>xs:anyURI</code>, it is resolved
            against the value of the base-URI property from the static context. </p>
         <p>If <code>$arg</code> is the empty sequence, the function behaves as if it had been
            called without an argument. See above.</p>
         <p>The single-argument form of the function returns the sequence of URIs corresponding to the 
            supplied URI in the <term>Available resource collections</term> described in 
            <xspecref spec="XP30" ref="id-xp-evaluation-context-components"/>.</p>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DC" code="0002"/> if no URI is supplied (that is, if the
            the function is called with no arguments, or with a single argument that evaluates to an empty sequence), and the
            value of the default resource collection is <xtermref ref="dt-absent" spec="DM30"
               >absent</xtermref>.</p>
         <p diff="chg" at="J">A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DC" code="0002"/> 
            if <term>available resource collections</term> provides no mapping for the absolutized URI.</p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DC" code="0004"/> if <code>$arg</code> is not a
            valid <code>xs:anyURI</code>.</p>
      </fos:errors>
      <fos:notes>
         <p>There are several reasons why it might be appropriate to use this function in preference
         to the <code>fn:collection</code> function:</p>
         
         <ulist>
            <item>
               <p>It allows resources to be retrieved that are not well-formed XML documents: for
               example, the returned URIs might be referenced using the <code>fn:unparsed-text</code>
               function rather than the <code>fn:doc</code> function.</p>
            </item>
            <item>
               <p>In XSLT 3.0 it allows the documents to be processed in streaming mode using the
                  <code>xsl:stream</code> instruction.</p>
            </item>
            <item>
               <p>It allows recovery from failures to read, parse, or validate individual documents,
                  by calling the <code>fn:doc</code> function within the scope of try/catch.</p>
            </item>
            <item>
               <p>It allows selection of which documents to read based on their URI, for example
                  they can be filtered to select those whose URIs end in <code>.xml</code>,
                  or those that use the <code>https</code> scheme.</p>
            </item>
            <item>
               <p>An application might choose to limit the number of URIs processed in a single run,
                  for example it might process only the first 50 URIs in the collection; or it might present the
                  URIs to the user and allow the user to select which of them need to be further processed.</p>
            </item>
            <item>
               <p>It allows the URIs to be modified before they are dereferenced, for example by adding
                  or removing query parameters, or by redirecting the request to a local cache or to a mirror site.</p>
            </item>
         </ulist>
         
         <p>For some of these use cases, this assumes that the cost of calling <code>fn:collection</code>
         might be significant (for example, it might involving retrieving all the documents in the collection over the
         network and parsing them). This will not necessarily be true of all implementations.</p>
         
         <p>Some implementations might ensure that calling <code>fn:uri-collection</code> and then applying
         <code>fn:doc</code> to each of the returned URIs delivers the same result as calling <code>fn:collection</code>
         with the same argument; however, this is not guaranteed.</p>
         
         <p diff="add" at="G">There is no requirement that the URIs returned by this function should all be
            distinct, and no assumptions can be made about the order of URIs in the sequence,
            unless the implementation defines otherwise.</p>
 

      </fos:notes>
   </fos:function>
   <fos:function name="unparsed-text">
      <fos:signatures>
         <fos:proto name="unparsed-text" return-type="xs:string?">
            <fos:arg name="href" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="unparsed-text" return-type="xs:string?">
            <fos:arg name="href" type="xs:string?"/>
            <fos:arg name="encoding" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="static-base-uri">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>

      <fos:summary>
         <p>The <code>fn:unparsed-text</code> function reads an external resource (for example, a
            file) and returns <phrase diff="chg" at="L">a string representation of the resource</phrase>.</p>
      </fos:summary>
      <fos:rules>
         <p>The <code>$href</code> argument <rfc2119>must</rfc2119> be a string in the form of a URI
            reference, which <rfc2119>must</rfc2119> contain no fragment identifier, and
               <rfc2119>must</rfc2119> identify a resource 
            <phrase diff="chg" at="L">for which a string representation is available</phrase>. If the URI is a
            relative URI reference, then it is resolved relative to the 
            <phrase diff="chg" at="L">Static Base URI property from the static context</phrase>.</p>
         <p diff="add" at="L">The mapping of URIs to the string representation of a resource is the mapping defined
            in the <xtermref spec="XP30" ref="dt-available-text-resources">available text resources</xtermref>
         component of the dynamic context.</p>
         <p>If the value of the <code>$href</code> argument is an empty sequence, the function
            returns an empty sequence.</p>
         <p>The <code>$encoding</code> argument, if present, is the name of an encoding. The values
            for this attribute follow the same rules as for the <code>encoding</code> attribute in
            an XML declaration. The only values which every <termref def="implementation"
               >implementation</termref> is <rfc2119>required</rfc2119> to recognize are
               <code>utf-8</code> and <code>utf-16</code>.</p>
         <p>The encoding of the external resource is determined as follows:</p>
         <olist>
            <item>
               <p>external encoding information is used if available, otherwise</p>
            </item>
            <item>
               <p>if the media type of the resource is <code>text/xml</code> or
                     <code>application/xml</code> (see <bibref ref="rfc2376"/>), or if it matches
                  the conventions <code>text/*+xml</code> or <code>application/*+xml</code> (see
                     <bibref ref="rfc3023"/> and/or its successors), then the encoding is recognized
                  as specified in <bibref ref="REC-xml"/>, otherwise</p>
            </item>
            <item>
               <p>the value of the <code>$encoding</code> argument is used if present, otherwise</p>
            </item>
            <item>
               <p>the processor <rfc2119>may</rfc2119> use <termref def="implementation-defined"
                     >implementation-defined</termref> heuristics to determine the likely encoding,
                  otherwise</p>
            </item>
            <item>
               <p>UTF-8 is assumed.</p>
            </item>
         </olist>
         <p>The result of the function is a string containing the 
            <phrase diff="chg" at="L">string representation</phrase> of the resource retrieved
            using the URI.</p>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="UT" code="1170"/> if <code>$href</code>
            contains a fragment identifier, or if it cannot be used to retrieve the 
            <phrase diff="chg" at="L">string representation</phrase> of a resource.</p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="UT" code="1190"/> <phrase diff="add" at="L">if the value 
            of the <code>$encoding</code> argument is not a valid encoding name, </phrase>if the <termref
               def="dt-processor">processor</termref> does not support the specified encoding,
            if the <phrase diff="chg" at="L">string representation</phrase> of the retrieved
            resource contains octets that cannot be decoded into Unicode <termref def="character"
               >characters</termref> using the specified encoding, or if the resulting characters
            are not permitted XML characters.</p>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="UT" code="1200"/> if
               <code>$encoding</code> is absent and the <termref def="dt-processor"
               >processor</termref> cannot infer the encoding using external information and the
            encoding is not UTF-8.</p>
      </fos:errors>

      <fos:notes>
         <p>If it is appropriate to use a base URI other than the <phrase diff="chg" at="J">dynamic</phrase> base URI (for example, when
            resolving a relative URI reference read from a source document) then it is advisable to
            resolve the relative URI reference using the <code>fn:resolve-uri</code> function before
            passing it to the <function>fn:unparsed-text</function> function.</p>
         <p diff="add" at="L">There is no essential relationship between the sets of URIs accepted by
            the two functions <code>fn:unparsed-text</code> and <code>fn:doc</code> (a URI accepted by one may or may
            not be accepted by the other), and if a URI is accepted by both there is no
            essential relationship between the results (different resource representations
            are permitted by the architecture of the web).</p>
         <p diff="add" at="L">There are no constraints on the MIME type of the resource.</p>
         
         
         <p diff="add" at="L">The fact that the resolution of URIs is defined by a mapping
            in the dynamic context means that in effect, various aspects of the behavior of this
            function are <termref def="implementation-defined"/>.
            Implementations may provide external configuration options that allow any aspect of the
            processing to be controlled by the user. In particular:</p>
         <ulist>
            <item>
               <p>The set of URI schemes that the implementation recognizes is
                  implementation-defined. Implementations may allow the mapping of URIs to resources
                  to be configured by the user, using mechanisms such as catalogs or user-written
                  URI handlers.</p>
            </item>
            <item>
               <p>The handling of media types is implementation-defined.</p>
            </item>
            
            <item>
               <p>Implementations may provide user-defined error handling options that allow
                  processing to continue following an error in retrieving a resource, or in reading its content. 
                  When errors have been handled in this way, the
                  function may return a fallback document provided by
                  the error handler.</p>
            </item>
            <item>
               <p>Implementations may provide user options that relax the requirement for the
                  function to return deterministic results.</p>
            </item>
         </ulist>
         
         <p>The rules for determining the encoding are chosen for consistency with <bibref
               ref="xinclude"/>. Files with an XML media type are treated specially because there
            are use cases for this function where the retrieved text is to be included as unparsed
            XML within a CDATA section of a containing document, and because processors are likely
            to be able to reuse the code that performs encoding detection for XML external
            entities.</p>
         <p>If the text file contains characters such as <code>&lt;</code> and <code>&amp;</code>,
            these will typically be output as <code>&amp;lt;</code> and <code>&amp;amp;</code> if
            the string is serialized as XML or HTML. If these characters actually represent markup (for
            example, if the text file contains HTML), then an XSLT stylesheet can attempt to write
            them as markup to the output file using the <code>disable-output-escaping</code>
            attribute of the <code>xsl:value-of</code> instruction. Note, however, that XSLT
            implementations are not required to support this feature.</p>
      </fos:notes>



      <!--
      <imp-def-feature>The set of encodings recognized by the
         <function>unparsed-text</function> function, other than <code>utf-8</code> and
         <code>utf-16</code>, is <termref def="implementation-defined"
            >implementation-defined</termref>.</imp-def-feature>
      
      <imp-def-feature>If no encoding is specified on a call to the
         <function>unparsed-text</function> function, the processor
         <rfc2119>may</rfc2119> use <termref def="implementation-defined"
            >implementation-defined</termref> heuristics to determine the likely
         encoding.</imp-def-feature>-->

      <fos:examples>
         <fos:example>
            <p>This XSLT example attempts to read a file containing 'boilerplate' HTML and copy it directly to the serialized
               output file:</p>
            <eg xml:space="preserve"><![CDATA[<xsl:output method="html"/>

<xsl:template match="/">
  <xsl:value-of select="unparsed-text('header.html', 'iso-8859-1')"
                disable-output-escaping="yes"/>
  <xsl:apply-templates/>
  <xsl:value-of select="unparsed-text('footer.html', 'iso-8859-1')"
                disable-output-escaping="yes"/>
</xsl:template>
]]></eg>
         </fos:example>
      </fos:examples>

   </fos:function>

   <fos:function name="unparsed-text-lines">
      <fos:signatures>
         <fos:proto name="unparsed-text-lines" return-type="xs:string*">
            <fos:arg name="href" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="unparsed-text-lines" return-type="xs:string*">
            <fos:arg name="href" type="xs:string?"/>
            <fos:arg name="encoding" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="static-base-uri">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>

      <fos:summary>
         <p>The <code>fn:unparsed-text-lines</code> function reads an external resource (for
            example, a file) and returns its contents as a sequence of strings, one for each line of
            text in the  <phrase diff="chg" at="L">string representation</phrase> of the resource.</p>
      </fos:summary>

      <fos:rules>
         <p>The <code>unparsed-text-lines</code> function reads an external resource (for example, a
            file) and returns its <phrase diff="chg" at="L">string representation</phrase> as a sequence of strings, separated at newline
            boundaries. </p>
         <p>The result of the single-argument function is the same as the result of the expression
               <code>fn:tokenize(fn:unparsed-text($href), '\r\n|\r|\n')[not(position()=last() and
               .='')]</code>. The result of the two-argument function is the same as the result of
            the expression <code>fn:tokenize(fn:unparsed-text($href, $encoding),
               '\r\n|\r|\n'))[not(position()=last() and .='')]</code>. </p>
         <p>The result is a thus a sequence of strings containing the text of the resource retrieved
            using the URI, each string representing one line of text. Lines are separated by one of
            the sequences x0A, x0D, or x0Dx0A. The characters representing the newline are not
            included in the returned strings. If there are two adjacent newline sequences, a
            zero-length string will be returned to represent the empty line; but if the external
            resource ends with a newline sequence, no zero-length string will be returned as the
            last item in the result.</p>
      </fos:rules>
      <fos:errors>
         <p>Error conditions are the same as for the <code>fn:unparsed-text</code> function.</p>

      </fos:errors>

      <fos:notes>
         <p>See the notes for <code>fn:unparsed-text</code>.</p>
      </fos:notes>



   </fos:function>


   <fos:function name="unparsed-text-available">
      <fos:signatures>
         <fos:proto name="unparsed-text-available" return-type="xs:boolean">
            <fos:arg name="href" type="xs:string?"/>
         </fos:proto>
         <fos:proto name="unparsed-text-available" return-type="xs:boolean">
            <fos:arg name="href" type="xs:string?"/>
            <fos:arg name="encoding" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="static-base-uri">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Because errors in evaluating the <function>fn:unparsed-text</function> function are
            non-recoverable, these two functions are provided to allow an application to determine
            whether a call with particular arguments would succeed.</p>
      </fos:summary>
      <fos:rules>
         <p>The <function>fn:unparsed-text-available</function> function determines whether a call
            on the <function>fn:unparsed-text</function> function with identical arguments would
            return a string.</p>
         <p>If the first argument is an empty sequence, the function returns false. <phrase diff="del" at="L">If the second
            argument is an empty sequence, the function behaves as if the second argument were
            omitted.</phrase></p>
         <p>In other cases, the function returns true if a call on
               <function>fn:unparsed-text</function> with the same arguments would succeed, and
            false if a call on <function>fn:unparsed-text</function> with the same arguments would
            fail with a non-recoverable dynamic error.</p>
         <p>The functions <function>fn:unparsed-text</function> and
               <function>fn:unparsed-text-available</function> have the same requirement for
               <termref def="deterministic">determinism</termref> as the functions
               <code>fn:doc</code> and <code>fn:doc-available</code>. This means that unless the
            user has explicitly stated a requirement for a reduced level of determinism, either of
            these functions if called twice with the same arguments during the course of a
            transformation <rfc2119>must</rfc2119> return the same results each time; moreover, the
            results of a call on <function>fn:unparsed-text-available</function>
            <rfc2119>must</rfc2119> be consistent with the results of a subsequent call on
               <function>unparsed-text</function> with the same arguments.</p>
      </fos:rules>
      <fos:notes>
         <p>This requires that the <function>unparsed-text-available</function> function should
            actually attempt to read the resource identified by the URI, and check that it is
            correctly encoded and contains no characters that are invalid in XML. Implementations
            may avoid the cost of repeating these checks for example by caching the validated
            contents of the resource, to anticipate a subsequent call on the
               <function>unparsed-text</function>
            <phrase diff="add" at="A">or <function>unparsed-text-lines</function>
            </phrase> function. Alternatively, implementations may be able to rewrite an expression
            such as <code>if (unparsed-text-available(A)) then unparsed-text(A) else ...</code> to
            generate a single call internally.</p>

      </fos:notes>

   </fos:function>

   <fos:function name="environment-variable">
      <fos:signatures>
         <fos:proto name="environment-variable" return-type="xs:string?">
            <fos:arg name="name" type="xs:string"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="environment-variables">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the value of a system environment variable, if it exists.</p>
      </fos:summary>
      <fos:rules>
         <p>The set of available <xtermref spec="XP30" ref="dt-environment-variables">environment variables</xtermref> 
            is a set of (name, value) pairs forming part
            of the dynamic context, in which the name is unique within the set of pairs. The name
            and value are arbitrary strings.</p>
         <p>If the <code>$name</code> argument matches the name of one of these pairs, the function
            returns the corresponding value.</p>
         <p>If there is no environment variable with a matching name, the function returns the empty
            sequence.</p>
         <p>The collation used for matching names is <termref def="implementation-defined"/>, but
            must be the same as the collation used to ensure that the names of all environment
            variables are unique.</p>
         <p diff="add" at="I">The function is <termref def="dt-deterministic">deterministic</termref>, 
            which means that if it is called several times
         within the same <termref def="dt-execution-scope">execution scope</termref>, with the same arguments,
            it must return the same result.</p>
      </fos:rules>
      <fos:notes>
         <p>On many platforms, the term "environment variable" has a natural meaning in terms of
            facilities provided by the operating system. This interpretation of the concept does not
            exclude other interpretations, such as a mapping to a set of configuration parameters in
            a database system.</p>
         <p>Environment variable names are usually case sensitive. Names are usually of the form
               <code>(letter|_) (letter|_|digit)*</code>, but this varies by platform.</p>
         <p>On some platforms, there may sometimes be multiple environment variables with the same name;
            in this case, it is implementation-dependent as to which is returned; see for example
               <bibref ref="POSIX.1-2008"/> (Chapter 8, Environment Variables).
            Implementations <rfc2119>may</rfc2119> use prefixes or other naming conventions
            to disambiguate the names.</p>
         <p>The requirement to ensure that the function is deterministic means in practice that
         the implementation must make a snapshot of the environment variables at some time
         during execution, and return values obtained from this snapshot, rather than using
         live values that are subject to change at any time.</p>
         <p>Operating system environment variables may be associated with a particular process,
         while queries and stylesheets may execute across multiple processes (or multiple machines).
         In such circumstances implementations <rfc2119>may</rfc2119> choose to provide access
         to the environment variables associated with the process in which the query or stylesheet
         processing was initiated.</p>
         <p>Security advice: Queries from untrusted sources should not be permitted unrestricted
            access to environment variables. For example, the name of the account under which the
            query is running may be useful information to a would-be intruder. An implementation may
            therefore choose to restrict access to the environment, or may provide a facility to
            make <code>fn:environment-variable</code> always return the empty sequence.</p>
         
      </fos:notes>
   </fos:function>
   <fos:function name="available-environment-variables" diff="chg" at="11682">
      <fos:signatures>
         <fos:proto name="available-environment-variables" return-type="xs:string*"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="environment-variables">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a list of environment variable names that are suitable for passing to
               <code>fn:environment-variable</code>, as a (possibly empty) sequence of strings.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns a sequence of strings, being the names of the environment variables
            in the dynamic context in some <termref def="implementation-dependent"
               >implementation-dependent</termref> order.</p>
         <p>The function is <termref def="dt-deterministic">deterministic</termref>: that is, the
            set of available environment variables does not vary during evaluation.</p>
      </fos:rules>
      <fos:notes>
         <p>The function returns a list of strings, containing no duplicates.</p>
         <p>It is intended that the strings in this list should be suitable for passing to
               <code>fn:environment-variable</code>.</p>

         <p>See also the note on security under the definition of the
               <code>fn:environment-variable</code> function. If access to environment variables has
            been disabled, <code>fn:available-environment-variables</code> always returns the empty
            sequence.</p>
      </fos:notes>
   </fos:function>


   <fos:function name="generate-id">
      <fos:signatures>
         <fos:proto name="generate-id" return-type="xs:string"/>
         <fos:proto name="generate-id" return-type="xs:string">
            <fos:arg name="arg" type="node()?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties arity="0">
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>This function returns a string that uniquely identifies a given node. </p>
      </fos:summary>
      <fos:rules>
         <p>If the argument is omitted, it defaults to the context item (<code>.</code>). The
            behavior of the function if the argument is omitted is exactly the same as if the
            context item had been passed as the argument.</p>
         <p>If the argument is the empty sequence, the result is the zero-length string.</p>
         <p>In other cases, the function returns a string that uniquely identifies a given node.</p>

         <p>The returned identifier <rfc2119>must</rfc2119> consist of ASCII alphanumeric characters
            and <rfc2119>must</rfc2119> start with an alphabetic character. Thus, the string is
            syntactically an XML name.</p>
         <p>An implementation is free to generate an identifier in any convenient way provided that
            it always generates the same identifier for the same node and that different identifiers
            are always generated from different nodes. An implementation is under no obligation to
            generate the same identifiers each time a document is transformed or queried.</p>
      </fos:rules>
      <fos:errors>
         <p>The following errors may be raised when <code>$arg</code> is omitted: if the context
            item is <xtermref ref="dt-absent" spec="DM30">absent</xtermref>
            <xerrorref spec="XP" class="DY" code="0002" type="type"/>; if the context item is not a
            node <xerrorref spec="XP" class="TY" code="0004" type="type"/>.</p>
      </fos:errors>
      <fos:notes>
         <p>There is no guarantee that a generated unique identifier will be distinct from any
            unique IDs specified in the source document.</p>
         <p>There is no inverse to this function; it is not directly possible to find the node with
            a given generated ID. Of course, it is possible to search a given sequence of nodes
            using an expression such as <code>$nodes[generate-id()=$id]</code>.</p>
         <p>It is advisable, but not required, for implementations to generate IDs that are distinct
            even when compared using a case-blind collation.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p>The primary use case for this function is to generate hyperlinks. For example, when
               generating HTML, an anchor for a given section <code>$sect</code> can be generated by
               writing (in either XSLT or XQuery):</p>
            <p>
               <code><![CDATA[<a name="{generate-id($sect)}"/>]]></code>
            </p>
            <p>and a link to that section can then be produced with code such as:</p>
            <p>
               <code><![CDATA[see <a href="#{generate-id($sect)}">here</a>]]></code>
            </p>
            <p>Note that anchors generated in this way will not necessarily be the same each time a
               document is republished.</p>
         </fos:example>
      </fos:examples>
   </fos:function>

   <fos:function name="parse-xml" diff="chg" at="I">
      <fos:signatures>
         <fos:proto name="parse-xml" return-type="document-node(element(*))?">
            <fos:arg name="arg" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>nondeterministic</fos:property>
         <fos:property dependency="static-base-uri">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>This function takes as input an XML document represented as a string, and
            returns the document node at the root of an XDM tree representing the parsed
            document.</p>
      </fos:summary>
      <fos:rules>
         <p diff="add" at="G">If <code>$arg</code> is the empty sequence, the function returns the
            empty sequence.</p>
         <p>The precise process used to construct the XDM instance is <termref def="implementation-defined"/>. In
            particular, it is implementation-defined whether DTD and/or schema validation is invoked, and it is
            implementation-defined whether an XML 1.0 or XML 1.1 parser is used.</p>
         <p>The Static Base URI property from the static context of the
            <code>fn:parse-xml</code> function call is used both as the base URI used by the XML parser to resolve
            relative entity references within the document, and as the base URI of the document node
            that is returned.</p>
         <p>The document URI of the returned node is <termref def="absent">absent</termref>.</p>
         <p>The function is <emph>not</emph>
            <termref def="deterministic">deterministic</termref>: that is, if the function is called
            twice with the same arguments, it is <termref def="implementation-dependent"
               >implementation-dependent</termref> whether the same node is returned on both
            occasions.</p>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DC" code="0006"/> if the content of
               <code>$arg</code> is not a well-formed and namespace-well-formed XML document.</p>
         <p diff="add" at="G">A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DC" code="0006"/> if DTD-based
            validation is carried out and the content of <code>$arg</code> is not valid against its
            DTD.</p>
      </fos:errors>
      <fos:notes>
         <p>Since the XML document is presented to the parser as a string, rather than as a sequence
            of octets, the encoding specified within the XML declaration has no meaning. If the XML
            parser accepts input only in the form of a sequence of octets, then the processor must
            ensure that the string is encoded as octets in a way that is consistent with rules used
            by the XML parser to detect the encoding.</p>
         <p>The primary use case for this function is to handle input documents that contain nested
            XML documents embedded within CDATA sections. Since the content of the CDATA section are
            exposed as text, the receiving query or stylesheet may pass this text to the
               <code>fn:parse-xml</code> function to create a tree representation of the nested
            document.</p>
         <p>Similarly, nested XML within comments is sometimes encountered, and lexical XML is
            sometimes returned by extension functions, for example, functions that access web
            services or read from databases.</p>
         <p>A use case arises in XSLT where there is a need to preprocess an input document before
            parsing. For example, an application might wish to edit the document to remove its
            DOCTYPE declaration. This can be done by reading the raw text using the
               <code>fn:unparsed-text</code> function, editing the resulting string, and then
            passing it to the <code>fn:parse-xml</code> function.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p>The expression <code>fn:parse-xml("&lt;alpha>abcd&lt;/alpha>")</code> returns a newly
               created document node, having an <code>alpha</code> element as its only child; the
                  <code>alpha</code> element in turn is the parent of a text node whose string value
               is <code>"abcd"</code>.</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="parse-xml-fragment" diff="add" at="I">
      <fos:signatures>
         <fos:proto name="parse-xml-fragment" return-type="document-node()?">
            <fos:arg name="arg" type="xs:string?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>nondeterministic</fos:property>
         <fos:property dependency="static-base-uri">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>This function takes as input an XML external entity represented as a string,
            and returns the document node at the root of an XDM tree representing the parsed
            document fragment.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$arg</code> is the empty sequence, the function returns the empty sequence.</p>
         <p>The input must be a namespace-well-formed external general parsed entity. More specifically,
            it must be a string conforming to the production rule <xnt spec="xml"
               >extParsedEnt</xnt> in <bibref ref="REC-xml"/>, it must contain no entity references other
            than references to predefined entities,
            and it must satisfy all the rules
            of <bibref ref="REC-xml-names"/> for namespace-well-formed documents with the exception
            that the rule requiring it to be a well-formed document is replaced by the rule requiring
            it to be a well-formed external general parsed entity.</p>
         
         <p>The string is parsed to form a sequence of nodes which
            become children of the new document node, in the same way as the content of any element
            is converted into a sequence of children for the resulting element node.</p>
         <p>Schema validation is <emph>not</emph> invoked, which means that the nodes in the
            returned document will all be untyped.</p>
         <p>The precise process used to construct the XDM instance is <termref def="implementation-defined"/>. In
            particular, it is implementation-defined whether an XML 1.0 or XML 1.1 parser is
            used.</p>
         <p diff="chg" at="L">The Static Base URI from the static context of the <code>fn:parse-xml-fragment</code> function call 
            is used as the base URI of the document node
            that is returned.</p>
         <p>The document URI of the returned node is <termref def="absent">absent</termref>.</p>
         <p>The function is <emph>not</emph>
            <termref def="deterministic">deterministic</termref>: that is, if the function is called
            twice with the same arguments, it is <termref def="implementation-dependent"
               >implementation-dependent</termref> whether the same node is returned on both
               occasions.</p>
      </fos:rules>
      <fos:errors>
         <p>A <phrase diff="add" at="L">dynamic</phrase> error is raised <errorref class="DC" code="0006"/> if the content of
               <code>$arg</code> is not a well-formed external general parsed entity, 
            if it contains entity references other than references to predefined entities, or if a document that
            incorporates this well-formed parsed entity would not be namespace-well-formed.</p>
      </fos:errors>
      <fos:notes>
         <p>See also the notes for the <code>fn:parse-xml</code> function.</p>
         <p>The main differences between <code>fn:parse-xml</code> and
               <code>fn:parse-xml-fragment</code> are that for <code>fn:parse-xml</code>, the
            children of the resulting document node must contain exactly one element node and no
            text nodes, wheras for <code>fn:parse-xml-fragment</code>, the resulting document node
            can have any number (including zero) of element and text nodes among its children. An
            additional difference is that the <emph>text declaration</emph> at the start of an
            external entity has slightly different syntax from the <emph>XML declaration</emph> at
            the start of a well-formed document.</p>
         <p>Note that all whitespace outside the <emph>text declaration</emph> is significant, including
            whitespace that precedes the first element node.</p>
         <p>One use case for this function is to handle XML fragments stored in databases,
            which frequently allow zero-or-more top level element nodes. Another use case
            is to parse the contents of a <code>CDATA</code> section embedded within another XML document.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p>The expression <code>fn:parse-xml-fragment("&lt;alpha>abcd&lt;/alpha>&lt;beta>abcd&lt;/beta>")</code> returns a newly
               created document node, having two elements named <code>alpha</code> and <code>beta</code>
               as its children; each of these elements in turn is the parent of a text node.</p>
            <p>The expression <code>fn:parse-xml-fragment("He was &lt;i>so&lt;/i> kind")</code> returns a newly
               created document node having three children: a text node whose string value is
               <code>"He was "</code>, an element node named <code>i</code> having a child text
               node with string value <code>"so"</code>, and a text node whose string value is
               <code>" kind"</code>.</p>
            <p>The expression <code>fn:parse-xml-fragment("")</code> returns a document node
            having no children.</p>
            <p>The expression <code>fn:parse-xml-fragment(" ")</code> returns a document node
            whose children comprise a single text node whose string value is a single space.</p>
            <p>The expression <code>fn:parse-xml-fragment('&lt;xml version="1.0" encoding="utf8" standalone="yes"?>&lt;/a>")</code>
               results in a <phrase diff="add" at="L">dynamic</phrase> error <errorref class="DC" code="0006"/> because the "standalone" keyword
               is not permitted in the text declaration that appears at the start
            of an external general parsed entity. (Thus, it is not the case that any input accepted by the
            <code>fn:parse-xml</code> function will also be accepted by <code>fn:parse-xml-fragment</code>.)</p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="serialize">
      <fos:signatures>
         <fos:proto name="serialize" return-type="xs:string">
            <fos:arg name="arg" type="item()*"/>
         </fos:proto>
         <fos:proto name="serialize" return-type="xs:string">
            <fos:arg name="arg" type="item()*"/>
            <fos:arg name="params" type="element(output:serialization-parameters)?"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>This function serializes the supplied <phrase diff="chg" at="G">input
               sequence</phrase>
            <code>$arg</code> as described in <bibref ref="xslt-xquery-serialization-30"/>,
            returning the serialized <phrase diff="chg" at="G">representation of the
               sequence</phrase> as a string.</p>
      </fos:summary>
      <fos:rules>
         <p>The value of <code>$arg</code> acts as the input sequence to the serialization process,
            which starts with sequence normalization.</p>

         <p diff="chg" at="G">The single-argument version of this function has the same effect as
            the two-argument version called with <code>$params</code> set to an empty sequence. This
            in turn is the same as the effect of passing an
               <code>output:serialization-parameters</code> element with no child elements.</p>
         <p diff="chg" at="G">The <code>$params</code> argument is used to identify a set of
            serialization parameters. These are supplied in the form of an
               <code>output:serialization-parameters</code> element, having the format described in
               <xspecref spec="SER30" ref="serparams-in-xdm-instance"/>.</p>
         <p>The final stage of serialization, that is, encoding, is skipped. If the serializer does
            not allow this phase to be skipped, then the sequence of octets returned by the
            serializer is decoded into a string by reversing the character encoding performed in the
            final stage.</p>
      </fos:rules>
      <fos:errors>
         <p diff="add" at="L">If the host language makes serialization an optional feature and
         the implementation does not support serialization, then a dynamic error
            <errorref class="DC" code="0010"/> is raised.</p>
         <p>The serialization process will raise an error if <code>$arg</code> is an attribute or
            namespace node.</p>
         <p>If any serialization error occurs, including the detection of an invalid value for a
            serialization parameter, this results in the <code>fn:serialize</code> call failing with
            a dynamic error.</p>
      </fos:errors>
      <fos:notes>
         <p>One use case for this function arises when there is a need to construct an XML document
            containing nested XML documents within a CDATA section (or on occasions within a
            comment). See <code>fn:parse-xml</code> for further details.</p>
         <p>Another use case arises when there is a need to call an extension function that expects
            a lexical XML document as input.</p>
         <p>There are also use cases where the application wants to post-process the output of a
            query or transformation, for example by adding an internal DTD subset, or by inserting
            proprietary markup delimiters such as the <code>&lt;% ... %&gt;</code> used by some
            templating languages.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p diff="chg" at="L">Given the output parameters:</p>
         </fos:example>
         <fos:variable name="params" as="element()"><![CDATA[
<output:serialization-parameters xmlns:output="http://www.w3.org/2010/xslt-xquery-serialization">
  <output:omit-xml-declaration value="yes">
</output:serialization-parameters>]]>
         </fos:variable>
         <fos:variable name="data" as="element()"><![CDATA[
<a b='3'/>]]>
         </fos:variable>
         <fos:example>
            <p>The following call might produce the output shown:</p>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression><![CDATA[fn:serialize($data, $params)]]></fos:expression>
               <fos:result><![CDATA['<a b="3"/>']]></fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="position">
      <fos:signatures>
         <fos:proto name="position" return-type="xs:integer"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the context position from the dynamic context.</p>
      </fos:summary>
      
      <fos:rules>
         <p>Returns the context position from the dynamic context. (See <xspecref spec="XP30"
               ref="id-xp-evaluation-context-components"/>.)</p>
      </fos:rules>
      <fos:errors>
         <p>An error is raised <xerrorref spec="XP" class="DY" code="0002" type="type"/> if the
            context item is <xtermref ref="dt-absent" spec="DM30">absent</xtermref>.</p>
      </fos:errors>
   </fos:function>
   <fos:function name="last">
      <fos:signatures>
         <fos:proto name="last" return-type="xs:integer"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-dependent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the context size from the dynamic context.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the context size from the dynamic context. (See <xspecref spec="XP30"
               ref="id-xp-evaluation-context-components"/>.)</p>
      </fos:rules>
      <fos:errors>
         <p>An error is raised <xerrorref spec="XP" class="DY" code="0002" type="type"/> if the
            context item is <xtermref ref="dt-absent" spec="DM30">absent</xtermref>.</p>
      </fos:errors>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>(1 to 20)[fn:last() - 1]</fos:expression>
               <fos:result>19</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="current-dateTime">
      <fos:signatures>
         <fos:proto name="current-dateTime" return-type="xs:dateTimeStamp"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the current date and time (with timezone).</p>
      </fos:summary>
      <fos:rules>
         <p>Returns the current dateTime (with timezone) from the dynamic context. (See <xspecref
               spec="XP30" ref="id-xp-evaluation-context-components"/>.) This is an
               <code>xs:dateTime</code> that is current at some time during the evaluation of a
            query or transformation in which <code>fn:current-dateTime</code> is executed.</p>
         <p>This function is <termref def="dt-deterministic"/>. The precise instant during the query or
            transformation represented by the value of <code>fn:current-dateTime()</code> is
               <termref def="implementation-dependent"/>.</p>
         <p diff="chg" at="A">If the implementation supports data types from XSD 1.1 then the
            returned value will be an instance of <code>xs:dateTimeStamp</code>. Otherwise, the only
            guarantees are that it will be an instance of <code>xs:dateTime</code> and will have a
            timezone component.</p>
      </fos:rules>
      <fos:notes>
         <p>The returned <code>xs:dateTime</code> will always have an associated timezone, which
            will always be the same as the implicit timezone in the dynamic context</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p><code>fn:current-dateTime()</code> returns an <code>xs:dateTimeStamp</code>
               corresponding to the current date and time. For example, a call of
                  <code>fn:current-dateTime()</code> might return
                  <code>2004-05-12T18:17:15.125Z</code> corresponding to the current time on May 12,
               2004 in timezone <code>Z</code>. </p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="current-date">
      <fos:signatures>
         <fos:proto name="current-date" return-type="xs:date"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the current date.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns <code>xs:date(fn:current-dateTime())</code>. This is an <code>xs:date</code>
            (with timezone) that is current at some time during the evaluation of a query or
            transformation in which <code>fn:current-date</code> is executed.</p>
         <p>This function is <termref def="dt-deterministic"/>. The precise instant during the query or
            transformation represented by the value of <code>fn:current-date</code> is <termref
               def="implementation-dependent"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>The returned date will always have an associated timezone, which will always be the same
            as the implicit timezone in the dynamic context</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p><code>fn:current-date()</code> returns an <code>xs:date</code> corresponding to the
               current date. For example, a call of <code>fn:current-date()</code> might return
                  <code>2004-05-12+01:00</code>. </p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="current-time">
      <fos:signatures>
         <fos:proto name="current-time" return-type="xs:time"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the current time.</p>
      </fos:summary>
      <fos:rules>
         <p>Returns <code>xs:time(fn:current-dateTime())</code>. This is an <code>xs:time</code>
            (with timezone) that is current at some time during the evaluation of a query or
            transformation in which <code>fn:current-time</code> is executed.</p>
         <p>This function is <termref def="dt-deterministic"/>. The precise instant during the query or
            transformation represented by the value of <code>fn:current-time()</code> is <termref
               def="implementation-dependent"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>The returned time will always have an associated timezone, which will always be the same
            as the implicit timezone in the dynamic context</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <p><code>fn:current-time()</code> returns an <code>xs:time</code> corresponding to the
               current time. For example, a call of <code>fn:current-time()</code> might return
                  <code>23:17:00.000-05:00</code>. </p>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="implicit-timezone">
      <fos:signatures>
         <fos:proto name="implicit-timezone" return-type="xs:dayTimeDuration"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the value of the implicit timezone property from the dynamic context.
         </p>
      </fos:summary>
      <fos:rules>
         <p>Returns the value of the implicit timezone property from the dynamic context. Components
            of the dynamic context are discussed in <xspecref spec="XP30"
               ref="id-xp-evaluation-context-components"/>.</p>
      </fos:rules>
   </fos:function>
   <fos:function name="default-collation">
      <fos:signatures>
         <fos:proto name="default-collation" return-type="xs:string"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the value of the default collation property from the static context.
         </p>
      </fos:summary>
      <fos:rules>
         <p>Returns the value of the default collation property from the static context. Components
            of the static context are discussed in <xspecref spec="XP30"
               ref="id-xp-static-context-components"/>.</p>
      </fos:rules>
      <fos:notes>
         <p>The default collation property can never be absent. If it is not explicitly defined, a
            system defined default can be invoked. If this is not provided, the Unicode codepoint
            collation (<code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>) is
            used. </p>
      </fos:notes>
   </fos:function>
   <fos:function name="static-base-uri">
      <fos:signatures>
         <fos:proto name="static-base-uri" return-type="xs:anyURI?"/>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property dependency="static-base-uri">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>This function returns the value of the Static Base URI property from the static context.</p>
      </fos:summary>
      <fos:rules>
         <p>The function returns the value of the Static Base URI property from the static context. If the
            property is absent, the empty sequence is returned.</p>
         <p>Components of the static context are discussed in <xspecref spec="XP30"
               ref="eval_context"/> .</p>
      </fos:rules>
      <fos:notes>
         <p diff="add" at="L">XQuery 3.0 and XSLT 3.0 give an implementation freedom to use different base URIs during the
         static analysis phase and the dynamic evaluation phase, that is, for compile-time and run-time resources respectively.
         In this situation, the <code>fn:static-base-uri</code> function should return a URI suitable for locating resources needed
         during dynamic evaluation.</p>
      </fos:notes>
   </fos:function>
   <fos:function name="function-lookup" diff="add" at="J">
      <fos:signatures>
         <fos:proto name="function-lookup" return-type="function(*)?">
            <fos:arg name="name" type="xs:QName"/>
            <fos:arg name="arity" type="xs:integer"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the function having a given name and arity, if there is one.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$function-name</code> and <code>$function-arity</code> identify a named function
            that is present in the dynamic context, then
         a function item corresponding to that named function is returned.</p>
         
         <p>Otherwise (if no known function can be identified by name and arity), 
         an empty sequence is returned.</p>
         
         <p>If the arguments to <code>fn:function-lookup</code> identify a function that is present
         in the static context of the function call, the function will always return the same function
         that a static reference to this function would bind to. If there is no such function in the
         static context, then the results depend on what is present in the dynamic context, which
         is <termref def="implementation-defined">implementation-defined</termref>.</p>
         
         
         
      </fos:rules>
      <!--<fos:errors>
         <p diff="del" at="K">If the function that is identified is 
            <termref def="dt-context-dependent">context-dependent</termref>, <code>fn:function-lookup</code>
            returns a function whose name and signature match those of the requested function, but
            whose implementation is a call on the <code>fn:error</code> function, so that any attempt to
            call the returned function fails with a dynamic error.</p>
      </fos:errors>-->
      <fos:notes>
         <p>This function can be useful where there is a need to make a dynamic decision on which
         of several statically-known functions to call. It can thus be used as a substitute for polymorphism,
         in the case where the application has been designed so several functions implement the same
         interface.</p>
         <p>The function can also be useful in cases where a query or stylesheet module is written to work 
            with alternative versions of a library module. In such cases the author of the main module might wish to
            test whether an imported library module contains or does not contain a particular function, and to
            call a function in that module only if it is available in the version that was imported. A static
            call would cause a static error if the function is not available, whereas getting the function
            using <code>fn:function-lookup</code> allows the caller to take fallback action in this situation.
         </p>
         <p diff="add" at="L">If the function that is retrieved by <code>fn:function-lookup</code> has dependencies
         on the static or dynamic context, the context that applies is the static and/or dynamic context of the
         call to the <code>fn:function-lookup</code> function itself. The context thus effectively forms part of the
         closure of the returned function.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:function-lookup(xs:QName('fn:substring'), 2)('abcd', 2)</fos:expression>
               <fos:result>'bcd'</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            
            <p>The expression <code>(fn:function-lookup(xs:QName('xs:dateTimeStamp'), 1), xs:dateTime#1)[1] ('2011-11-11T11:11:11Z')</code>
            returns an <code>xs:dateTime</code> value set to the specified date, time, and timezone; if the implementation supports
            XSD 1.1 then the result will be an instance of the derived type <code>xs:dateTimeStamp</code>. The query is written to
            ensure that no failure occurs when the implementation does not recognize the type <code>xs:dateTimeStamp</code>.</p>
               
            
         </fos:example>
         <fos:example>
            <p diff="add" at="K">The expression <code>(let $f := fn:function-lookup(xs:QName('zip:binary-entry', 2) 
            return if (exists($f)) then $f($href, $entry) else ()</code> returns the result of calling
            <code>zip:binary-entry($href, $entry)</code> if the function is available, or an empty sequence
            otherwise.</p>
         </fos:example>
         
      </fos:examples>
   </fos:function>
   <fos:function name="function-name" diff="chg" at="C">
      <fos:signatures>
         <fos:proto name="function-name" return-type="xs:QName?">
            <fos:arg name="func" type="function(*)"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the name of the function identified by a function item.</p>
      </fos:summary>
      <fos:rules>
         <p>If <code>$func</code> refers to a named function, <code>fn:function-name($func)</code>
            returns the name of that function.</p>
         <p>Otherwise (<code>$func</code> refers to an anonymous function),
               <code>fn:function-name($func)</code> returns an empty sequence.</p>
         <p>The prefix part of the returned QName is <termref def="implementation-dependent"/>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:function-name(fn:substring#2)</fos:expression>
               <fos:result>fn:QName("http://www.w3.org/2005/xpath-functions",
               "fn:substring")</fos:result>
               <fos:postamble>The namespace prefix of the returned QName is not predictable.</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:function-name(function($node){count($node/*)})</fos:expression>
               <fos:result>()</fos:result>
            </fos:test>
         </fos:example>

      </fos:examples>
   </fos:function>
   <fos:function name="function-arity" diff="chg" at="C">
      <fos:signatures>
         <fos:proto name="function-arity" return-type="xs:integer">
            <fos:arg name="func" type="function(*)"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the arity of the function identified by a function item.</p>
      </fos:summary>
      <fos:rules>
         <p>The <code>fn:function-arity</code> function returns the arity (number of arguments) of
            the function identified by <code>$func</code>.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:function-arity(fn:substring#2)</fos:expression>
               <fos:result>2</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:function-arity(function($node){name($node)})</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>let $initial := fn:substring(?, 1, 1) return fn:function-arity($initial)</fos:expression>
               <fos:result>1</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="for-each" diff="add" at="C">
      <fos:signatures>
         <fos:proto name="for-each" return-type="item()*">
            <fos:arg name="seq" type="item()*"/>
            <fos:arg name="f" type="function(item()) as item()*"/>
            
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Applies the function item <var>$f</var> to every item from the sequence
               <var>$seq</var> in turn, returning the concatenation of the resulting sequences in
            order.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of the function is equivalent to the following implementation in XQuery:</p>
         <eg><![CDATA[
declare function fn:map($f, $seq) {
  if (fn:empty($seq))
  then ()
  else $f(fn:head($seq)), fn:map($f, fn:tail($seq))
};]]></eg>
         <p>or its equivalent in XSLT:</p>
         <eg><![CDATA[
<xsl:function name="fn:map">
  <xsl:param name="f"/>
  <xsl:param name="seq/>
  <xsl:if test="fn:exists($seq)">
    <xsl:sequence select="$f(fn:head($seq)), fn:map($f, fn:tail($seq))"/>
  </xsl:if>
</xsl:function>]]>
         </eg>
      </fos:rules>
      <fos:notes>
         <p>The function call <code>fn:map($F, $SEQ)</code> is equivalent to the expression
               <code>for $i in $SEQ return $F($i)</code><phrase diff="add" at="G">, assuming that
               ordering mode is <code>ordered</code>.</phrase></p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:map(function($a) { $a * $a }, 1 to 5)</fos:expression>
               <fos:result>(1, 4, 9, 16, 25)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:map(fn:string-to-codepoints#1, ("john", "jane"))</fos:expression>
               <fos:result>(106, 111, 104, 110, 106, 97, 110, 101)</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:map(xs:int#1, ("23", "29"))</fos:expression>
               <fos:result>(23, 29)</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="filter" diff="add" at="D">
      <fos:signatures>
         <fos:proto name="filter" return-type="item()*">
            <fos:arg name="seq" type="item()*"/><fos:arg name="f" type="function(item()) as xs:boolean"/>
            
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns those items from the sequence <var>$seq</var> for which the supplied
            function <var>$f</var> returns true.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of the function is equivalent to the following implementation in XQuery:</p>
         <eg><![CDATA[
declare function fn:filter(
        $f as function(item()) as xs:boolean, 
        $seq as item()*)
        as item()* {
  if (fn:empty($seq))
  then ()
  else ( fn:head($seq)[$f(.) eq fn:true()], 
         fn:filter($f, fn:tail($seq))
       )
};]]></eg>
         <p>or its equivalent in XSLT:</p>
         <eg><![CDATA[
<xsl:function name="fn:filter" as="item()*">
  <xsl:param name="f" as="function(item()) as xs:boolean"/>
  <xsl:param name="seq" as="item()*"/>
  <xsl:if test="fn:exists($seq)">
    <xsl:sequence select="fn:head($seq)[$f(.) eq fn:true()], fn:filter($f, fn:tail($seq))"/>
  </xsl:if>
</xsl:function>]]>
         </eg>
      </fos:rules>
      <fos:errors>
         <p diff="chg" at="G">As a consequence of the function signature and the function calling
            rules, a type error occurs if the supplied function <var>$f</var> returns anything other
            than a single <code>xs:boolean</code> item; there is no conversion to an effective
            boolean value.</p>
      </fos:errors>
      <fos:notes>
         <p>The function call <code>fn:filter($F, $SEQ)</code> has a very similar effect to the
            expression <code>$SEQ[$F(.)]</code>. There are some differences, however. In the case of
               <code>fn:filter</code>, the function <code>$F</code> is required to return a boolean;
            there is no special treatment for numeric predicate values, and no conversion to an
            effective boolean value. Also, with a filter expression <code>$SEQ[$F(.)]</code>, the
            focus within the predicate is different from that outside; this means that the use of
            a context-sensitive function such as <code>fn:lang#1</code> will give different results
            in the two cases.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:filter(function($a) {$a mod 2 = 0}, 1 to 10)</fos:expression>
               <fos:result>(2, 4, 6, 8, 10)</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="fold-left" diff="add" at="D">
      <fos:signatures>
         <fos:proto name="fold-left" return-type="item()*">
            <fos:arg name="seq" type="item()*"/>
            <fos:arg name="zero" type="item()*"/>
            <fos:arg name="f" type="function(item()*, item()) as item()*"/>
            
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Processes the supplied sequence from left to right, applying the supplied
            function repeatedly to each item in turn, together with an accumulated result value.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of the function is equivalent to the following implementation in XQuery:</p>
         <eg><![CDATA[
declare function fn:fold-left(
        $f as function(item()*, item()) as item()*, 
        $zero as item()*, 
        $seq as item()*) 
        as item()* {
  if (fn:empty($seq))
  then $zero
  else fn:fold-left($f, $f($zero, fn:head($seq)), fn:tail($seq))
};]]></eg>
         <p>or its equivalent in XSLT:</p>
         <eg><![CDATA[
<xsl:function name="fn:fold-left" as="item()*">
  <xsl:param name="f" as="function(item()*, item()) as item()*"/>
  <xsl:param name="zero" as="item()*"/>
  <xsl:param name="seq" as="item()*"/>
  <xsl:choose>
    <xsl:when test="fn:empty($seq)">
      <xsl:sequence select="$zero"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:sequence select="fn:fold-left($f, $f($zero, fn:head($seq)), fn:tail($seq))"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>]]>
         </eg>
      </fos:rules>
      <fos:errors>
         <p diff="chg" at="G">As a consequence of the function signature and the function calling
            rules, a type error occurs if the supplied function <var>$f</var> cannot be applied to
            two arguments, where the first argument is either the value of <var>$zero</var> or the
            result of a previous application of <var>$f</var>, and the second is <var>$seq</var> or
            any trailing subsequence of <var>$seq</var>.</p>
      </fos:errors>
      <fos:notes>
         <p>This operation is often referred to in the functional programming literature as
            "folding" or "reducing" a sequence. It takes a function that operates on a pair of
            values, and applies it repeatedly, with an accumulated result as the first argument, and
            the next item in the sequence as the second argument. The accumulated result is
            initially set to the value of the <var>$zero</var> argument, which is conventionally a
            value (such as zero in the case of addition, one in the case of multiplication, or a
            zero-length string in the case of string concatenation) that causes the function to
            return the value of the other argument unchanged.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-left(function($a, $b) { $a + $b }, 0, 1 to
                  5)</fos:expression>
               <fos:result>15</fos:result>
               <fos:postamble>This returns the sum of the items in the sequence</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-left(function($a, $b) { $a * $b }, 1,
                  (2,3,5,7))</fos:expression>
               <fos:result>210</fos:result>
               <fos:postamble>This returns the product of the items in the sequence</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-left(function($a, $b) { $a or $b }, false(), (true(),
                  false(), false()))</fos:expression>
               <fos:result>true()</fos:result>
               <fos:postamble>This returns true if any item in the sequence has an effective boolean
                  value of true</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-left(function($a, $b) { $a and $b }, false(), (true(),
                  false(), false()))</fos:expression>
               <fos:result>false()</fos:result>
               <fos:postamble>This returns true only if every item in the sequence has an effective
                  boolean value of true</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-left(function($a, $b) {($b, $a)}, (), 1 to
                  5)</fos:expression>
               <fos:result>(5,4,3,2,1)</fos:result>
               <fos:postamble>This reverses the order of the items in a sequence</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-left(fn:concat(?, ".", ?), "", 1 to 5)</fos:expression>
               <fos:result>".1.2.3.4.5"</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-left(fn:concat("$f(", ?, ", ", ?, ")"), "$zero", 1 to
                  5)</fos:expression>
               <fos:result>"$f($f($f($f($f($zero, 1), 2), 3), 4), 5)"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="fold-right" diff="add" at="D">
      <fos:signatures>
         <fos:proto name="fold-right" return-type="item()*">
            <fos:arg name="seq" type="item()*"/>
            <fos:arg name="zero" type="item()*"/>
            <fos:arg name="f" type="function(item()*, item()) as item()*"/>
            
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Processes the supplied sequence from right to left, applying the supplied
            function repeatedly to each item in turn, together with an accumulated result value.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of the function is equivalent to the following implementation in XQuery:</p>
         <eg><![CDATA[
declare function fn:fold-right(
        $f as function(item(), item()*) as item()*, 
        $zero as item()*, 
        $seq as item()*) 
        as item()* {
  if (fn:empty($seq))
  then $zero
  else $f(fn:head($seq), fn:fold-right($f, $zero, fn:tail($seq)))
};]]></eg>
         <p>or its equivalent in XSLT:</p>
         <eg><![CDATA[
<xsl:function name="fn:fold-right" as="item()*">
  <xsl:param name="f" as="function(item(), item()*) as item()*"/>
  <xsl:param name="zero" as="item()*"/>
  <xsl:param name="seq" as="item()*"/>
  <xsl:choose>
    <xsl:when test="fn:empty($seq)">
      <xsl:sequence select="$zero"/>
    </xsl:when>
    <xsl:otherwise>
      <xsl:sequence select="$f(fn:head($seq), fn:fold-right($f, $zero, fn:tail($seq))"/>
    </xsl:otherwise>
  </xsl:choose>
</xsl:function>]]>
         </eg>
      </fos:rules>
      <fos:errors>
         <p diff="chg" at="G">As a consequence of the function signature and the function calling
            rules, a type error occurs if the supplied function <var>$f</var> cannot be applied to
            two arguments, where the first argument is any item in the sequence <var>$seq</var>, and
            the second is either the value of <var>$zero</var> or the result of a previous
            application of <var>$f</var>.</p>

      </fos:errors>
      <fos:notes>
         <p>This operation is often referred to in the functional programming literature as
            "folding" or "reducing" a sequence. It takes a function that operates on a pair of
            values, and applies it repeatedly, with the next item in the sequence as the first
            argument, and the result of processing the remainder of the sequence as the second
            argument. The accumulated result is initially set to the value of the <var>$zero</var>
            argument, which is conventionally a value (such as zero in the case of addition, one in
            the case of multiplication, or a zero-length string in the case of string concatenation)
            that causes the function to return the value of the other argument unchanged.</p>
         <p>In cases where the function performs an associative operation on its two arguments (such
            as addition or multiplication), <code>fn:fold-right</code> produces the same result as
               <code>fn:fold-left</code>.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-right(function($a, $b) { $a + $b }, 0, 1 to
                  5)</fos:expression>
               <fos:result>15</fos:result>
               <fos:postamble>This returns the sum of the items in the sequence</fos:postamble>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-right(fn:concat(?, ".", ?), "", 1 to 5)</fos:expression>
               <fos:result>"1.2.3.4.5."</fos:result>
            </fos:test>
         </fos:example>
         <fos:example>
            <fos:test>
               <fos:expression>fn:fold-right(concat("$f(", ?, ", ", ?, ")"), "$zero", 1 to
                  5)</fos:expression>
               <fos:result>"$f(1, $f(2, $f(3, $f(4, $f(5, $zero)))))"</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="for-each-pair" diff="add" at="D">
      <fos:signatures>
         <fos:proto name="for-each-pair" return-type="item()*">
            <fos:arg name="seq1" type="item()*"/>
            <fos:arg name="seq2" type="item()*"/>
            <fos:arg name="f" type="function(item(), item()) as item()*"/>
            
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Applies the function item <var>$f</var> to successive pairs of items taken one
            from <var>$seq1</var> and one from <var>$seq2</var>, returning the concatenation of the
            resulting sequences in order.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of the function is equivalent to the following implementation in XQuery:</p>
         <eg><![CDATA[
declare function fn:map-pairs($f, $seq1, $seq2)
{
   if(fn:exists($seq1) and fn:exists($seq2)) 
   then (
     $f(fn:head($seq1), fn:head($seq2)),
     fn:map-pairs($f, fn:tail($seq1), fn:tail($seq2))
   )
   else ()
};]]></eg>
         <p>or its equivalent in XSLT:</p>
         <eg><![CDATA[
<xsl:function name="fn:map-pairs">
  <xsl:param name="f"/>
  <xsl:param name="seq1/>
  <xsl:param name="seq2/>
  <xsl:if test="fn:exists($seq1) and fn:exists($seq2">
    <xsl:sequence select="$f(fn:head($seq1), fn:head($seq2))"/>
    <xsl:sequence select="fn:map-pairs($f, fn:tail($seq1), fn:tail($seq2))"/>
  </xsl:if>
</xsl:function>]]>
         </eg>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:map-pairs(concat#2, ("a", "b", "c"), ("x", "y",
                  "z"))</fos:expression>
               <fos:result>("ax", "by", "cz")</fos:result>
            </fos:test>
         </fos:example>
         <!--<fos:example>
            <fos:test>
               <fos:expression><![CDATA[fn:map-pairs(function($a, $b){<e a="{$a}" b="{$b}"/>}, (1 to 3), ("x", "y", "z"))]]></fos:expression>
               <fos:result as="element()*"><![CDATA[(<e a="1" b="x"/>, <e a="2" b="y"/>, <e a="3" b="z"/>)]]></fos:result>
               <fos:postamble>This example uses XQuery syntax</fos:postamble>
            </fos:test>
         </fos:example>-->
         <fos:example>
            <fos:test>
               <fos:expression>fn:map-pairs(function($a, $b){10*$a + $b}, 1 to 5, 1 to
                  5)</fos:expression>
               <fos:result>(11, 22, 33, 44, 55)</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="new" prefix="map" diff="add" at="MAP">
      <fos:signatures>
         <fos:proto name="new" return-type="map(*)"/>
         <fos:proto name="new" return-type="map(*)">
            <fos:arg name="maps" type="map(*)*"/>
         </fos:proto>
         
      </fos:signatures>
      <fos:properties arity="1">
         <fos:property>deterministic</fos:property>
         <fos:property dependency="collations implicit-timezone">context-dependent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      
      <fos:summary>
         <p>Creates a new map: either an empty map, or a map that combines entries from a number of
            existing maps.</p>
      </fos:summary>
      <fos:rules>
         <p>The function <function>map:new</function> constructs and returns a new map.</p>

         <p>The zero-argument form of the function returns an empty <termref def="dt-map"
               >map</termref> whose collation is the default collation in the static context. It is
            equivalent to calling the one-argument form of the function with an empty sequence as
            the value of the first argument.</p>

         <p>The one-argument form of the function returns a <termref def="dt-map">map</termref> that
            is formed by combining the contents of the maps supplied in the <code>$input</code>
            argument. It is equivalent to calling the two-argument form of the function with the
            default collation from the static context as the second argument.</p>

         <p>The two-argument form of the function returns a <termref def="dt-map">map</termref> that
            is formed by combining the contents of the maps supplied in the <code>$input</code>
            argument. The collation of the new map is the value of the <code>$collation</code>
            argument. The supplied maps are combined as follows:</p>

         <olist>
            <item>
               <p>There is one entry in the new map for each distinct key value present in the union
                  of the input maps, where keys are considered distinct according to the rules of
                  the <code>fn:distinct-values</code> function with <code>$collation</code> as the
                  collation.</p>
            </item>
            <item>
               <p>The associated value for each such key is taken from the last map in the input
                  sequence <code>$input</code> that contains an entry with this key. If this map
                  contains more than one entry with this key (which can happen if its collation is
                  different from that of the new map) then it is <termref
                     def="implementation-dependent">implementation-dependent</termref> which of them
                  is selected.</p>
            </item>
         </olist>

         <p>There is no requirement that the supplied input maps should have the same or compatible
            types. The type of a map (for example <code>map(xs:integer, xs:string)</code>) is
            descriptive of the entries it currently contains, but is not a constraint on how the map
            may be combined with other maps.</p>
      </fos:rules>
      <fos:examples>
         <fos:variable name="week"
            select="map{0:=&quot;Sonntag&quot;, 1:=&quot;Montag&quot;, 2:=&quot;Dienstag&quot;,
            3:=&quot;Mittwoch&quot;, 4:=&quot;Donnerstag&quot;, 5:=&quot;Freitag&quot;, 6:=&quot;Samstag&quot;}"/>
         <fos:example>
            <fos:test>
               <fos:expression>map:new()</fos:expression>
               <fos:result>map{}</fos:result>
               <fos:postamble>Returns an empty map, whose collation is the default collation from
                  the static context</fos:postamble>
            </fos:test>
            <fos:test>
               <fos:expression>map:new(())</fos:expression>
               <fos:result>map{}</fos:result>
               <fos:postamble>Returns an empty map, whose collation is the default collation from
                  the static context</fos:postamble>
            </fos:test>
            <fos:test>
               <fos:expression>map:new((map:entry(0, "no"), map:entry(1, "yes")))</fos:expression>
               <fos:result>map{0:="no", 1:="yes"}</fos:result>
               <fos:postamble>Returns a map with two entries; the collation of the map is the
                  default collation from the static context</fos:postamble>
            </fos:test>
            <fos:test>
               <fos:expression>map:new((map:entry(0, "no"), map:entry(1, "yes")))</fos:expression>
               <fos:result>map{0:="no", 1:="yes"}</fos:result>
               <fos:postamble>Returns a map with two entries; the collation of the map is the
                  default collation from the static context</fos:postamble>
            </fos:test>
            <fos:test>
               <fos:expression>map:new(($week, map{7:="Unbekannt"}))</fos:expression>
               <fos:result>map{0:="Sonntag", 1:="Montag", 2:="Dienstag", 3:="Mittwoch",
                  4:="Donnerstag", 5:="Freitag", 6:="Samstag", 7:="Unbekannt"}</fos:result>
               <fos:postamble>The value of the existing map is unchanged; a new map is created
                  containing all the entries from <code>$week</code>, supplemented with a new
                  entry.</fos:postamble>
            </fos:test>
            <fos:test>
               <fos:expression>map:new(($week, map{6:="Sonnabend"}))</fos:expression>
               <fos:result>map{0:="Sonntag", 1:="Montag", 2:="Dienstag", 3:="Mittwoch",
                  4:="Donnerstag", 5:="Freitag", 6:="Sonnabend"}</fos:result>
               <fos:postamble>The value of the existing map is unchanged; a new map is created
                  containing all the entries from <code>$week</code>, with one entry replaced by a
                  new entry. Both input maps contain an entry with the key value <code>6</code>; the
                  one used in the result is the one that comes last in the input
                  sequence.</fos:postamble>
            </fos:test>

            <fos:test>
               <fos:expression>map:new((map{"A":=1}, map{"a":=2}),
                  "http://collation.example.com/caseblind")</fos:expression>
               <fos:result>map{"a":=2}</fos:result>
               <fos:postamble>Assuming that the keys of the two entries are equal under the rules of
                  the chosen collation, only one of the entries can appear in the result; the one
                  that is chosen is the one from the last map in the input sequence. If both entries
                  were in the same map, it would be implementation-dependent which was
                  chosen.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   
   <fos:function name="keys" prefix="map">
      <fos:signatures>
         <fos:proto name="keys" return-type="xs:anyAtomicType*">
            <fos:arg name="input" type="map(*)"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns a sequence containing all the key values present in a map</p>
      </fos:summary>
      <fos:rules>
         <p>The function <function>map:keys</function> takes any <termref def="dt-map">map</termref>
            as its <code>$input</code> argument and returns the keys that are present in the map as
            a sequence of atomic values, in <termref def="implementation-dependent"
               >implementation-dependent</termref> order.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>map:keys(map{1:="yes", 2:="no"})</fos:expression>
               <fos:result allow-permutation="true">(1,2)</fos:result>
               <fos:postamble>The result is in implementation-dependent order.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="size" prefix="map" diff="add" at="MAP">
      <fos:signatures>
         <fos:proto name="size" return-type="xs:integer">
            <fos:arg name="input" type="map(*)"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the number of entries in the supplied map.</p>
      </fos:summary>
      <fos:rules>
         <p>The function <function>map:size</function> takes any <termref def="dt-map">map</termref>
            as its <code>$input</code> argument and returns the number of entries that are present
            in the map.</p>
      </fos:rules>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>map:size(map:new())</fos:expression>
               <fos:result>0</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:size(map{"true":=1, "false":=0})</fos:expression>
               <fos:result>2</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="contains" prefix="map" diff="add" at="MAP">
      <fos:signatures>
         <fos:proto name="contains" return-type="xs:boolean">
            <fos:arg name="map" type="map(*)"/>
            <fos:arg name="key" type="xs:anyAtomicType"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Tests whether a supplied map contains an entry for a given key</p>
      </fos:summary>
      <fos:rules>
         <p>The function <function>map:contains</function> returns true if the <termref def="dt-map"
               >map</termref> supplied as <code>$map</code> contains an entry with a key equal to
            the supplied value of <code>$key</code>; otherwise it returns false. The equality
            comparison uses the map's collation; no error occurs if the map contains keys that are
            not comparable with the supplied <code>$key</code>.</p>

         <p>If the supplied key is <code>xs:untypedAtomic</code>, it is converted to
               <code>xs:string</code>. If the supplied key is the <code>xs:float</code> or
               <code>xs:double</code> value <code>NaN</code>, the function returns false.</p>
      </fos:rules>
      <fos:examples>
         <fos:variable name="week"
            select="map{0:=&quot;Sonntag&quot;, 1:=&quot;Montag&quot;, 2:=&quot;Dienstag&quot;,
            3:=&quot;Mittwoch&quot;, 4:=&quot;Donnerstag&quot;, 5:=&quot;Freitag&quot;, 6:=&quot;Samstag&quot;}"/>
         <fos:example>
            <fos:test>
               <fos:expression>map:contains($week, 2)</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:contains($week, 9)</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:contains(map{}, "xyz")</fos:expression>
               <fos:result>false()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:contains(map{"xyz":=23}, "xyz")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:contains(map{"abc":=23, "xyz":=()}, "xyz")</fos:expression>
               <fos:result>true()</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="get" prefix="map" diff="add" at="MAP">
      <fos:signatures>
         <fos:proto name="get" return-type="item()*">
            <fos:arg name="map" type="map(*)"/>
            <fos:arg name="key" type="xs:anyAtomicType"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Returns the value associated with a supplied key in a given map.</p>
      </fos:summary>
      <fos:rules>
         <p>The function <function>map:get</function> attempts to find an entry within the <termref
               def="dt-map">map</termref> supplied as <code>$input</code> that has a key equal to
            the supplied value of <code>$key</code>. If there is such an entry, it returns the
            associated value; otherwise it returns an empty sequence. The equality comparison uses
            the map's collation; no error occurs if the map contains keys that are not comparable
            with the supplied <code>$key</code>.</p>

         <p>If the supplied key is <code>xs:untypedAtomic</code>, it is converted to
               <code>xs:string</code>. If the supplied key is the <code>xs:float</code> or
               <code>xs:double</code> value <code>NaN</code>, the function returns an empty
            sequence.</p>
      </fos:rules>
      <fos:notes>
         <p>A return value of <code>()</code> from <function>map:get</function> could indicate that
            the key is present in the map with an associated value of <code>()</code>, or it could
            indicate that the key is not present in the map. The two cases can be distinguished by
            calling <function>map:contains</function>.</p>

         <p>Calling the <termref def="dt-map">map</termref> as a function item has the same effect
            as calling <code>get</code>: that is, when <code>$map</code> is a map, the expression
               <code>$map($K)</code> is equivalent to <code>get($map, $K)</code>. Similarly, the
            expression <code>get(get(get($map, 'employee'), 'name'), 'first')</code> can be written
            as <code>$map('employee')('name')('first')</code>. </p>
      </fos:notes>
      <fos:examples>
         <fos:variable name="week"
            select="map{0:=&quot;Sonntag&quot;, 1:=&quot;Montag&quot;, 2:=&quot;Dienstag&quot;,
            3:=&quot;Mittwoch&quot;, 4:=&quot;Donnerstag&quot;, 5:=&quot;Freitag&quot;, 6:=&quot;Samstag&quot;}"/>
         <fos:example>
            <fos:test>
               <fos:expression>map:get($week, 4)</fos:expression>
               <fos:result>"Donnerstag"</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:get($week, 9)</fos:expression>
               <fos:result>()</fos:result>
               <fos:postamble>When the key is not present, the function returns an empty
                  sequence.</fos:postamble>
            </fos:test>
            <fos:test>
               <fos:expression>map:get(map:entry(7,()), 7)</fos:expression>
               <fos:result>()</fos:result>
               <fos:postamble>An empty sequence as the result can also signify that the key is
                  present and the associated value is an empty sequence.</fos:postamble>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="entry" prefix="map" diff="add" at="MAP">
      <fos:signatures>
         <fos:proto name="entry" return-type="map(*)">
            <fos:arg name="key" type="xs:anyAtomicType"/>
            <fos:arg name="value" type="item()*"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Creates a map that contains a single entry (a key-value pair).</p>
      </fos:summary>
      <fos:rules>
         <p>The function <function>map:entry</function> returns a new <termref def="dt-map"
               >map</termref> containing a single entry. The collation of the new map is the 
            default collation from the static context. The key of the entry in the new map is
               <code>$key</code>, and its associated value is <code>$value</code>.</p>

         <p>If the supplied key is <code>xs:untypedAtomic</code>, it is converted to
               <code>xs:string</code>. If the supplied key is the <code>xs:float</code> or
               <code>xs:double</code> value <code>NaN</code>, the supplied <code>$map</code> is
            returned unchanged.</p>
      </fos:rules>
      <fos:notes>
         <p>The function <code>map:entry</code> is intended primarily for use in conjunction with
            the function <code>map:new</code>. For example, a map containing seven entries may be
            constructed like this:</p>

         <eg><![CDATA[
map:new((
   map:entry("Su", "Sunday"),
   map:entry("Mo", "Monday"),
   map:entry("Tu", "Tuesday"),
   map:entry("We", "Wednesday"),
   map:entry("Th", "Thursday"),
   map:entry("Fr", "Friday"),
   map:entry("Sa", "Saturday")
   ))]]></eg>
         <p>Unlike the <code>map{...}</code> expression, this technique can be used to construct a
            map with a variable number of entries, for example:</p>
         <eg><![CDATA[
map:new(for $b in //book return map:entry($b/isbn, $b))]]></eg>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>map:entry("M", "Monday")</fos:expression>
               <fos:result>map{"M":="Monday"}</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="remove" prefix="map" diff="add" at="MAP">
      <fos:signatures>
         <fos:proto name="remove" return-type="map(*)">
            <fos:arg name="map" type="map(*)"/>
            <fos:arg name="key" type="xs:anyAtomicType"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Constructs a new map by removing an entry from an existing map</p>
      </fos:summary>
      <fos:rules>
         <p>The function <function>map:remove</function> returns a new <termref def="dt-map"
               >map</termref>. The collation of the new map is the same as the collation of the map
            supplied as <code>$map</code>. The entries in the new map correspond to the entries of
               <code>$map</code>, excluding any entry whose key is equal to <code>$key</code>.</p>
         <p>No failure occurs if the input map contains no entry with the supplied key; the input
            map is returned unchanged</p>
      </fos:rules>
      <fos:examples>
         <fos:variable name="week"
            select="map{0:=&quot;Sonntag&quot;, 1:=&quot;Montag&quot;, 2:=&quot;Dienstag&quot;,
              3:=&quot;Mittwoch&quot;, 4:=&quot;Donnerstag&quot;, 5:=&quot;Freitag&quot;, 6:=&quot;Samstag&quot;}"/>
         <fos:example>
            <fos:test>
               <fos:expression>map:remove($week, 4)</fos:expression>
               <fos:result>map{0:="Sonntag", 1:="Montag", 2:="Dienstag", 3:="Mittwoch",
                  5:="Freitag", 6:="Samstag"}</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>map:remove($week, 23)</fos:expression>
               <fos:result>map{0:="Sonntag", 1:="Montag", 2:="Dienstag", 3:="Mittwoch",
                  4:="Donnerstag", 5:="Freitag", 6:="Samstag"}</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="parse-json" prefix="fn" diff="add" at="MAP">
      <fos:signatures>
         <fos:proto name="parse-json" return-type="item()?">
            <fos:arg name="json-text" type="xs:string"/>
         </fos:proto>
         <fos:proto name="parse-json" return-type="item()?">
            <fos:arg name="json-text" type="xs:string"/>
            <fos:arg name="options" type="map(*)"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Parses a string supplied in the form of a JSON text, returning the results in the form
            of a map.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of the one-argument form of this function is the same as calling the
            two-argument form with an empty map as the value of the <code>$options</code>
            argument.</p>

         <p>The first argument is a JSON-text (see below) in the form of a string. The function
            parses this string to return an XPath value. (To read a JSON file, the function can be
            used in conjunction with the <code>fn:unparsed-text</code> function).</p>

         <p>The <code>$options</code> argument can be used to control the way in which the parsing
            takes place. The value of the argument is a map, whose keys may be either strings or
            QNames. String-valued options are defined in this specification; QName-valued options
            have an <termref def="implementation-defined"/> effect.</p>

         <p>If the <code>$options</code> map contains an entry with the key <code>"spec"</code>, the
            value determines the specification of JSON that is to be used. The value "RFC4627"
            denotes [RFC4627], with no deviations from the grammar permitted. The value "ECMA-262"
            denotes the specification in section 15.12 of [ECMA-262 5th edition]. The value
            "liberal" indicates any <termref def="implementation-defined"/> superset of RFC4627 (or equivalently, an
            implementation that recovers from some or all errors in the input). The default is
            RFC4627.</p>

         <p>If the <code>$options</code> map contains an entry with the key <code>"unescape"</code>,
            the value determines whether escape sequences (marked by a backslash) in the input are
            expanded. The value is a boolean: <code>true</code> indicates that escape sequences are
            expanded into the characters they represent, while <code>false</code> indicates that
            they remain as escape sequences. The default is <code>true</code>. If the value is
               <code>true</code> and the input contains escape sequences representing characters or
            codepoints that are not valid characters in the version of XML supported by the
            implementation, a dynamic error occurs.</p>

         <p>The various structures that can occur in JSON are transformed recursively to XDM values
            as follows:</p>

         <olist>
            <item>
               <p>A JSON <emph>object</emph> is converted to a map. The collation of the map is the
                  Unicode codepoint collation. The entries in the map correspond to the key/value
                  pairs in the JSON object. The key is always of type <code>xs:string</code>; the
                  associated value may be of any type, and is the result of converting the JSON
                  value by recursive application of these rules. For example, the JSON text
                     <code>{"x":2, "y":5}</code> is transformed to the value <code>map{"x":=2,
                     "y":=5}</code>.</p>
            </item>
            <item>
               <p>A JSON <emph>array</emph> is transformed to a map whose keys are consecutive
                  integers starting at one, and whose associated values are the result of converting
                  the corresponding member of the array by recursive application of these rules. For
                  example, the JSON text <code>["a", "b", null]</code> is transformed to the value
                     <code>map{1:="a", 2:="b", 3:=()}</code>.</p>
            </item>
            <item>
               <p>A JSON <emph>string</emph> is converted to an <code>xs:string</code> value. If the
                     <code>unescape</code> option is set to <code>true</code> (or omitted), then
                  escaped characters are expanded (for example, <code>\n</code> becomes a single x0A
                  character, while <code>\u20AC</code> becomes the character <code>&#x20ac;</code>),
                  provided that the expansion is a valid XML character. A character that is not
                  valid in the version of XML used by the processor is then a dynamic error. If the
                     <code>unescape</code> option is set to <code>false</code>, escaped characters
                  are retained in their escaped form, and no error can then occur.</p>
            </item>
            <item>
               <p>A JSON <emph>number</emph> is converted to an <code>xs:double</code> value using
                  the rules for casting from <code>xs:string</code> to <code>xs:double</code>.</p>
            </item>
            <item>
               <p>The JSON <emph>boolean</emph> values <code>true</code> and <code>false</code> are
                  converted to the corresponding <code>xs:boolean</code> values.</p>
            </item>
            <item>
               <p>The JSON value <emph>null</emph> is converted to the empty sequence.</p>
            </item>
         </olist>


      </fos:rules>
      <fos:errors>
         <p>A dynamic error <errorref class="JS" code="0001"/> occurs if the value of
               <code>$input</code> does not conform to the JSON grammar, as selected using the
            explicit or implicit <code>spec</code> option.</p>
         <p>A dynamic error <errorref class="JS" code="0002"/> occurs if the value of
               <code>$input</code> contains an escaped representation of a character (or codepoint)
            that is not a valid character in the version of XML supported by the implementation,
            unless the <code>unescape</code> option is set to false.</p>
      </fos:errors>
      <fos:notes>
         <p>ECMA-262 differs from RFC 4627 in two respects: it does not allow the input to depart
            from the JSON grammar, but it does allow the top-level construct in the input to be a
            string, boolean, number, or null, rather than requiring an object or array.</p>
         <p>Many JSON implementations allow commas to be used after the last item in an object or
            array, though the specification does not permit it. The option
               <code>spec="liberal"</code> is provided to allow such deviations from the
            specification to be accepted. Some JSON implementations also allow constructors such as
               <code>new Date("2000-12-13")</code> to appear as values: specifying
               <code>spec="liberal"</code> allows such extensions to be accepted, but does not
            guarantee it. If such extensions are accepted, the resulting XDM value is
            implementation-defined.</p>
         <p>The result of the function will be an instance of one of the following types. An
               <code>instance of</code> test (or in XQuery, <code>typeswitch</code>) can be used to
            distinguish them:</p>
         <ulist>
            <item>
               <p><code>map(xs:string, xs:anyAtomicType)</code> for a JSON object</p>
            </item>
            <item>
               <p><code>map(xs:integer, xs:anyAtomicType)</code> for a JSON array</p>
            </item>
            <item>
               <p><code>xs:string</code> for a JSON string</p>
            </item>
            <item>
               <p><code>xs:double</code> for a JSON number</p>
            </item>
            <item>
               <p><code>xs:boolean</code> for a JSON boolean</p>
            </item>
            <item>
               <p><code>empty-sequence()</code> for a JSON null</p>
            </item>
         </ulist>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>parse-json('{"x":1, "y":[3,4,5]}')</fos:expression>
               <fos:result>map{"x":=1e0,"y":=map{1:=3e0,2:=4e0,3:=5e0}}</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>parse-json('"abcd"', map{'spec':='RFC4627'})</fos:expression>
               <fos:error-result error-code="FOJS0001"/>
            </fos:test>
            <fos:test>
               <fos:expression>parse-json('"abcd"', map{'spec':='ECMA-262'})</fos:expression>
               <fos:result>"abcd"</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>parse-json('{"x":"\\", "y":"\u0025"}')</fos:expression>
               <fos:result>map{"x":="\","y":="%"}</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>parse-json('{"x":"\\", "y":"\u0025"}',
                  map{'unescape':=false()})</fos:expression>
               <fos:result>map{"x":="\\","y":="\u0025"}</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>
   <fos:function name="serialize-json" prefix="fn" diff="add" at="MAP">
      <fos:signatures>
         <fos:proto name="serialize-json" return-type="xs:string">
            <fos:arg name="input" type="item()?"/>
         </fos:proto>
         <fos:proto name="serialize-json" return-type="xs:string">
            <fos:arg name="input" type="item()?"/>
            <fos:arg name="options" type="map(*)"/>
         </fos:proto>
      </fos:signatures>
      <fos:properties>
         <fos:property>deterministic</fos:property>
         <fos:property>context-independent</fos:property>
         <fos:property>focus-independent</fos:property>
      </fos:properties>
      <fos:summary>
         <p>Serializes an XDM value in the as a string conforming to the JSON grammar.</p>
      </fos:summary>
      <fos:rules>
         <p>The effect of the one-argument form of this function is the same as calling the
            two-argument form with an empty map as the value of the <code>$options</code>
            argument.</p>

         <p>The <code>$options</code> argument can be used to control the way in which the
            serialization takes place. The value of the argument is a map, whose keys may be either
            strings or QNames. String-valued options are defined in this specification; QName-valued
            options have an <termref def="implementation-defined"/> effect.</p>

         <p>In the absence of options specifying otherwise, the function applies the following rules
            to achieve the conversion, recursively.</p>

         <p>A value is <emph>JSON-serializable</emph> if it is one of the following:</p>

         <olist>
            <item>
               <p>An instance of <code>map(xs:string, item()?)</code> is JSON-serializable if the
                  value associated with every entry in the map is JSON-serializable. Such a value is
                  serialized as a JSON object.</p>
            </item>
            <item>
               <p>An instance of <code>map(xs:integer, item()?)</code> is JSON-serializable if the
                  value associated with every entry in the map is JSON-serializable. Such a value is
                  serialized as a JSON array.</p>
            </item>
            <item>
               <p>A sequence containing two or more items is JSON-serializable if each of its items
                  is JSON-serializable. Such a value is serialized as a JSON array.</p>
            </item>
            <item>
               <p>An atomic value of type <code>xs:string</code> is JSON-serializable; it is
                  serialized as a JSON string, after escaping other special characters using the
                  JSON backslash convention as described below.</p>
            </item>
            <item>
               <p>An atomic value of any numeric type is JSON-serializable; it is serialized as a
                  JSON number.</p>
            </item>
            <item>
               <p>An atomic value of type <code>xs:boolean</code> is JSON-serializable; it is
                  serialized as the JSON boolean value <code>true</code> or <code>false</code>.</p>
            </item>
            <item>
               <p>An empty sequence is JSON-serializable; it is serialized as the JSON value
                     <code>null</code>.</p>
            </item>
         </olist>

         <p>If the option <code>indent</code> is present it must have the boolean value
               <code>true</code> or <code>false</code>. The default is <code>false</code>. The value
               <code>true</code> indicates that whitespace should be added to the output with the
            aim of improving human legibility; the value <code>false</code> indicates that no
            optional whitespace should be added.</p>

         <p>If the option <code>escape</code> is present it must have the boolean value
               <code>true</code> or <code>false</code>. The default is <code>true</code>. The value
               <code>true</code> indicates that special characters <rfc2119>may</rfc2119> be escaped
            using the JSON backslash notation, and where the JSON syntax requires it, they
               <rfc2119>must</rfc2119> be escaped. The value <code>false</code> indicates that
            strings are already in escaped form and no further escaping is permitted; in this case a
            dynamic error [TBA] occurs if the resulting string is not valid according to the JSON
            grammar.</p>

         <p>If the option <code>fallback</code> is present its value must be an instance of
               <code>function($input as item()*) as item()?</code>. The supplied function is called
            when a value that is not JSON-serializable is encountered in a map. The function must
            return a value that is JSON-serializable, or that can be made JSON-serializable by
            recursive application of the function, and the serialization of this value will be
            inserted in the output as the serialization of the original value. For example,
            supplying the function <code>string#1</code> will convert all non-serializable values to
            strings, provided that the <code>fn:string</code> function is applicable to the value. </p>
         <p>If the option <code>spec</code> is present, then its value must be "RFC4627",
            "ECMA-262", or "liberal". If the value is "RFC4627" or "ECMA-262" then the result string
            must be one that can be successfully parsed using the <code>fn:parse-json</code>
            function with the same option set (if the input cannot be serialized into such a form, a
            dynamic error is reported). If the value is "liberal", the serialized form may use
            <termref def="implementation-defined"/> extensions to the JSON grammar, provided that they are accepted
            by the same implementation's <code>parse-json</code> function with the option
               <code>spec="liberal"</code>.</p>
      </fos:rules>
      <fos:errors>
         <p>A dynamic error [TBA] is reported if the supplied value cannot be serialized as a JSON
            text conforming to the rules of the specification selected by the explicit or implicit
               <code>spec</code> option.</p>
      </fos:errors>
      <fos:notes>
         <p>The <code>fallback</code> function can be used to customize what is serializable, and
            how it is serialized. For example, supplying the function <code>fn:string#1</code> will
            ensure that values such as dates and times are converted to strings. Supplying the
            function <code>fn:serialize-xml#1</code> will cause nodes to be serialized as strings
            containing lexical XML. More elaborate conversions can be achieved by specifying a
            user-defined function, for example one which converts an element node to a map.</p>

         <p>Although the value returned by the fallback function must be JSON-serializable, the
            fallback function will be called recursively if the value is a map that contains values
            that are not JSON-serializable.</p>
      </fos:notes>
      <fos:examples>
         <fos:example>
            <fos:test>
               <fos:expression>fn:serialize-json(map{"a":=1, "b":=(3 to 5)})</fos:expression>
               <fos:result>'{"a":1,"b":[3,4,5]}'</fos:result>
               <fos:result>'{"b":[3,4,5],"a":1}'</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:serialize-json(("a", "b", "c", "d"))</fos:expression>
               <fos:result>'["a","b","c","d"]'</fos:result>
            </fos:test>
            <fos:test>
               <fos:expression>fn:serialize-json(xs:date('2010-12-31'),
                  map{'spec':='ECMA-262','fallback':=fn:string#1})</fos:expression>
               <fos:result>'"2010-12-31"'</fos:result>
            </fos:test>
         </fos:example>
      </fos:examples>
   </fos:function>

</fos:functions>
